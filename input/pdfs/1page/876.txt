Un algorithme stable de dÃ©composition pour lâ€™analyse des
rÃ©seaux sociaux dynamiques
Romain Bourquiâˆ—, Paolo Simonettoâˆ—âˆ—
Fabien Jourdanâˆ—âˆ—
âˆ—LaBRI, UniversitÃ© Bordeaux 1, 351, cours de la LibÃ©ration F-33405 Talence cedex
{bourqui, simonett}@labri.fr
http://www.labri.fr/perso/{bourqui,simonett}
âˆ—âˆ—INRA, UMR1089, XÃ©nobiotiques, F-31000 Toulouse, France
Fabien.Jourdan@toulouse.inra.fr http://www.lirmm.fr/ fjourdan
RÃ©sumÃ©. Les rÃ©seaux dynamiques soulÃ¨vent de nouveaux problÃ¨mes dâ€™ana-
lyses. Un outils efficace dâ€™analyse doit non seulement permettre de dÃ©composer
ces rÃ©seaux en groupes dâ€™Ã©lÃ©ments similaires mais il doit aussi permettre la dÃ©-
tection de changements dans le rÃ©seau. Nous prÃ©sentons dans cet article une nou-
velle approche pour lâ€™analyse de tels rÃ©seaux. Cette technique est basÃ©e sur un
algorithme de dÃ©composition de graphe en groupes chevauchants (ou chevauche-
ment). La complexitÃ© de notre algorithme est O(|E| Â·deg2max+ |V | Â· log(|V |))).
La faible sensibilitÃ© de cet algorithme aux changements structuraux du rÃ©seau
permet dâ€™en dÃ©tecter les modifications majeures au cours du temps.
1 Introduction
Les graphes sont utiles dans de nombreux domaines tels que la biologie, la micro-Ã©lectroni-
que, les sciences sociales, lâ€™extraction de connaissance mais aussi lâ€™informatique (e.g. Newman
et Girvan (2004); Newman (2004); Palla et al. (2007); Suderman et Hallett (2007)). Il existe
notamment un certain nombre de travaux portant sur la dÃ©tection de communautÃ©s dans les
rÃ©seaux. Par exemple, en sciences sociales, les personnes ayant les mÃªmes centres dâ€™intÃ©rÃªt
ou en biologie, les enzymes dâ€™un rÃ©seau mÃ©tabolique intervenant dans un processus commun
(e.g. Newman et Girvan (2004); Newman (2004); Palla et al. (2007); Bader et Hogue (2003)).
La dÃ©tection de communautÃ©s offre deux atouts majeurs. En effet, elle permet non seulement
une analyse initiale des donnÃ©es mais surtout elle permet de construire une abstraction visuelle.
Trouver des groupes (ou communautÃ©s) dans un rÃ©seau est gÃ©nÃ©ralement traduit en un
problÃ¨me de dÃ©composition de graphe. Les algorithmes de dÃ©composition recherchent des
groupes dâ€™Ã©lÃ©ments (ou clusters) ayant une (ou plusieurs) propriÃ©tÃ©(s) commune(s). Le critÃ¨re
le plus largement admis pour quâ€™un ensemble de groupes forme une Â« bonne Â» dÃ©composition
du graphe est que la densitÃ© de chaque groupe soit Ã©levÃ©e mais aussi que la densitÃ© entre les
diffÃ©rents groupes soit faible.
Le problÃ¨me qui consiste Ã  extraire des communautÃ©s est rendu plus difficile si lâ€™on sâ€™intÃ©-
resse aux rÃ©seaux dynamiques. Les rÃ©seaux dynamiques sont de plus en plus frÃ©quents du fait
notamment de lâ€™amÃ©lioration des techniques dâ€™acquisitions ou encore de lâ€™augmentation du
Un algorithme de dÃ©composition pour lâ€™analyse des rÃ©seaux dynamiques
nombre de bases de donnÃ©es, que ce soit en biologie (e.g. lâ€™Ã©volution dâ€™un organisme en fonc-
tion de son environement) ou encore en sciences sociales (e.g. rÃ©seau de co-citation, rÃ©seau des
acteurs dâ€™Hollywood). Par consÃ©quent, il est nÃ©cessaire de pouvoir non seulement identifier
les communautÃ©s de ces rÃ©seaux mais aussi de pouvoir dÃ©tecter leurs changements structu-
raux (e.g. disparitions/crÃ©ations de communautÃ©s). La dÃ©composition des rÃ©seaux dynamiques
est actuellement un domaine en pleine effervescence (e.g. Popescul et al. (2000); Li et Yoo
(2005); Gaertler et al. (2006); Chakrabarti et al. (2006); HÃ¼bner (2008)). Tandis que certaines
de ces approches prennent en compte lâ€™attribut temporel pour dÃ©composer le graphe (Popescul
et al., 2000; Li et Yoo, 2005), dâ€™autres tentent de trouver des groupes Ã©voluant peu dans le
temps (Gaertler et al., 2006; Chakrabarti et al., 2006; HÃ¼bner, 2008).
Dans cet article, nous nous intÃ©ressons Ã  une mÃ©thode dâ€™analyse des rÃ©seaux dynamiques
basÃ©e sur la dÃ©composition. Notre mÃ©thode consiste Ã  Â«discrÃ©tiserÂ» le rÃ©seau dynamique en
un ensemble de rÃ©seaux statiques. Puis, nous appliquons un algorithme de dÃ©composition en
groupes chevauchants sur chacun de ces rÃ©seaux statiques. Afin de dÃ©tecter les changements
majeurs dans le rÃ©seau Ã©tudiÃ©, nous comparons ensuite les dÃ©compositions obtenues en utilisant
une mesure de similaritÃ©.
Cet article est organisÃ© comme suit : dans la section 2, nous prÃ©sentons une vue dâ€™ensemble
de notre mÃ©thode, puis dans la section 3 nous dÃ©crivons notre algorithme de dÃ©composition,
et enfin nous Ã©valuons la qualitÃ© et la Â«stabilitÃ©Â» de cet algorithme de dÃ©composition sur un
rÃ©seau social de rÃ©fÃ©rence dans la section 4.
2 Vue dâ€™ensemble de la mÃ©thode
FIG. 1 â€“ Description des trois Ã©tapes de la mÃ©thode.
La figure 1 illustre la mÃ©thode que nous prÃ©sentons dans cet article. La premiÃ¨re Ã©tape de
cette mÃ©thode consiste Ã  transformer un rÃ©seau dynamique en un ensemble de rÃ©seaux sta-
tiques. Si lâ€™on considÃ¨re un graphe dynamique G dÃ©fini sur un intervale de temps [0..T ], cette
transformation consiste Ã  construire un ensemble de graphes statiques {G[0,[, ..., G[Tâˆ’,T ]},
oÃ¹  est le facteur de Â«discrÃ©tisationÂ» et G[t,t+] est le graphe statique correspondant Ã  la pÃ©-
riode de temps [t, t+ ] (i.e. le graphe contenant les sommets et arÃªtes du graphe dynamiqueG
intervenant dans la pÃ©riode [t, t + ]). Lâ€™idÃ©e principale de notre approche est que si le graphe
Ã©volue peu (et si le facteur de discrÃ©tisation est correctement choisi) alors deux graphes sta-
R. Bourqui et al.
tiques correspondant Ã  deux pÃ©riodes consÃ©cutives ont des structures topologiques proches.
Pour comparer les topologies de ces graphes, nous utilisons tout dâ€™abord un algorithme de dÃ©-
composition puis nous utilisons une mesure de similaritÃ© de dÃ©compositions de graphes. Afin
que notre mÃ©thode soit efficace, nous devons garantir la similaritÃ© de dÃ©compositions obtenues
sur deux graphes dont les topologies sont proches.
Dans notre mÃ©thode, la qualitÃ© du rÃ©sultat dÃ©pend grandement du facteur de discrÃ©tisa-
tion choisi. Cependant, nous ne nous intÃ©ressons pas ici Ã  lâ€™Ã©tude de lâ€™impacte du facteur de
discrÃ©tisation qui est actuellement le sujet dâ€™un autre travail. Dans cet article, nous nous in-
tÃ©ressons tout particuliÃ¨rement Ã  un algorihme de dÃ©composition de graphe peu sensible Ã  de
faibles modifications structurelles. Cet algorithme a trois Ã©tapes principales : premiÃ¨rement,
nous calculons la mÃ©trique Strength (de Auber et al. (2003)) sur les arÃªtes et sommets, puis
nous cherchons un ensemble maximal de sommets indÃ©pendants (i.e. de sommets Ã  distance
au moins 2), enfin nous construisons les groupes Â«autourÂ» des sommets de lâ€™ensemble indÃ©-
pendant.
3 Algorithme
3.1 MÃ©trique Strength
Pour dÃ©finir la mÃ©trique Strength (Auber et al., 2003; Chiricota et al., 2003), nous de-
vons introduire quelques notations. Soient u et v deux sommets du graphe, on noteMu(v) =
NG(v) \ (NG(u)âˆª{u}) lâ€™ensemble des voisins de v (en excluant u) qui ne sont pas voisins de
u, et on noteWuv = NG(u) âˆ©NG(v) lâ€™ensemble des sommets voisins de u et de v. Soient A
et B deux ensembles de sommets, on note E(A,B) lâ€™ensemble des arÃªtes reliant un sommet
de A Ã  un sommet de B. Enfin, s(A,B) = |E(A,B)|/(|A| Â· |B|) est le ratio entre le nombre
dâ€™arÃªtes reliant A et B et le nombre maximal dâ€™arÃªtes quâ€™il pourrait y avoir entre ces deux
ensembles 1. La mÃ©trique Strength dâ€™une arÃªte e = (u, v), notÃ©e ws(e) est :
ws(e) =
Î³3,4(e)
Î³max(e)
(1)
oÃ¹ :
Î³3,4(e) = |Wuv|+ |E(Mv(u),Mu(v))|+ |E(Mv(u),Wuv)|
+ |E(Wuv,Mu(v))|+ |E(Wuv)|
(2)
Î³max(e) = |Mv(u)|+ |W (u, v)|+ |Mu(v)|+ |Mv(u)||Mu(v)|
+ |Mv(u)||Wuv|+ |Wuv||Mu(v)|+ |Wuv|(|Wuv| âˆ’ 1)/2
(3)
Cette mÃ©trique compte donc pour chaque arÃªte le nombre de cycles de longueur 3 et 4
passant par cette arÃªte et normalise cette valeur par le nombre maximum possible de tels cycles
(la figure 2 illustre les 3 ensembles formÃ©s par les voisinnage de u et v). Enfin, on peut dÃ©finir
la valeur de Strength dâ€™un sommet comme suit :
ws(u) =
âˆ‘
eâˆˆadj(u) ws(e)
deg(u)
1Lorsque A = B, on a s(A,A) = s(A) = 2 Â· |E(A)|/(|A| Â· (|A| âˆ’ 1))
Un algorithme de dÃ©composition pour lâ€™analyse des rÃ©seaux dynamiques
FIG. 2 â€“ La mÃ©trique Strength de lâ€™arÃªte e = (u, v) est calculÃ©e en comparant le nombre de
cycles de tailles 3 et 4 passant par cette arÃªte au nombre maximal de tels cycles.
oÃ¹ adj(u) est lâ€™ensemble des arÃªtes adjacentes Ã  u et deg(u) est le degrÃ© de u. La mÃ©trique
Strength permet donc de quantifier la cohÃ©sion du voisinnage dâ€™une arÃªte ou dâ€™un sommet.
Le temps nÃ©cessaire pour calculer cette mÃ©trique est O(|E| Â· deg2max) oÃ¹ degmax est le degrÃ©
maximum du graphe.
3.2 Extraction dâ€™un ensemble indÃ©pendant maximal
FIG. 3 â€“ (a) Sous-graphe du Â«graphe dâ€™HollywoodÂ» oÃ¹ les sommets reprÃ©sentent des acteurs
et deux sommets sont reliÃ©s si les acteurs correspondant ont participÃ© Ã  un film commun. La
couleur de chaque sommet correspond Ã  sa valeur de Strength, de la plus faible en jaune
Ã  la plus forte en bleu. (b) Si le sommet entourÃ© en rose est choisi comme Â«centreÂ» de la
communautÃ©, on pourrait alors obtenir un groupe unique contenant tous le rÃ©seau. (c) Dans le
cas oÃ¹, les sommets Â«centresÂ» sont des sommets de fortes valeurs de Strength, on obtient alors
trois groupes correspondant au trois films de ce rÃ©seau.
Pour identifier les Â«centresÂ» des communautÃ©s du rÃ©seau Ã©tudiÃ©, nous utilisons une mÃ©-
thode inspirÃ©e du MISF (pour Maximal Independant Set Filtering) de Gajer et Kobourov
(2000). Cette technique consiste Ã  extraire un ensemble maximal Î½ de sommets du rÃ©seau
tel que âˆ€u, v âˆˆ V , distG(u, v) â‰¥ 2. Elire un ensemble de sommets Ã  distance au moins 2
dans le graphe permet tout dâ€™abord dâ€™obtenir un bon Ã©chantillonnage du rÃ©seau. Dâ€™autre part,
cela permet de dÃ©terminer automatiquement le nombre de groupes en fonction de la topologie
du graphe. Enfin, cette technique nous garantit lâ€™unicitÃ© de chaque groupe trouvÃ© par notre
algorithme (i.e. deux groupes obtenus par notre approche ne peuvent Ãªtre identiques).
R. Bourqui et al.
Etant donnÃ© que les sommets deÎ½ seront les Â«centresÂ» de nos communautÃ©s, ces sommets
ne doivent pas Ãªtre des Â«pivotsÂ» du rÃ©seau. Si on utilise lâ€™un de ces sommets pivots comme
Â«centreÂ» dâ€™un groupe, ce groupe pourrait alors contenir plusieurs communautÃ©s (cf figure 3).
La mÃ©trique Strength calculÃ©e sur les sommets nous permet dâ€™identifier ces pivots. En ef-
fet, les sommets situÃ©s Ã  lâ€™intersection de plusieurs communautÃ©s ont des valeurs de Strength
relativement faible. Les sommets de fortes valeurs de Strength doivent donc Ãªtre ajoutÃ©s prio-
ritairement Ã  lâ€™ensemble Î½ . Nous utilisons lâ€™algorithme 1 pour extraire un tel ensemble de
sommets.
Input : A graph G = (V,E)
Output : A maximal setÎ½ of vertices at distance at least 2
vector<node> sorted_nodes;
sortNodeWithStrength(G, sorted_nodes);
for unsigned int i from 0 to (number of vertices in G) do
node u = sorted_nodes[i];
if u in G then
append(Î½ ,u);
foreach node v in neighborhood of u do
remove(G, v);
end
remove(G, u);
end
end
Algorithme 1 : Extraction de lâ€™ensemble Î½ . La fonction sortNodeWithStrength(G,
sorted_nodes) trie les sommets de G par ordre dÃ©croissant de valeur de Strength et stocke
le rÃ©sultat dans sorted_nodes.
La complexitÃ© de lâ€™algorithme de trie sortNodeWithStrength(Graph, vector<node>) est en
temps O(|V | Â· log(|V |)). En ce qui concerne la boucle for, on peut trivalement montrer que sa
complexitÃ© en temps et en espace est O(|V |+ |E|). Le coÃ»t total de lâ€™extration de lâ€™ensemble
Î½ est rÃ©alisÃ© en temps O(|V | Â· log(|V |) + |E|) et en espace O(|V |+ |E|).
3.3 DÃ©tection des groupes
Lâ€™algorithme 2 permet ensuite dâ€™extraire les groupes en utilisant lâ€™ensembleÎ½ . Le principe
de cet algorithme est de construire des Â«boulesÂ» de rayon 1 dans le graphe autour des sommets
Î½ . Pour chaque sommet u de Î½ , si une arÃªte (u, v) a une valeur de Strength supÃ©rieure Ã  une
borne  fixÃ©e, alors cette arÃªte doit Ãªtre intra-communautaire et par consÃ©quent le sommet v
est ajoutÃ© Ã  la communautÃ© de u. La borne  est calculÃ©e en fonction du nombre dâ€™arÃªtes du
graphe G = (V,E) et du nombre dâ€™arÃªtes du graphe complet Ã  |V | sommets. Lâ€™idÃ©e est que
moins le rÃ©seau est dense, moins les communautÃ©s contenues dans ce rÃ©seau sont denses. Dans
lâ€™algorithme 2, la borne  a Ã©tÃ© fixÃ©e empiriquement et peut Ãªtre modifiÃ©e afin de construire des
groupes plus ou moins tolÃ©rant aux Â«bruitsÂ».
En ce qui concerne la complexitÃ©, pour chaque sommet u de Î½ , lâ€™algorithme 2 parcourt
toutes les arÃªtes adjacentes Ã  u et a donc un coÃ»t en temps O(deg(u)). On obtient donc une
Un algorithme de dÃ©composition pour lâ€™analyse des rÃ©seaux dynamiques
Input : A graph G = (V,E), the Strength of each edge, a maximal setÎ½
Output : A set D of groups of vertices
double  = 2 Â· |E|/(|V | Â· (|V | âˆ’ 1));
foreach node u inÎ½ do
Group curGroup = createNewGroup();
append(curGroup, u);
foreach edge e = (u, v) adjacent to u do
if Strength(e) >  then
append(curGroup, v);
end
end
append(D, curGroup);
end
Algorithme 2 : Construction des groupes de sommets.
complexitÃ© en temps de O(
âˆ‘
uâˆˆÎ½
degu). Etant donnÃ© que
âˆ‘
uâˆˆV deg(u) = 2 Â· |E|, lâ€™algo-
rithme 2 est donc rÃ©alisÃ© en temps O(|E|) et en espace O(|V |+ |E|).
La complexitÃ© totale de notre algorithme de dÃ©composition est donc en temps O(|E| Â·
deg2max + |V | Â· log(|V |)) et en espace O(|V |+ |E|).
4 Evaluation de lâ€™algorithme
4.1 Cas dâ€™Ã©tude
Nous avons choisi comme cas dâ€™Ã©tude une sous-partie du jeu de donnÃ©es du concours Info-
Vis 2007 Contest (2007). Ce jeu de donnÃ©es est issu de la base de donnÃ©es cinÃ©matographique
IMDb (pour Internet Movie Database). Afin de pouvoir rÃ©aliser notre Ã©tude, nous en avons
extrait un sous-rÃ©seau de 432 films, 4025 acteurs. Nous avons ensuite contruit un graphe de
la maniÃ¨re suivante : un sommet du graphe reprÃ©sente un acteur et deux sommets du graphe
sont reliÃ©s par une arÃªte si les acteurs correspondant ont participÃ© Ã  (au moins) un film com-
mun. Nous avons ainsi obtenu un rÃ©seau de 4025 sommets et 41216 arÃªtes. La figure 4 montre
le graphe ainsi construit. Nous avons choisi ces donnÃ©es puisquâ€™il est bien connu quâ€™elles
contiennent des structures de communautÃ©s, typiquement chaque film est reprÃ©sentÃ© par une
clique (sous-graphe complet) et ces cliques peuvent partager des sommets (correspondant aux
acteurs ayant participÃ© Ã  plusieurs films).
Afin dâ€™Ã©valuer la qualitÃ© de notre algorithme de dÃ©composition, nous utilisons deux cri-
tÃ¨res. Le premier de ces critÃ¨res est la qualitÃ© de la dÃ©composition produite par notre algo-
rithme. Pour Ã©valuer cette qualitÃ©, nous utilisons une gÃ©nÃ©ralisation de la mesure de qualitÃ©
MQ introduite par Mancoridis et al. (1998) au cas des dÃ©compositions chevauchantes. Le
deuxiÃ¨me critÃ¨re est une mesure de la Â«sensibilitÃ©Â» de notre algorithme aux modifications
structurelles du rÃ©seau. Pour cela, nous comparons la dÃ©composition obtenue sur le graphe ori-
ginal Ã  une dÃ©composition obtenue aprÃ¨s un certain nombre de modifications structurelles du
rÃ©seau.
R. Bourqui et al.
FIG. 4 â€“ Sous-graphe du Â«graphe dâ€™HollywoodÂ». Ce sous-graphe correspond Ã  un ensemble
de 432 films et contient 4025 sommets (acteurs) et 41216 arÃªtes. La couleur de chaque sommet
correspond Ã  sa valeur de Strength (de la plus faible en jaune Ã  la plus forte en bleu).
4.2 QualitÃ© de la dÃ©composition
Le critÃ¨re le plus largement admis pour quâ€™un ensemble de groupes forme une Â« bonne Â» dÃ©-
composition du graphe est une densitÃ© intra-groupe Ã©levÃ©e et une densitÃ© inter-groupes faible.
Nous utilisons pour Ã©valuer la qualitÃ© dâ€™une dÃ©composition une gÃ©nÃ©ralisation de la mesure de
qualitÃ© MQ de Mancoridis et al. (1998) au cas des dÃ©compositions chevauchantes. Cette gÃ©-
nÃ©ralisation a Ã©tÃ© introduite par Bourqui et Auber (2008). ConsidÃ©rons un graphe G = (V,E)
et une dÃ©composition C = {C1, C2, ..., Ck} des sommets de G,MQOver est dÃ©finie comme
suit :
MQOver =MQ
+ âˆ’MQâˆ’Over (4)
avec
MQ+ =
1
k
âˆ‘
i
s(Ci, Ci) (5)
et
MQâˆ’Over =
1
k(k âˆ’ 1)
âˆ‘
i
âˆ‘
j 6=i
sOver(Ci, Cj) (6)
oÃ¹ sOver(Ci, Cj) =
|E(Ci,Cj\i)|
|Ci|Â·|Cj\i|
et Cj\i = Cj \ (Cj âˆ© Ci). Dans cette Ã©quation,MQ+ reprÃ©-
sente la cohÃ©sion interne des groupes C1, ..., Ck tandis que MQ
âˆ’
Over reprÃ©sente la cohÃ©sion
externe des groupes (ou inter-groupes)
Nous avons appliquÃ© notre algorithme de dÃ©composition au sous-graphe du graphe dâ€™Hol-
lywood (cf figure 4). La figure 5.(b) montre le rÃ©sultat que nous avons obtenu sur ce graphe.
Dans cette figure, chaque groupe trouvÃ© par notre algorithme est entourÃ© par une enveloppe
convexe mauve. La valeur de MQOver de cette dÃ©composition est 0.96 ce qui montre notre
algorithme donne un excellent rÃ©sultat sur ces donnÃ©es (selon la mesure MQOver). La fi-
gure 5.(a) montre la dÃ©composition que nous considÃ©rons comme optimale, i.e. la dÃ©compo-
sition oÃ¹ chaque groupe correspond Ã  un film. On peut tout dâ€™abord noter la similaritÃ© de ces
deux dÃ©compositions. Lorsque lâ€™on compare en dÃ©tail les groupes obtenus, il sâ€™avÃ¨re que notre
Un algorithme de dÃ©composition pour lâ€™analyse des rÃ©seaux dynamiques
FIG. 5 â€“ DÃ©compositions optimale (a) et obtenue par notre algorithme (b) du graphe de la
figure 4. Chaque groupe est entourÃ© par une enveloppe convexe mauve.
algorithme trouve 421 groupes dont 404 sont en correspondance parfaite avec des groupes de la
dÃ©composition optimale. Notre algorithme permet donc de retrouver plus de 93% des groupes
de la dÃ©composition optimale (et prÃ¨s de 96% des groupes trouvÃ©s correspondent Ã  des films).
En ce qui concerne les 17 groupes de notre dÃ©composition qui ne sont pas en correspondances
parfaites, chacun de ces groupes est un sous-groupe de la dÃ©composition optimale.
4.3 SensibilitÃ© aux modifications
Afin dâ€™Ã©valuer la sensibilitÃ© de notre algorithme aux changements structuraux du rÃ©seau,
nous comparons la dÃ©composition de rÃ©fÃ©rence (obtenue sur le rÃ©seau original) aux dÃ©com-
positions obtenue aprÃ¨s un certain nombre dâ€™ajout et/ou de suppressions dâ€™arÃªtes. Dans cette
section, nous expliquons la mesure de similaritÃ© utilisÃ©e pour comparer deux dÃ©compositions,
puis nous prÃ©sentons les rÃ©sultats que nous avons obtenus.
4.3.1 Mesure de similaritÃ©
Pour mesurer la similaritÃ© des deux dÃ©compositions, nous utilisons une mÃ©trique inspirÃ©e
de celle de BrohÃ©e et van Helden (2006). Cette mesure est basÃ©e sur la reprÃ©sentativitÃ©. On dit
que deux dÃ©compositions sont similaires si et seulement si la premiÃ¨re est reprÃ©sentative de la
seconde, et inversement.
Pour dÃ©finir la reprÃ©sentativitÃ© de deux dÃ©compositions, nous devons tout dâ€™abord dÃ©finir
la reprÃ©sentativitÃ© de deux groupes. Soient ci et cj deux groupes, on dit que le groupe ci
est reprÃ©sentatif du groupe cj si et seulement si le groupe ci est composÃ© en majeure partie
dâ€™Ã©lÃ©ments de cj . On dÃ©finit reprÃ©sentativitÃ© dirigÃ©e de groupes (en anglais, directed cluster
representativeness) comme suit :
Ïciâ†’cj =
ci âˆ© cj
|cj | Ïcjâ†’ci =
ci âˆ© cj
|ci|
On appelle alors la reprÃ©sentativitÃ© non-dirigÃ©e de groupes (en anglais, undirected cluster re-
presentativeness) ou plus simplement la reprÃ©sentativitÃ© de groupes :
Ïcicj =
âˆš
Ïciâ†’cj Â· Ïcjâ†’ci
R. Bourqui et al.
Cela correspond Ã  la moyenne gÃ©omÃ©trique (en anglais, geometrical mean)) des reprÃ©sentati-
vitÃ©s dirigÃ©es des groupes ci et cj .
On peut, de maniÃ¨re analogue, dÃ©finir le degrÃ© de reprÃ©sentativitÃ© dâ€™une dÃ©composition par
rapport Ã  une autre. ConsidÃ©rons deux dÃ©composition C et C â€², on dit que C est reprÃ©sentative
de C â€² si et seulement si pour chaque groupe câ€² de la dÃ©composition C â€², la dÃ©composition C
contient un groupe reprÃ©sentatif de câ€². Etant donnÃ© que les groupes de Â«petitesÂ» tailles ont
tendance Ã  biaiser cette mÃ©trique, nous donnons plus dâ€™importance aux reprÃ©sentativitÃ©s des
groupes de Â«grandesÂ» tailles. On dÃ©finit alors la reprÃ©sentativitÃ© dirigÃ©e de dÃ©compositions
(en anglais, directed clustering representativeness) comme suit :
ÏƒCâ†’Câ€² =
âˆ‘
ciâˆˆCâ€²
max
cjâˆˆC
Ïcjci |ci|
âˆ
ciâˆˆCâ€²
|ci|
Cette formule correspond Ã  la moyenne valuÃ©e (et normalisÃ©e) des meilleures reprÃ©sentativitÃ©s
de chaque groupe de C â€² par des groupes de C.
On peut alors dÃ©finir la reprÃ©sentativitÃ© non-dirigÃ©e de dÃ©compositions (en anglais, undi-
rected clustering representativeness), ou plus simplement la reprÃ©sentativitÃ© de dÃ©composi-
tions comme suit :
ÏƒCCâ€² =
âˆš
ÏƒCâ†’Câ€² Â· ÏƒCâ€²â†’C
Une variation possible de cette mÃ©trique peut Ãªtre obtenue en utilisant un produit simple
en lieu et place de la moyenne gÃ©omÃ©trique lors du calcul de la reprÃ©sentativitÃ© non-dirigÃ©e.
Cela permet de distinguer plus aisÃ©ment les dÃ©compositions similaires des dÃ©composition
Â«diffÃ©rentesÂ» puisque les Â«mauvaisesÂ» correspondances sont alors plus pÃ©nalisÃ©es. Nous uti-
lisons dans la suite, cette variation de la mÃ©trique de similaritÃ©.
4.3.2 RÃ©sultats
Pour mesurer la sensibilitÃ© de notre algorithme de dÃ©composition, nous commenÃ§ons par
gÃ©nÃ©rer un jeu de donnÃ©es Ã  partir du graphe de la figure 4. Pour cela, nous utilisons lâ€™algo-
rithme 3. Cet algorithme permet de gÃ©nÃ©rer une collection de 100000 graphes.
Nous avons ensuite comparÃ© la dÃ©composition du graphe original avec celles obtenues sur
les graphes de la collection Collection gÃ©nÃ©rÃ©e par lâ€™algorithme 3. La figure 6 montre les
rÃ©sultats que nous avons obtenus.
Dans la figure 6.(a), la courbe bleue montre le nombre moyen de correspondances par-
faites de groupes en fonction du nombre dâ€™arÃªtes supprimÃ©es ou ajoutÃ©es au rÃ©seau original,
et le tracÃ© rouge indique pour chacune de ces moyennes les Ã©carts types observÃ©s. On peut
remarquer sur cette figure que jusquâ€™Ã  2000 opÃ©rations, notre algorithme permet de trouver en
moyenne entre 250 et 421 (i.e. le nombre de groupes dans la dÃ©composition originale) corres-
pondances parfaites entre la dÃ©composition originale et les dÃ©compositions des graphes de la
collection gÃ©nÃ©rÃ©e. Dâ€™autre part, on peut aussi remarquer que les Ã©carts types sont relativement
faibles, compris entre 0.44 et 10.34. Dans la figure 6.(b), la courbe bleue montre la valeur
moyenne de la mÃ©trique de similaritÃ© en fonction du nombre dâ€™arÃªtes supprimÃ©es ou ajoutÃ©es
au rÃ©seau original, et le tracÃ© rouge indique pour chacune de ces valeurs moyennes les Ã©carts
types observÃ©s. Les valeurs moyennnes de la mÃ©trique de similaritÃ© sont comprises sur ce jeu
Un algorithme de dÃ©composition pour lâ€™analyse des rÃ©seaux dynamiques
Input : subgraph G = (V,E) of the Hollywood graph
Output : A set Collection of graphs
for unsigned int i = 0 to i == NB_TESTS do
Graph H = G;
for unsigned int j = 0 to j ==MAX_OPERATIONS do
Operation op = getOperation();
if op == â€™edge deletionâ€™ then
node src = getRandomNode();
node tgt = getRandomNode();
edge e = edge(src, tgt);
while e is not element of H do
src = getRandomNode();
tgt = getRandomNode();
e = edge(src, tgt);
end
deleteEdge(H , e);
end
else /* op == â€™edge additionâ€™ */
node src = getRandomNode();
node tgt = getRandomNode();
edge e = edge(src, tgt);
while e is element of H do
src = getRandomNode();
tgt = getRandomNode();
e = edge(src, tgt);
end
addEdge(H , e);
append(Collection, H);
end
end
Algorithme 3 : Construction du jeu de donnÃ©es utilisÃ© pour Ã©valuer la sensibilitÃ© de
notre algorithme de dÃ©composition. La fonction getOperation() retourne â€™edge addi-
tionâ€™ avec une probabilitÃ© 0.5, â€™edge deletionâ€™ sinon. Les constantes NB_TESTS et
MAX_OPERATIONS ont Ã©tÃ© respectivement fixÃ©es Ã  50 et 2000.
de donnÃ©es entre 0.9 et 1. On obtient donc de bonnes valeurs de similaritÃ©s entre la dÃ©compo-
sition originale et les dÃ©compositions des graphes de la collection gÃ©nÃ©rÃ©e. En ce qui concerne
les Ã©carts types, ils sont compris entre 0.0002 et 0.007.
Si lâ€™on considÃ¨re une mesure de Â«stabilitÃ©Â» naÃ¯ve comme le nombre de correspondances
parfaites, notre algorithme permet en moyenne de prÃ©server prÃ¨s de 78% des groupes. Dâ€™autre
part, les valeurs moyennes des mesures de similaritÃ© sont elles aussi Ã©levÃ©es montrant ainsi la
stabilitÃ© de notre algorithme de dÃ©composition.
R. Bourqui et al.
FIG. 6 â€“ (a) Nombre moyen de correspondances parfaites (en bleu) en fonction du nombre
dâ€™opÃ©rations dâ€™addition et de suppression effectuÃ©es ainsi que lâ€™Ã©cart type (en rouge) ; (b)
Valeur moyenne de la mÃ©trique de similaritÃ© (en bleu) en fonction du nombre dâ€™opÃ©rations
dâ€™addition et de suppression effectuÃ©es ainsi que lâ€™Ã©cart type (en rouge).
5 Conclusion
Dans cet article, nous avons prÃ©sentÃ© une nouvelle approche pour lâ€™analyse de rÃ©seau dy-
namiques. Cette technique est basÃ©e sur la discrÃ©tisation du graphe dynamique en un ensemble
de graphes statiques et sur la dÃ©composition de graphe en groupes chevauchants de sommets.
Lâ€™idÃ©e principale de notre approche est que si la structure du rÃ©seau Ã©volue peu dans le temps
alors les dÃ©compositions obtenues sur deux graphes correspondants Ã  deux pÃ©riodes de temps
successives doivent contenir des structures de communautÃ©s similaires.
Afin de dÃ©composer les graphes correspondant Ã  chaque pÃ©riode de temps, nous donnons
dans cet article un nouvel algorithme de dÃ©composition de graphe dont la complexitÃ© en temps
est O(|E| Â· deg2max + |V | Â· log(|V |))). Etant donnÃ© que dans notre approche, deux graphes
similaires doivent avoir des dÃ©compositions similaires, nous avons montrÃ© la faible sensibilitÃ©
de notre algorithme aux modifications structurelles du rÃ©seau.
Enfin, nous donnons une gÃ©nÃ©ralisation de la mesure de similaritÃ© de BrohÃ©e et van Helden
(2006) au cas des dÃ©compositions chevauchantes. Cela nous permet de comparer les dÃ©com-
positions obtenues sur deux graphes correspondants Ã  deux pÃ©riodes de temps successives, et
par consÃ©quent de dÃ©tecter dâ€™Ã©ventuels changements structuraux du rÃ©seau.
RÃ©fÃ©rences
Auber, D., Y. Chiricota, F. Jourdan, et G. MelanÃ§on (2003). Multiscale Visualization of Small-
World Networks. In Proc. of IEEE Information Visualization Symposium, pp. 75â€“81.
Bader, G. D. et C. W. Hogue (2003). An automated method for finding molecular complexes
in large protein interaction networks. BMC Bioinformatics 4.
Bourqui, R. et D. Auber (2008). Analysis of 4-connected components decomposition for graph
visualization. Technical report, LaBRI (http://www.labri.fr/).
Un algorithme de dÃ©composition pour lâ€™analyse des rÃ©seaux dynamiques
BrohÃ©e, S. et J. van Helden (2006). Evaluation of clustering algorithms for protein-protein
interaction networks. BMC Bioinformatics 7(488). http://www.biomedcentral.com/1471-
2105/7/488.
Chakrabarti, D., R. Kumar, et A. Tomkins (2006). Evolutionary clustering. In Proc. of the 12th
ACM SIGKDD int. conference on Knowledge Discovery and Data mining, pp. 554â€“560.
Chiricota, Y., F. Jourdan, et G. MelanÃ§on (2003). Software Components Capture using Graph
Clustering. In 11th IEEE Int. Workshop on Program Comprehension.
Gaertler, M., R. GÃ¶rke, D. Wagner, et S. Wagner (2006). How to Cluster Evolving Graphs. In
Proc. of the European Conference of Complex Systems (ECCSâ€™06).
Gajer, P. et S. G. Kobourov (2000). GRIP: Graph dRawing with Intelligent Placement. In
Proc. Graph Drawing 2000 (GDâ€™00), pp. 222â€“228.
HÃ¼bner, F. (2008). The Dynamic Graph Clustering Problem -ILP-Based Approaches Balanc-
ing Optimality and the Mental Map. Ph. D. thesis, Institut fÃ¼r Theoritische Informatik,
UniversitÃ¤t Karlruhe (TH).
InfoVis 2007 Contest (2007). IEEE InfoVis 2007 Contest: InfoVis goes to the movies.
http://www.apl.jhu.edu/Misc/Visualization/.
Li, C. et J. Yoo (2005). A study of the effects of bias in criterion functions for temporal data
clustering. In Proc. of the 43rd annual Southeast regional conference, pp. 85â€“89.
Mancoridis, S., B. S. Mitchell, C. Rorres, Y. Chen, et E. R. Gansner (1998). Using Automatic
Clustering to Produce High-Level System Organizations of Source Code. In IEEE Proc.
Int. Workshop on Program Understanding (IWPCâ€™98), pp. 45â€“53.
Newman, M. E. J. (2004). Fast algorithm for detecting community structure in networks.
Physical Review E 69, 066133.
Newman, M. E. J. et M. Girvan (2004). Finding and evaluating community structure in net-
works. Physical Review E 69, 026113.
Palla, G., A.-L. Barabasi, et T. Vicsek (2007). Quantifying social group evolution. Nature 446,
664â€“667.
Popescul, A., L. H. Ungar, G. W. Flake, S. Lawrence, et C. L. Giles (2000). Clustering and
Identifying Temporal Trends in Document Databases. In Proc. of the IEEE Advances in
Digital Libraries 2000, pp. 173â€“182.
Suderman, M. et M. Hallett (2007). Tools for visually exploring biological networks. Bioin-
formatics Advanced Access.
Summary
Dynamical networks raise new analysis problems. An efficient analysis tool has to not only
allow to split the network into groups of â€œsimilarâ€ elements but also allow to detect changes in
the network structure. In this article, we describe a new method for analyzing such dynamical
networks. This technique is based on an algorithm of decomposition of graph into overlapping
clusters. Time complexity of this algorithm is O(|E| Â· deg2max+ |V | Â· log(|V |))). The stability
of that algorithm allows to detect the changes of the studied network over the time.
