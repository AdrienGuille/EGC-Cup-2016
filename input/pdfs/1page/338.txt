Apprentissage de spécifications de CSP
Matthieu Lopez∗, Lionel Martin∗
∗LIFO, Université d’Orléans,
Batiment IIIA, Rue Léonard de Vinci, B.P. 6759, F-45067, ORLEANS Cedex 2
prenom.nom@univ-orleans.fr,
http://www.univ-orleans.fr/lifo/
1 Introduction
Les problèmes de satisfaction de contraintes (CSP) permettent de modéliser une grande va-
riété de problèmes cependant le niveau d’expertise requis pour les modéliser est trop élevé pour
des non-experts ou bien pour des informaticiens généralistes (Freuder (1997)). De nombreux
travaux ont cherché à simplifier l’utilisation des CSP en proposant par exemple des langages
de spécification haut-niveau ou encore l’apprentissage de modèle. Notre objectif est de propo-
ser une manière d’obtenir automatiquement une spécification d’un CSP en partant de solutions
et de non-solutions du problème. Une spécification d’un problème est une formalisation plus
abstraite qu’un modèle. Considérons le problème des n-reines qui consiste à placer n reines
sur un plateau de taille n× n tel qu’aucune reine n’en attaque une autre. Il existe des modèles
pour les 8-reines, 12 reines, et des spécifications pour le problème général des n-reines. Nous
proposons (fig. 1) un langage de spécification où COMPARATOR est un atome avec que des en-
trées et VARIABLE_GENERATOR au moins une sortie. Le but de ce langage n’est pas de fournir
une simplification à l’utilisateur, mais plutôt de fournir une cible pour l’apprentissage.
2 Apprendre des spécifications de CSP
Nous nous sommes intéressés aux algorithmes de type separate-and-conquer (Furnkranz
(1999)). Dans ce cas, les méthodes usuelles en ILP échoue car d’une part de l’espace de
recherche est en général trop grand, d’autre part, la recherche Top-down est aveugle en ne
considérant que le critère de couverture des exemples. Nous nous sommes donc intéressée à
restreindre la taille de l’espace de recherche en générant pour un exemple graine s, plusieurs
treillis de petite taille. Nous définissons les extrémités des treillis (clauses et⊥) dans la suite.
Clause  : Nous proposons une approche incrémentale visant à ajouter progressivement
des VARIABLE_GENERATOR par couche. Les atomes de profondeur 1 ajoutés sont ceux n’ayant
que des sorties. Puis à profondeur i, on ne peut ajouter que des atomes dont les entrées sont
des variables déjà introduites. On commence par ajouter un atome pour chaque entrée d’un
prédicat, puis on augmente ce chiffre 1 jusqu’à l’apprentissage d’une règle discriminante.
Clause ⊥ : En partant de la clause , nous construisons des clauses en ajoutant un maxi-
mum de COMPARATOR aux atomes de  tel qu’elles couvrent l’exemple s. Pour se faire, pour
1. Sauf pour les prédicats correspondant à des fonctions
RNTI-E-19- 709 -
