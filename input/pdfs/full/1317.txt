Verification of embbeded systems with preemption: a
negative result
Jérôme Ermont∗, Frédéric Boniol∗
∗IRIT-ENSEEIHT, 2 rue C. Camichel. F31071 Toulouse, France
{frederic.boniol,jerome.ermont}@enseeiht.fr
Abstract. The aim of this article is to explore the problem of verification of
preemptive communicating timed processes, i.e., timed processes which can be
suspended and resumed by an on-line scheduler. The contribution of the article
is to show that this problem is unfortunately undecidable. We discuss then an
alternative verification method to overcome this negative result.
1 Introduction
Embedded systems often are characterized by the two following properties. Firstly they
are an information processing sub system of their embedding systems. Secondly they are reac-
tive, i.e. they interact with their physical environment at a speed imposed by the environment.
Consequently, they have to meet both real time and safety constraints. These characteristics
make writing embedded software a substantially different and more difficult task than classical
software. To overcome this complexity, the avionics architectures traditionally being imple-
mented are of federated, which means that each avionics system has its own independent and
dedicated computing and communicating resources. Federated architectures have great advan-
tage of inherent fault containment. Systems implemented by dedicated resources are loosely
coupled allowing modular design and verification.
However, federated architectures are penalizing due to massive use of isolated resources,
and results in increase in weight, maintenance costs, power consumption, etc. Due to these
drawbacks, the aviation industry is gradually moving towards the use of Integrated Modular
Architectures (IMA) for both civil and military aircraft programmes. Instead of using indi-
vidual resources, IMA uses generic computing and communicating platforms. This allows
multiple applications to share and reuse the same computing and communicating resources
concurrently. This facilitates a reduction in the number of deployed subsystems which are not
fully utilised and provides a more efficient use of system resources, leaving space for future
expansion. This is the case of modern aircraft such as Airbus A380, Boeing B777, or Euro
Fighter aircraft. Each function is allocated to a shared computer. Scheduling of functions
is managed by an embedded real time operating system. Communications between comput-
ers are supported by multiplexed data buses (Boeing B777), or by switched communication
networks (Airbus 1380), and are scheduled by real time communication protocols. The main
advantage of such an organisation is to offer a modular view of the global system. However,
the use of shared computing and communication resources introduces non-deterministic jitters
and delays, which can affect the global behaviour of the system.
Verification of embedded systems with preemption
Due to safety constraints, embedded systems have to go through certification. It requires
a rigorous design process based on tight rules. However, due to their increasing complexity,
there is no guarantee that such a design process leads to error free systems. Another way
for helping embedded system designers is formal methods, i.e., fundamental techniques for
analysis, validation, or transformation of systems in a provably sound way. Real time systems
correctness depends both, on qualitative (functional) aspects and, as said before, on quantitative
(performance) ones (scheduling, delay, jitters. . . ). Such a dependency becomes more important
with IMA systems where concurrency between several functions on the same resources can
lead to delays which can alterate the functional behaviour. Consequently, to verify an IMA
system needs to to take into account the real time behaviour of its components, and then the
implementation choices: the allocation of processes on computers, the messages allocation on
communication buses, and more precisely the real time scheduling strategy of processes on
computers and messages on buses.
The questions are then: (a) how to model such a system and (b) is it possible to formally
verify timed properties over such a system. Unfortunately, the answer to the second question
depends on the process scheduling strategy. As far as non preemptive strategy is concerned
(processes can be aborted but not resumed), it is easy to show that the verification is still
decidable. This result is obtained by translating such processes into timed automata. However,
as far as preemptive strategy is concerned (processes can be suspended and resumed), the
verification problem becomes undecidable. The aim of this article is to prove this last negative
result. It can be obtained by reducing the verification problem of preemptive processes to the
halting problem for two-counters machines (Henzinger et al., 1998; Cerans, 1992). For that
purpose, we introduce in the next section a formal algebra of preemptive timed processes in
order to model real time systems. We then give in section 3 a tiny logic SubSL for modeling
properties to be verified. And finally, section 4 proves that the satisfaction problem of a formula
φ from SubSL by a process p from P is undecidable.
2 Step one: a (small) calculus for modeling real time pre-
emptive systems
Embedded systems are real-time systems composed of processes which evolve and com-
municate using events (or actions). In order to formalize such systems, we define in this section
a timed process algebra, called P . The time domain of P is T = IR ∪ {∞}. Let us consider
A = {a, b, . . .} the set of events. The co-set A = {a|a ∈ A} is the set of waiting actions. Let
ε /∈ A ∪ A be an invisible action used to “break” delays. The following grammar defines the
terms of P , ranged over P , Q, ...
P ::= δ|X|aP |[l, u]P |P +Q|P‖Q|(P ⇓ a)Q|(P ↓ a ↑ b)Q|recX.P
where:
• δ is an idle process which cannot execute any action but let the time pass.
• V = {X,Y, ...} is a set of process variables used to model recursive processes.
• aP is a non-blocking broadcasting process. It immediately executes action a and then
behaves like P .
J. Ermont et al.
• [l, u]P is a delayed process, with l, u ∈ T and l ≤ u. When u > 0, this process may
stay idle t ≤ u time units. When l = 0, it performs the ε action and behaves like P . If
l > 0, it must stay idle at least l time units before performing the ε action.
• P +Q is the non deterministic choice between P and Q.
• P‖Q executes P andQ in parallel. It (1) can execute independently actions of P andQ,
or (2) can synchronize whenever one of them sends a transmission event and the other
waits for the complementary reception event, or (3) can let the time pass if P and Q are
able to do so.
• (P ⇓ a)Q models the abortion mechanism. Before receiving event a, this process be-
haves like P . When receiving a, P is aborted and Q is started.
• (P ↓ a ↑ b)Q models the suspension mechanism. Before receiving event a, this process
behaves like P . When a is received P is suspended and Q is resumed from its last
suspension point. Afterwards, the global process behaves like (Q ↓ b ↑ a)P .
• recX.P is the classical recursive process modelling infinite behaviours.
The P semantics is given by the timed labeled transition system (P, P,→) where →⊆ P ×
A∪T ∪ {ε}×P , defined by table 1. We write P t→ P ′ with t ∈ T to mean that P lets t time
units pass and becomes P ′. In the same way, we write P a→ P ′ to mean that P emits event a
and instantaneously becomes P ′. To specify non-blocking transmission event, reception event
and broadcasting, we also add an auxiliary relation ⊆ P ×A× P and we write P a P ′ to
mean that P is waiting for the event a and when receiving it, behaves like P ′.
Let us note aP = (δ ⇓ a)P . aP is a blocking process waiting for the broadcasting of
action a (by another process), and when receiving it, behaves like P .
As we are only interested in observational behaviour, we introduce then a weak behavioural
transition⇒ on P processes which abstracts invisible action ε.
Definition 1 Abstraction of ε. Let⇒⊆ P ×A ∪ T × P defined by:
• P a⇒ P ′ if P ( ε→)∗ a→ P ′
• P t⇒ P ′ if P ( ε→)∗ t1→ ( ε→)∗ · · · ( ε→)∗ tn→ ( ε→)∗P ′ with t =∑i≤n ti
3 Step two: a (tiny) logic
To prove that the verification problem is undecidable, a property language is required. The
language we consider, called SubSL, is a fragment of a dense-time logic denoted SL presented
in Laroussinie et al. (1995) (which in turn is a variation of the timed mu-calculus (Henzinger
et al., 1992)). This logic (and then the fragment under consideration) allows model-checking
by using accessibility analysis which is decidable for timed automata (Aceto et al., 2001).
Definition 2 SubSL. The set of SubSL formulae is generated by the following grammar:
ϕ ::= tt | ff | ϕ1 ∧ ϕ2 | [a]ϕ | ∀ϕ | X | max(X,ϕ)
where a ∈ A. X is a formula variable and max(X,ϕ) stands for the maximal solution of the
recursion equation X = ϕ.
Verification of embedded systems with preemption
t ∈ T
δ
t→δ
a ∈ A
aP
a→P t ∈ T
0<t≤d2
[d1,d2]P
t→[max(0,d1−t),d2−t]P [0,d2]P ε→P
α ∈ A ∪ {ε} P α→P ′
P+Q
α→P ′ α ∈ A ∪ {ε}
Q
α→Q′
P+Q
α→Q′ a ∈ A
P
a P ′
P+Q
a P ′ a ∈ A
Q
a Q′
P+Q
a Q′
t ∈ T P t→P ′ Q
t
6→
P+Q
t→P ′
t ∈ T P
t
6→ Q t→Q′
P+Q
t→Q′
t ∈ T P t→P ′ Q t→Q′
P+Q
t→P ′+Q′
a ∈ A P a→P ′ Q
a
6 
P‖Q a→P ′‖Q a ∈ A
P
a
6 Q a→Q′
P‖Q a→P‖Q′
a ∈ AP a→P ′ Q a Q′
P‖Q a→P ′‖Q′ a ∈ A
P
a P ′ Q a→Q′
P‖Q a→P ′‖Q′
a ∈ AP a P ′ Q
a
6 Q
a
6→
P‖Q a P ′‖Q a ∈ A
P
a
6 P
a
6→ Q a Q′
P‖Q a P‖Q′
a ∈ AP a P ′ Q a Q′
P‖Q a P ′‖Q′ t ∈ T
P
t→P ′ Q t→Q′
P‖Q t→P ′‖Q′
a ∈ A
(P⇓a)Q a Q b ∈ A
P
b P ′ b 6=a
(P⇓a)Q b (P ′⇓a)Q
α ∈ A ∪ {ε} P α→P ′
(P⇓a)Q α→(P ′⇓a)Q t ∈ T
P
t→P ′
(P⇓a)Q t→(P ′⇓a)Q
c ∈ A P c→P ′
(P↓a↑b)Q c→(P ′↓a↑b)Q c ∈ A
P
c P ′ c6=a c6=b
(P↓a↑b)Q c (P ′↓a↑b)Q
a ∈ A
(P↓a↑b)Q a (Q↓b↑a)P t ∈ T
P
t→P ′
(P↓a↑b)Q t→(P ′↓a↑b)Q
α ∈ A ∪ {ε} P α→P ′
recX.P
α→P ′{recX.P/X} a ∈ A
P
a P ′
recX.P
a P ′{recX.P/X}
t ∈ T P t→P ′
recX.P
t→P ′{recX.P/X}
TAB. 1 – Semantics rules of P
J. Ermont et al.
The satisfaction relation of SubSL formulae over P processes is defined by:
Definition 3 Satisfaction. The satisfaction relation |= between P processes, SubSL formulae
is the largest relation satisfying the following implications:
P |= tt ⇒ true
P |= ff ⇒ false
P |= ϕ1 ∧ ϕ2 ⇒ ∀P ′ : P ( ε→)∗P ′ then P ′ |= ϕ1 and P ′ |= ϕ2
P |= [a]ϕ ⇒ ∀P ′ and ∀b 6= a : P ( b⇒)∗ a⇒ P ′ then P ′ |= ϕ
P |= ∀ϕ ⇒ ∀t ∈ T ,∀P ′ : P t⇒ P ′ then P ′ |= ϕ
P |= max(X,ϕ) ⇒ ∀P ′ : P ( ε→)∗P ′ then P ′ |= ϕ{max(X,ϕ)\X}
Any relation satisfying these implications is a satisfaction relation. It follows from standard
fix-point theory that |= is the union of all satisfaction relations and that these implications are
in fact bi-implications.
A high-level operator has been defined in terms of the basic elements of SubSL, and is, for the
designer, closer to intuition than the basic operators: always ϕ = max(X,ϕ ∧∧a∈A[a]X ∧
∀X). Note that the formula [a]tt means that a must be broadcast instantaneously. Conversely,
[a]ff is satisfied if and only if a cannot be broadcast instantaneously.
4 Step three: the undecidability result
After giving a timed preemptive process algebra and a (tiny) logic, we prove in this main
section that the satisfaction problem of a SubSL formula by a P process is undecidable. To do
this, we use the halting problem for a two-counters machine.
Definition 4 Two-counters machine. A two-counters machine, with non-negative integer
variables called counters denoted by C1 and C2, is a finite sequence of instructions 1 :
INS1, · · · , k : INSk where k ∈ IN, and all instructions INSi(0 ≤ i < k) has one of the
next forms (with 1 ≤ l, l′, l′′ ≤ k and 1 ≤ j ≤ 2):
• Cj := Cj + 1; goto l
• if Cj = 0 then goto l′ else (Cj := Cj − 1; goto l′′)
Minsky (1967) has shown that the halting problem of a two-counters machine is undecidable.
The main proposition leading to our undecidability result is then:
Proposition 1 The halting problem of a two-counters machine can be reduced to the satisfac-
tion problem of a SubSL property by a P process.
To prove this proposition, we model the behaviour of a two-counters machine in the processes
algebra P .
Verification of embedded systems with preemption
4.1 Step 3.1: modelling counter values
Counters values can be encoded using implicit clock values (intervals) of the algebra. This
encoding is defined by the equation: c = 21−C where c is an implicit clock of the algebra and
C is a counter value. In other words, the value C of a counter of the machine corresponds
to the value 21−C of a clock of the algebra. In this way, counters values belonging to IR are
encoded into the clock values in [0,2]. The discrete evolutions of the counters are simulated
by a set of continuous rounds takingW (or multiples ofW ) time units. This technique, named
“wrapping”, is inspired by K. Cerans (Cerans, 1992) and T. Henzinger et al. (Henzinger et al.,
1998). Clocks which model counters have cyclic and continuous evolutions from 0 toW . To
make understanding more easier, intervals, modelling time evolution in the algebra, are labelled
by clock names. Thus, the interval labelled c1 will encode the counter valueC1 and the interval
labelled c2 will encode the counter value C2. When W time units have passed, the counters
are reseted and an event resetcj (j = 1, 2) is sent to indicate this reset to other processes. The
counters reset can also be “forced” when receiving an event fresetcj (j = 1, 2). TheP models
of the two counters C1 and C2 are :
Ct1 = recX.((recY.[W,W ]c1resetc1Y ) ⇓ fresetc1)X
Ct2 = recX.((recY.[W,W ]c2resetc2Y ) ⇓ fresetc2)X
A two-counters machine consists of three operations: (1) incrementing a counter, (2) decre-
menting a counter and (3) branching based upon whether a specific counter values are 0. We
now model this three operations using P processes.
4.2 Step 3.2: modelling the test for zero
As we say before, the value C of a counter corresponds to an implicit clock value in the
algebra. Testing if C is equal to 0 consists of determining if a clock value is equal to 2. Using
the wrapping technique, the clock c1 (or c2) will evolve during a round (i.e. W time units). At
the end of a round, the value of c1 stays unchanged.
Suppose that the value of C1 is x. The process Ct1 will send the event resetc1 after
waitingW − x time units. The wait time is minimal when x is equal to 2 and will grow when
x decrease (corresponding to incrementing a counter). When C1 = 1, the value of clock c1
is x = 1, according to the encoding equation. Then, to detect if specific counter values are 0,
we wait duringW − 2 + 12 time units. In this way, if the process Ct1 sends the event resetc1
after letting pass W − 2 + 12 time units, then x < 2 and C1 6= 0. Conversely, if the process
Ct1 sends the event resetc1 before W − 2 + 12 time units, then the only value for x is 2 and
C1 = 0. The test for zero of counter C2 can be done in the same way.
To show if a counter is equal to zero or not, we use two events: eq1 and neq1. These two
events will be sent at the end of the test, i.e. at the end of round. We use also two auxiliary
events: zero1 and dif1. The process ZERO1 models the previously described behaviour.
ZERO1 = test1((resetc1 zero1 δ ⇓ dif1)δ‖([W − 2 +
1
2
,W − 2 + 1
2
]dif1 δ ⇓ zero1)δ)
A process A1 is used to count the number of rounds and sends an event done at the end of the
test.
A1 = recX.test1[W,W ]at11 t12 done X
J. Ermont et al.
c  = 21 c  = 21
resetc
1
eq
done
4
t
eg
a
1
1
(a) c1 = 2 : counter C1 is equal to 0
c  = 11
c  = 11
resetc
1
neq
done
4
t
dif
a
1 1
(b) c1 = 1, counter C1 is not equal to 0
FIG. 1 – Examples of test for zero withW = 4.
A third process T1 receives zero1 and dif1 and emits eq1 and neq1 at the end of the test, i.e.
after receiving event t11 from A1.
T1 = test1(zero1 t11 eq1 t12δ + dif1 t11 neq1 t12δ)
Finally, the P process testing for zero for the counter C1 is done by composing the previous
different processes.
TEST1 = (recX.((ZERO1‖T1) ⇓ done)X)‖A1
On figures 1(a) and 1(b), we show two executions of the process TEST1 withW = 4. In the
first case c1 = 2 and in the second case c1 = 1. In the same manner, we can model the test for
zero for the counter C2. Thus, we obtain the TEST2 process.
4.3 Step 3.3: decrementing a counter
Decrementing a counter consists of synchronizing this counter with a process which ex-
ecutes a delay and which can be suspended. Suppose x the value of c1. As x = 21−C1 ,
decrementing the counter C1 consists of doubling the value of x. Let the process Zdec1 be syn-
chronized with the process Ct1 and which can be suspended. Whenever Zdec1 is suspended,
time cannot evolve in this process. Let z be a clock modeling time evolution in Zdec1 . The
decrementing models consists of three step: (1) assigning the value of x to z; (2) doubling the
value of z; then z = 2 × x; and (3) assigning the value of z to c1; finally c1 = 2 × x and
C1 = C1 − 1.
The first step, assigning the value of x to z, consists of letting a round pass (i.e. W times
units) and resetting z when x is reseted, by synchronizing Ct1 and Zdec1 on event resetc1 .
Then, before the doubling procedure, the value of z is equal to x. Let a be a clock reseted
at this time. Suppose that z is frozen, by suspending the process Zdec1 , during W − x time
units, i.e. up to receiving the event resetc1 . At the end of this duration, z is still equal to x,
but a = W − x. Suppose that z is restarted by resuming process Zdec1 . When a = W , i.e. x
time units later, z is equal to x+ x. z is then doubled. Finally (third step), z is assigned to c1
by synchronizing Ct1 and Zdec1 on event fresetc1 when z is reseted. c1 is doubled and the
counter has been decremented: C1 := C1 − 1.
Verification of embedded systems with preemption
4
8
t
a
a
done
zc1 c1
c  = 11
c  = 21
c1
resetc
1resetz
e1
freset
1
c
1
creset
FIG. 2 – Decrementing the counter C1 whenW = 4, initially c1 = 1
As for the test for zero, a processAdec1 is used to control the evolution of the decrementing.
At the end of the first round, the process Zdec1 is suspended via the event e1 transmitted by
Adec1 . The process Adec1 lets the time to pass during the doubling and the second assignment
procedures, i.e. during 2 rounds, and, afterwards, transmits the event done to indicate the end
of the decrementing.
Adec1 = recX.dec1[W,W ]ae1[2W, 2W ]adoneX
The affectation z := c1 is made by the process RZdec1 . To do so, this process synchronizes
Zdec1 and Ct1 when c1 = 0.
RZdec1 = dec1 resetc1resetzδ
A third process Zdec1 controls the evolution of z. The execution of this process is suspended
when receiving event e1 and resumed when receiving event resetc1 . Thus, evolution of z is
suspended duringW − x time units, where x is initial value of c1.
Zdec1 = dec1((recX.(([W,W ]zfresetc1δ) ⇓ resetz)X) ↓ e1 ↑ resetc1)δ
Finally, the process DEC1 controls the decrementing of the counter C1.
DEC1 = (recX.((RZdec1‖Zdec1) ⇓ done)X)‖Adec1
The event dec1 is used to control the beginning of the decrementing and the event done is used
to indicate the end. An example is given by figure 2, with W = 4 and c1 = 1, i.e. C1 = 1.
After transmission of event done, the value of c1 is 2 and the counter C1 is decremented:
C1 = 0. In the same way, decrementing the counter C2 can be modelled by a similar process
DEC2.
4.4 Step 3.4: incrementing a counter
To model incrementing a counter is quite more difficult. If decrementing a counter consists
of doubling a clock value, conversely incrementing a counter consists of halving this value.
This halving procedure is done by using two auxiliary clocks caux1 and caux2. We proceed in
J. Ermont et al.
four steps: (1) non-deterministic guessing a value to caux1 and assigning caux1 to caux2; (2)
doubling the value of caux1: caux1 := 2 × caux1; (3) testing if caux1 = c1; in that case, we
proceed to step 4, else we restart from step 1; and (4) assigning the value of caux2 to c1. This
sequence is encoded by the process Ainc1 :
Ainc1 = recX.inc1[W,W ]a doubl1[W,W ]ae1[2W, 2W ]a
testeq1[W,W ]a endtest1[W,W ]a end1 X
Guessing a value to caux1 consists of letting the time to pass during a non-deterministic delay
between [2,W ], such that at the end of a round, the value of caux1 ∈ [0, 2]. The processCaux1
controls the evolution of the clock caux1. Initially, caux1 evolves from 0 to a non-deterministic
value in [2,W]. Then, the behaviour of Caux1 is similar to the process Ct1: When W time
units have passed, caux1 is reseted and an event resetcaux1 is sent to indicate this reset. caux1
can also be reseted when receiving an event fresetcaux1 .
Caux1 = inc1[2,W ]initc2
(recX.((recY.[W,W ]caux1resetcaux1Y ) ⇓ fresetcaux1)X)
The process Caux2 is used to store the initial value of caux1 in clock caux2 to allow the final
assignment. To do so, the clock caux2 is initialized when receiving event initc2 provided by
Caux1 and then evolves periodically from 0 toW .
Caux2 = inc1 initc2recX.[W,W ]caux2resetcaux2X
As done for decrementing a counter, doubling consists of freezing a clock evolution during
W − caux1 time units by synchronizing processes Caux1 and Zinc1 :
Zinc1 = doubl1((recX.(([W,W ]zfresetcaux1δ) ⇓ resetz)X) ↓ e1 ↑ resetcaux1)δ
Before doubling, we have to synchronize clocks of processes Caux1 and Zinc1 . This is done
using process RZinc1 and events resetcaux1 and resetz .
RZinc1 = inc1 resetcaux1resetzδ
The third step (test) is modeled by the process EQinc1 . caux1 and c1 are equal if and only if
the events resetcaux1 and resetc1 are received by EQinc1 simultaneously.
EQinc1 = (recX.testeq1
(resetcaux1 resetc1eq δ + resetc1 resetcaux1eq δ ⇓ fail)neq X)
‖(recX.testeq1fail X)
Remark 1 Due to the non-determinism of the parallel operator, the event fail can be pro-
duced before receiving resetcaux1 and resetc1 . In such a case, EQinc1 can emit event neq
before eq although caux1 = c1. However, whenever caux1 = c1, it is also possible to receive
resetcaux1 and resetc1 before emitting fail, and then, to produce eq before neq. As the halt-
ing problem for a two-counters machine is encoded into a reachability problem (see section
4.6), the existence of such an execution is sufficient.
Verification of embedded systems with preemption
c  = 21
c  = 11
c1 c1 c1 c1 c1 c1
c1
resetc
1
initcaux2
caux1
caux2
caux1
caux2 caux2
resetcaux
1
resetcaux
2
e1
caux1
caux2 caux2
caux1
fresetcaux
1
freset
1
c
termine
done
8
4 a a a a
a
t
mul eq fintesttesteq1 1 1 1
FIG. 3 – Incrementing the counter C1 whenW = 4, initially c1 = 2
A process Control1 determines if the halving procedure needs to be restarted (when the test
failed) or, inversely, to assign caux2 to c1 by synchronizing Caux2 and Ct1.
Control1 = recX.(eq endtest1 resetcaux2fresetc1end1 done X
+neq end1 inc1 X)
Finally, incrementing a counter C1 can be model by the process INC1.
INC1 = (recX.((Caux1‖Caux2‖Zinc1‖RZinc1) ⇓ done)X)
‖Ainc1‖EQinc1‖Control1
Remark 2 As the choice of values caux1 and caux2 is non-deterministic, the execution time of
process INC1 can be unbounded. Nevertheless, the end of the process (transmission of the
event done) stays inevitable at any time. In other words, incrementing a counter can terminate
always despite his unbounded execution time.
On figure 3 is depicted an example of incrementing the counter C1 with W = 4 and c1 = 2.
In the same way, incrementing the counter C2 is modelled by a similar process INC2.
4.5 Global model of a two-counters machine
The two counters can only evolve if an operation is executed. We define two processes
OP1 and OP2 which control processes Ct1 and Ct2 when an operation is requested.
OP1 = recX.(inc1op1 X + dec1op1 X + test1op1 X)
OP2 = recX.(inc2op2 X + dec2op2 X + test2op2 X)
Whenever an operation is requested, process OPi (i = 1 or 2) transmits event opi. Cti must
be resumed up to the end of the operation (reception of event done). Then evolution of coun-
ters and their associated operations can be model in P by the processes COUNTER1 and
COUNTER2.
COUNTER1 = (δ ↓ op1 ↑ done)Ct1‖INC1‖DEC1‖TEST1‖OP1
COUNTER2 = (δ ↓ op2 ↑ done)Ct2‖INC2‖DEC2‖TEST2‖OP2
J. Ermont et al.
A two-counters machine is a finite sequence of instructions. It remains to model in P such a
sequence. Let us consider for example the following two-counters machine:
INS1 : C1 := C1 + 1 ; goto INS2
INS2 : if C1 = 0 then goto INS3 else ( C1 := C1 − 1 ; goto INS1 )
INS3 : if C2 = 0 then goto INS4 else ( C2 := C2 − 1 ; goto INS2 )
INS4 : halt
This sequence can be encoded by a P process which transmits an event inc1 when the counter
C1 must be incremented, an event dec1 when the same counter must be decremented, or an
event test1 when the test C1 = 0 must be performed. Executing the instruction halt cor-
responds to execute the process haltδ which transmits the event halt and idles. In P , the
previous sequence is modelled by the process P_INS1:
P_INS1 = recX1.inc1 done P_INS2
P_INS2 = recX2.test1(eq1 P_INS3 + neq1 dec1 done X1)
P_INS3 = test2(eq2 P_INS4 + neq2 dec2 done X2)
P_INS4 = halt δ
Finally, the two-counters machine is modelled by the processMP :
MP = P_INS1‖COUNTER1‖COUNTER2
4.6 Last step: the halting problem of a two-counters machine
Let us consider the following proposition: MP |= always([halt]ff). This proposition
means: “can the processMP never transmit the event halt?” This transmission models the
execution of the instruction halt of the two-counters machine. So, the proposition can be
rewritten in “can the two-counters machine never halt”. Then, we have reduced the halting
problem for a two-counters machine to the verification of the SubSL formula always([halt]ff)
by the processMP . The proposition 1 is then proved.
Proposition 2 The verification problem of an SubSL formula by a P process is undecidable.
Proof. From proposition 1 and from the undecidability result of the halting problem of a
two-counters machine.
5 Discussion
The previous section show that the verification problem of real-time preemptive systems is
undecidable. It is then theoretically impossible to verify functional properties over such sys-
tems. Two questions then arise: what are the causes of undecidability, and how to overcome
this result. Firstly, let us remark that non preemptive processes, i.e., P processes without op-
erator (P ↓ a ↑ b)Q can be translated into timed automata. The timed automata verification
problem is decidable and is supported by numerous tools. The non preemptive processes ver-
ification problem then becomes decidable too. Secondly, in (Rusu, 1996), V. Rusu has shown
Verification of embedded systems with preemption
that the verification problem restricted to a time-bounded fragment of TCTL logic is also de-
cidable, even in the case of preemptive processes. There are then two main undecidability
sources: (1) the use of time-unbound operators, such as “always” or “never” is the future, for
modeling properties to be verified, or (2) the use of the suspension and resumption operators for
encoding preemptive scheduling strategy. These considerations show, from a theoretical point
of view, where is the frontier between the decidable verification problems and the undecidable
ones when considering real time systems.
However, as explained in introduction, industrial embedded systems such as integrated
modular avionic (IMA) systems are based on on-line preemptive scheduling strategy and have
to satisfy time-unbounded safety properties (e.g., engines are never reversed in flight). To
verify such properties over IMA systems is then an undecidable problem. Abstract models or
semi algorithms are then needed for verifying the behavior of scheduled preemptive systems.
In the specific case of critical embedded systems which have to go through certification, a
specific functional property is often required: determinism, i.e., all computations must produce
the same result (data and orders to actuators) when dealing with the same input environment,
whatever the true execution time and the suspend and resume events interleaving. The benefit
of this property, if ensured, is to allow abstraction of preemptive processes by non preemptive
ones characterized by fixed beginning and end dates without modifying the whole behaviour
of the system. To prove that a multi tasking system is deterministic has been shown decidable
(Boniol et al., 2007). Then, to verify a functional property ϕ over a deterministic system S can
be done following two decidable steps: firstly to prove determinism, and secondly to build to
build an abstract non preemptive model S′ of S and then to verify ϕ over S.
Unfortunately, in the other cases (i.e., non deterministic systems), the verification problem
of functional properties on on-line scheduled preemptive multi tasking systems remains open.
References
Aceto, L., P. Bouyer, A. Burgueño, and K. G. Larsen (2001). The Power of Reachability
Testing for Timed Automata. Technical Report LSV-01-6, ENS Cachan, France.
Boniol, F., C. Pagetti, and F. Revest (2007). Functionally deterministic scheduling. In
ISOLA07.
Cerans, K. (1992). Algorithmic Problems in Analysis of Real-Time Systems Specifications. Ph.
D. thesis, Institut of Mathematical and Computer Science, University of Latvia, Riga.
Henzinger, T. A., P. W. Kopke, A. Puri, and P. Varaiya (1998). What’s Decidable About Hybrid
Automata ? Journal of Computer and Systems Sciences 57, 94–124.
Henzinger, T. A., X. Nicollin, J. Sifakis, and S. Yovine (1992). Symbolic Model Checking for
Real-Time Systems. In 7th. LiCS Symposium, Santa-Cruz, California, pp. 394–406.
Laroussinie, F., K. G. Larsen, and C. Weise (1995). From Timed Automata to Logic - and
Back. In MFCS95, Prague, Czech Republic.
Minsky, M. (1967). Computation: Finite and Infinite Machines. Prentice-Hall.
Rusu, V. (1996). Vérification temporelle de programmes Electre. Ph. D. thesis, Ecole Centrale
de Nantes.
