Utilisation des règles d’association pour la prédiction de
valeurs manquantes
Tao-Yuan Jen∗, Dominique Laurent∗, Gorgoumack Sambe∗ ∗∗
∗ETIS-CNRS, Université Cergy Pontoise,
F-95000 Cergy Pontoise
jen@u-cergy.fr, dlaurent@u-cergy.fr
∗∗Université de Ziguinchor
BP : 523 Ziguinchor Sénégal
gsambe@univ-zig.sn
Résumé. Le traitement des valeurs manquantes est une problématique impor-
tante dans le domaine des entrepôts de données. Plusieurs solutions ont été pro-
posées pour la prédiction de valeurs manquantes, présentant les caractéristiques
suivantes : (i) la prédiction traite soit des valeurs continues soit des valeurs dis-
crètes, et (ii) la prédiction est approximative (soit elle est associée à une pro-
babilité soit elle concerne un ensemble de valeurs). Récemment, une méthode
de prédiction permettant de traiter indépendamment les cas continu et discret a
été proposée, en se basant sur les règles d’association. Cette méthode permet de
prédire, avec une confiance toujours égale à 1, soit un ensemble de valeurs dans
le cas discret, soit un intervalle de valeurs dans le cas continu.
Dans cet article, nous reprenons cette approche basée sur l’extraction de rè-
gles d’association et nous montrons comment générer des règles de prédictions
portant sur une unique valeur et dont la confiance est toujours égale à 1. Afin
d’obtenir de telles règles, notre méthode suppose que l’on dispose d’une hiérar-
chie décrivant des concepts généralisant les valeurs qui peuvent être prédites.
1 Introduction
Avec la mondialisation, la croissance et la compétition effrénée, les entreprises ont vu s’ac-
croître le volume de leurs données. Ces données dispersées sur plusieurs sites de l’entreprise,
sont regroupées et fédérées sur un seul support de données appelé entrepôt de données, à des
fins de consultation et d’analyse.
La présence de valeurs manquantes dans les entrepôts de données est un problème crucial
car les méthodes utilisées pour l’analyse de ces entrepôts produisent généralement des résultats
erronés ou incomplets. Dans la mise en place d’un entrepôt de données, la phase de nettoyage
des données est estimée entre 30 et 80% du temps de développement. Pour remédier au prob-
lème des valeurs manquantes, plusieurs solutions sont proposées (Kamber et Han (2005)) :
– ignorer les données comportant des valeurs manquantes,
– les remplacer manuellement,
Utilisation des règles d’association pour la prédiction de valeurs manquantes
– les remplacer automatiquement soit par une valeur fictive, soit par une valeur calculée,
– utiliser la valeur la plus probable prédite à l’aide d’algorithmes de prédiction comme la
régression, les arbres de décision, et les réseaux de neurones (Kamber et Han (2005)).
La dernière solution qui exploite le plus d’information disponible pour faire la prédiction est la
plus utilisée. Les travaux de Ragel et Cremilleux (1999); Shen et al. (2007); Jami et al. (2005)
utilisent les règles d’association à des fins de prédiction.
Les valeurs prédites par les approches autres que celle de Jami et al. (2005) sont approxi-
matives au sens ou elles sont le plus souvent associées à une probabilité. L’approche proposée
dans Jami et al. (2005) est au contraire certaine, car les règles de prédiction ont une confiance
de 1. Comme notre approche est également fondée sur des règles de confiance 1 et qu’à notre
connaissance, la méthode de Jami et al. (2005) est la seule à traiter des règles de prédiction de
confiance 1, nous comparons notre approche seulement à cette méthode. Toutefois, selon l’ap-
proche de Jami et al. (2005), l’approximation vient du fait qu’un ensemble de valeurs est prédit
de manière certaine au sens où on est certain que la valeur manquante appartient à l’ensemble.
Dans cet article, nous proposons une méthode de prédiction selon laquelle une seule valeur
est prédite de manière certaine. L’approche est basée sur les travaux de Jami et al. (2005),
initialement introduits dans Jami et al. (1998), qui ont pour but d’extraire des règles permettant
la prédiction de valeurs manquantes dans les cas où l’attribut fixé sur lequel la prédiction est
faite est soit continu soit discret. Dans cette approche, on considère une table R définie sur
un ensemble fixé d’attributs {A1, A2, . . . , An}, parmi lesquels se trouve l’attribut à prédire
noté Ai0 . Le but de l’approche est d’extraire des règles de la forme ρ : (Ai1 = v1, Ai2 =
v2, . . . , Aik = vk) → (Ai0 ∈ E) , où pour j = 1 . . . k, vj appartient au domaine de l’attribut
Aij , E est un sous-ensemble du domaine de Ai0 et :
1. dans la partie droite de ρ, notée plus simplement E, E est soit un intervalle, soit un
ensemble de valeurs selon que l’attribut prédit Ai0 est de type continu ou discret,
2. la partie gauche de ρ, notée plus simplement Γ, est fréquente dans l’ensemble R des
n-uplets de R ne contenant pas de valeurs manquantes (i.e., la proportion dans R de
n-uplets dont les valeurs sont égales aux vi est supérieure à un seuil donné), et
3. la confiance de ρ est 1 (i.e., la règle est satisfaite dans R).
De plus, il est montré dans Jami et al. (2005) que si ρ1 : Γ1 → E1 et ρ2 : Γ2 → E2 sont deux
règles telles que Γ2 est une “sous-condition” de Γ1, alors le support de ρ2 est supérieur au
support de ρ1 et E1 ⊆ E2. Ces propriétés ont pour conséquence que, dans Jami et al. (2005),
les règles de prédiction peuvent être engendrées selon un algorithme par niveau tel que Apriori
(Agrawal et Srikant (1994)).
De plus, afin d’éviter d’engendrer des règles redondantes, la notion de gain de précision,
associée à un seuil donné, est introduite dans Jami et al. (2005) comme suit. Si ρ1 et ρ2 sont
deux règles telles que spécifiées ci-dessus, le gain de précision de ρ2 par rapport à ρ1 est défini
par (|E2|−|E1|)|E2| , où |E| désigne la taille de E.
Une règle ρ1 : Γ1 → E1 n’est alors retenue que si, outre les conditions citées ci-dessus,
pour toutes les règles retenues ρ2 : Γ2 → E2 telles que Γ2 est une “sous-condition” de Γ1, le
gain de précision de ρ2 par rapport à ρ1 est supérieur au seuil de gain de précision donné.
On peut donc constater que, bien que l’approche de Jami et al. (2005) permette d’engendrer
des règles de prédiction de confiance 1, les prédictions associées ne sont pas réduites à une
T. Jen et Al.
valeur unique, et de plus, que cette approche nécessite l’introduction d’un seuil de gain de
précision, en plus du seuil de support.
Notre contribution est de fournir une méthode de calcul de règles de prédiction de confiance
1, basée sur Apriori (comme dans Jami et al. (2005)) et permettant de réduire l’ensemble prédit
par les règles à une valeur unique, selon un seuil unique, à savoir le seuil de support minimal.
Pour cela, notre méthode suppose qu’une hiérarchie est définie sur l’attribut prédit, permet-
tant ainsi de généraliser des ensembles de valeurs ou des intervalles par de nouveaux concepts,
non présents dans les données. Cette méthode est donc très adaptée aux contextes dimension-
nels des entrepôts de données et cubes OLAP, dans lesquels des hiérarchies définies sur les
dimensions sont considérées.
Nous illustrons la méthode présentée dans Jami et al. (2005), ainsi que celle présentée
dans cet article, sur la relation R de la table 1. Cette relation contient des données cliniques
codées. Un patient est décrit par son identifiant (ID) avec trois attributs X , Y et Z ayant pour
domaines respectifs {1, 2, 3, 4, 5}, {10, 20, 30, 40, 50} et {100, 200, 300, 400}. De plus, un
champ prescription, qui est l’attribut prédit, donne le nom du médicament prescrit au patient
selon les symptômes X , Y ou Z qu’il présente.
ID X Y Z prescription
1 1 10 100 efferalgan
2 1 10 100 aspegique
3 1 20 200 betsenol
4 1 30 100 ?
5 1 30 300 efferalgan
6 1 30 300 betsenol
7 3 10 100 aspegique
8 1 30 200 ?
9 3 10 100 efferalgan
10 1 30 100 dafalgan
11 3 ? 100 ?
12 2 30 300 dafalgan
13 1 ? 400 ?
14 1 40 100 betsenol
15 2 20 300 betsenol
16 2 30 100 aspegique
17 2 20 300 coversyl
18 4 40 400 coversyl
19 5 50 400 coversyl
X Y Z prescription
1 10 100 efferalgan
1 10 100 aspegique
1 20 200 betsenol
1 30 300 efferalgan
1 30 300 betsenol
3 10 100 aspegique
3 10 100 efferalgan
1 30 100 dafalgan
2 30 300 dafalgan
1 40 100 betsenol
2 20 300 betsenol
2 30 100 aspegique
2 20 300 coversyl
4 40 400 coversyl
5 50 400 coversyl
TAB. 1 – Table des données R et la table extraite R
Considérons la table complèteR issue de la table 1 et contenant tous les n-uplets deR sans
valeurs manquantes.
Selon Jami et al. (2005), pour un seuil de support de 0.1 et un seuil de gain de précision
de 0.2, la règle ρ1 : (X = 1) → {aspegique, dafalgan, efferalgan, betnesol} a un support de
7/15 et un gain de précision (calculé dans ce cas par rapport à toutes les valeurs possibles sur
l’attribut de prédiction) de 4/5. Cette règle est donc retenue et est interprétée comme suit :
Utilisation des règles d’association pour la prédiction de valeurs manquantes
pour X , l’observation du symptôme 1 est suffisamment fréquente (7/15) pour conclure avec
une confiance de 1 que le médicament prescrit est l’un des quatre cités.
De même, la règle ρ2 : (Y = 30) → {aspegique, dafalgan, efferalgan, betnesol} est
retenue car son support est 5/15 et son gain de précision est 4/5.
En revanche, la règle ρ3 : (X = 2) → {aspegique, dafalgan, efferalgan, betnesol, cover-
syl} n’est pas retenue, car même si son support (4/15) est supérieur à 0.1, son gain de préci-
sion est nul. Toutefois, si l’on considère maintenant ρ4 : (X = 2, Y = 30) → {aspegique,
dafalgan}, dont le support est 2/15, ses gains de précison par rapport à ρ2 et ρ3 sont respec-
tivement 2/5 et 2/4. Cette règle est donc retenue.
La méthode de prédiction proposée dans Jami et al. (2005) consiste à prédire une valeur
manquante de l’attribut, prescription dans cet exemple, en utilisant l’intersection des ensembles
prédits des règles dont le membre gauche est une sous-condition de la condition représentée
par le n-uplet possédant la valeur manquante.
Afin d’obtenir une prédiction ne portant que sur une valeur unique, nous proposons d’u-
tiliser une hiérarchie sur l’attribut à prédire. Cette hiérarchie est telle que les feuilles sont les
valeurs de l’attribut à prédire. Dans notre exemple, nous considérons la hiérarchie de la figure
1 où les feuilles sont aspegique, dafalgan, efferalgan, betnesol, coversyl, et où all est la racine.
all
mmm
mmm
mmm
PPP
PPP
PP
anti-inflammatoire
nnn
nnn
nn
PPP
PPP
PP
anti-hypertenseur
antalgique
sss
sss PPP
PPP
P corticoide coversyl
aspegique dafalgan efferalgan betsenol
FIG. 1 – Hiérarchie des médicaments
Avec cette hiérarchie et le même seuil de support que précédemment, les règles ρ1, ρ2, ρ3
et ρ4 considérées ci-dessus deviennent alors respectivement :
1. (X = 1) → anti-inflammatoire, car anti-inflammatoire est la généralisation la plus
spécifique dans la hérarchie de aspegique, dafalgan, efferalgan et betnesol.
2. (Y = 30)→ anti-inflammatoire, pour la même raison que ci-dessus.
3. (X = 2) → all, car toutes les valeurs possibles de prescription apparaissent dans
l’ensemble prédit.
4. (X = 2, Y = 30) → antalgique, car antalgique est la généralisation la plus spécifique
dans la hiérarchie de aspegique et dafalgan.
La première de ces règles est interprétée comme suit : pour X , l’observation du symptôme 1
est suffisamment fréquente pour conclure avec une confiance de 1 que le médicament prescrit
est un anti-inflammatoire.
T. Jen et Al.
Nous remarquons toutefois que toutes les règles obtenues ne présentent pas un intérêt pour
l’utilisateur. Ainsi, la règle (X = 2)→ all n’est d’aucun intérêt puisqu’elle prédit all, c’est à
dire tous les médicaments.
D’autre part, ρ : (X = 1, Y = 30) → anti-inflammatoire est une règle de prédiction
potentielle, mais, puisque la valeur prédite est la même que pour les conditions (X = 1) et
(Y = 30) seules, la règle ρ est considérée comme redondante. Cette règle ne sera pas retenue
selon notre approche.
Afin de prendre en compte ces remarques, une règle ρ qui prédit la valeur all ne sera pas
retenue, et une règle ρ plus spécifique qu’une règle ρ′ ne sera retenue que si elle prédit une
valeur plus spécifique (donc plus précise) que celle prédite par la règle ρ′.
Dans la section 2, nous définissons les concepts et notations utilisées par notre approche,
puis, dans la section 3, nous donnons les algorithmes de génération des règles retenues. La
section 4 propose une méthode de prédiction basée sur les règles retenues et donne certains
résultats expérimentaux. Nous concluons en section 5 en précisant les directions envisagées à
partir de ces travaux.
2 Définitions et notations
Considérons un ensemble fini d’attributs U = {A1, A2, . . . , An} et supposons qu’à chaque
Ai (i = 1, 2, . . . , n) est associé un ensemble de valeurs, appelé domaine de Ai et noté
dom(Ai). Pour tout i = 1, 2, . . . , n, dom(Ai) est soit un ensemble discret soit un ensem-
ble continu. Soit R une relation sur U , on note R la relation sur U obtenue en éliminant de R
tous les n-uplets contenant au moins une valeur manquante.
Definition 1 - Condition de prédiction. Une condition élémentaire est une expression de la
forme Ai = vi, Ai ∈ U, vi ∈ dom(Ai). Un n-uplet t sur U satisfait la condition élémentaire
Ai = vi, noté t |= (Ai = vi), si la restriction de t à Ai, notée t.Ai, est égale à vi.
Une condition de prédiction (ou simplement condition) Γ est soit une condition élémentaire
soit une conjonction de conditions élémentaires de la forme (Ai1 = v1∧Ai2 = v2∧. . .∧Aik =
vk) telle que, si j et j′ sont deux entiers distincts de {1, . . . , k}, alors Aij 6= Aij′ . L’ensemble{Ai1 , Ai2 , . . . , Aik} est appelé le schéma de Γ et noté sch(Γ).
Un n-uplet t satisfait Γ, noté t |= Γ, si t satisfait chaque condition élémentaire de Γ.
Toute condition de prédiction de la forme (Ai1 = v1 ∧ Ai2 = v2 ∧ . . . ∧ Aik = vk) sera plus
simplement notée (Ai1 = v1, Ai2 = v2, . . . , Aik = vk).
De plus, si Γ et Γ′ sont deux conditions de prédiction telles que toute condition élémentaire
de Γ est également une condition élémentaire de Γ′, on dit que Γ est une restriction de Γ′.
Dans l’exemple cité en introduction, (X = 2) et (X = 2, Y = 30) sont des conditions
de prédiction, la première étant élémentaire de schéma {X}, et la seconde étant composée, de
schéma {X,Y }. De plus, (X = 2) est une restriction de (X = 2, Y = 30).
Comme dans Jami et al. (2005), nous supposons que l’attribut sur lequel les ensembles
prédits sont calculés est fixé, et nous notons Ai0 cet attribut. De plus, nous supposons que l’at-
tribut prédit est associé à une hiérarchie, notée H(Ai0), ayant pour racine all et pour feuilles
les éléments de dom(Ai0) dans le cas discret, et dans le cas continu des intervalles deux à deux
disjoints dont l’union est égale à dom(Ai0).
Utilisation des règles d’association pour la prédiction de valeurs manquantes
Ainsi, dans le cas où Ai0 est continu, H(Ai0) permet de discrétiser de manière hiérar-
chique l’ensemble dom(Ai0). Par conséquent, dans notre approche, les cas continu et discret
concernant l’attribut prédit, sont traités de manière analogue.
Pour un nœud donné X de H(Ai0), tout nœud parent (direct ou indirect) de X est un
ancêtre de X , et tout nœud fils (direct ou indirect) de X est un descendant de X .
Un nœud X est dit plus spécifique qu’un nœud Y , noté Y  X , si X = Y ou si, dans
H(Ai0), X est un descendant de Y .
On remarque que, puisque H(Ai0) est un arbre, pour tout ensemble H de nœuds de
H(Ai0), il existe un unique élément de H(Ai0), noté min(H), qui est maximal par rapport
à  et tel que, pour tout X de H , min(H)  X .
Par exemple, si l’on considère la hiérarchie de la figure 1, pour H = {antalgique, efferal-
gan, betsenol}, on a min(H) = anti-inflammatoire, et pour H = {antalgique, coversyl}, on
a min(H) = all.
De plus, si X est un nœud de H(Ai0) et t un n-uplet sur U , on note t |= X le fait que
t.Ai0 est soit égale à X soit égale à un nœud descendant de X . En d’autres termes, t |= X si
X  t.Ai0 .
On remarque que, comme pour tout X de H(Ai0) on a all  X , tout n-uplet t satisfait
all  t.Ai0 . Par conséquent, toute règle dont la partie droite est all n’apporte aucune informa-
tion. La forme des règles extraites dans notre approche est donc définie comme suit.
Definition 2 - Règle de prédiction. Nous appelons règle de prédiction toute règle de la forme
Γ → XΓ, où Γ est une condition de prédiction telle que Ai0 6∈ sch(Γ) et XΓ ∈ H(Ai0) avec
XΓ 6= all.
Le support et la confiance d’une règle de prédiction sont définis comme suit.
Definition 3 - Support et confiance. Soit R une table sur U et ρ : Γ → XΓ une règle de
prédiction.
– Le support de Γ est défini par : sup(Γ) = |{t | t|=Γ)}||R|
– Le support de XΓ est défini par : sup(XΓ) =
|{t | t|=XΓ)}|
|R|
– Le support de ρ est défini par : sup(ρ) = |{t | t|=Γ,t|=XΓ)}||R|
– La confiance de ρ : Γ→ XΓ est définie par : conf(ρ) = sup(ρ)sup(Γ)
Soit s un seuil de support minimum, la condition de prédiction Γ (respectivement la règle de
prédiction ρ) est dite fréquente si sup(Γ) ≥ s (respectivement sup(ρ) ≥ s).
On notera que si Γ et Γ′ sont deux conditions de prédiction telles que Γ est une restriction de
Γ′, alors sup(Γ) ≥ sup(Γ′).
Cette remarque, qui exprime la monotonie du support des conditions de prédiction, sera
utilisée dans la section suivante concernant les algorithmes d’extraction des règles de prédic-
tion retenues dans notre approche, qui sont définies ci-après.
Il est également important de noter que si ρ : Γ→ XΓ a une confiance de 1, alors sup(ρ) =
sup(Γ).
Definition 4 - Règle retenue. Soit s un seuil de support, une règle de prédiction ρ : Γ→ XΓ
est retenue par rapport à s si :
T. Jen et Al.
– ρ est fréquente (i.e., sup(ρ) ≥ s),
– conf(ρ) = 1,
– Pour toute restriction Γ′ de Γ, conf(Γ′ → XΓ) 6= 1.
La première condition de la définition ci-dessus exprime que nous ne nous intéressons qu’aux
règles de prédiction qui s’appliquent dans une proportion suffisante de n-uplets de R, et la
deuxième condition exprime que seules les règles de prédiction exactes sont retenues dans
notre approche.
La troisième condition de la définition ci-dessus exprime le fait que l’on ne retient que les
règles de prédiction les plus générales, parmi celles ayant le même membre droit.
En effet, soit ρ : Γ → XΓ et ρ′ : Γ′ → XΓ′ deux règles de prédiction de confiance 1 et
telles que ρ est fréquente,XΓ = XΓ′ , et Γ′ est une restriction de Γ. Alors, puisque conf(ρ) =
conf(ρ′) = 1, on a sup(ρ) = sup(Γ) et sup(ρ′) = sup(Γ′). Donc, sup(ρ′) ≥ sup(ρ) (car
sup(Γ′) ≥ sup(Γ), du fait que Γ′ est une restriction de Γ). Par conséquent, ρ′ est fréquente, et
donc devrait être retenue selon les deux premiers critères.
Ces deux règles de prédiction ayant le même membre droit, ρ′ est redondante, et ne doit
donc pas être retenue. Par conséquent, la troisième condition de la définition ci-dessus permet
d’éviter les redondances dans les règles retenues.
Ainsi, si l’on considère ρ : (Y = 30)→ anti-inflammatoire et ρ′ : (Y = 30, Z = 300)→
anti-inflammatoire, ρ′ est une règle de prédiction fréquente, mais pas une règle retenue.
3 Algorithme d’extraction des règles
Il est important de noter en premier lieu que la propriété de monotonie du support d’une
condition de prédiction et le fait que l’on ne s’intéresse qu’à des règles de confiance égale à
1 ont pour conséquence qu’il est possible de calculer les règles retenues en utilisant un algo-
rithme par niveau parcourant le treillis des conditions de prédiction (selon l’ordre partiel induit
par la notion de restriction liée aux conditions de prédiction).
Ainsi, les algorithmes présentés dans cette section sont basés sur l’algorithme Apriori
(Agrawal et Srikant (1994)), avec la particularité, par rapport à l’algorithme classique, que les
règles retenues sont engendrées en même temps que les conditions de prédiction fréquentes.
Dans les algorithmes des figures 2 et 3, pour chaque niveau k du treillis des conditions de
prédiction (i.e., l’ensemble des conditions de prédiction constituées de k conditions élémen-
taires), on note respectivement Ck et Lk les ensembles de conditions de prédiction candidates
et fréquentes, etRk dénote l’ensemble des règles retenues dont le membre gauche est dans Lk.
Il est facile de voir que notre méthode est correcte et complète, à savoir que seules, toutes
les règles retenues (voir la définition 4) sont effectivement calculées.
En effet, l’algorithme Apriori étant lui-même correct et complet, toutes les conditions de
prédiction fréquentes sont calculées par l’algorithme 1. De plus :
– Les règles produites sont des règles de prédiction car aucune règle dont le membre droit
est all n’est retournée.
– Les règles produites sont des règles de confiance 1 car, pour toute règle produite Γ →
XΓ, la valeur XΓ est la généralisation la plus spécifique selon H(Ai0) de toutes les
Utilisation des règles d’association pour la prédiction de valeurs manquantes
valeurs α sur Ai0 de R pour lesquelles il existe t dans R tel que t |= Γ et t.Ai0 = α,
c’est à dire XΓ = min({α|(∃t ∈ R)(t |= Γ, t.Ai0 = α)})
– Par conséquent, les règles produites sont fréquentes, puisque leurs membres gauches le
sont.
– Enfin, la dernière boucle de l’algorithme principal (figure 2) garantit qu’aucune règle
redondante, selon la troisième condition de la définition 4, n’est produite.
Exemple 1. Nous illustrons les algorithmes des figures 2 et 3 dans le cadre de la table R
donnée en introduction de l’article, et avec un seuil de support de 0.1.
Au premier niveau, les conditions élémentaires fréquentes de L1 et les règles retenues de
R1 sont calculées. On obtient alors les résultats suivants : L1 = {(X = 1), (X = 2), (X =
3), (Y = 10), (Y = 20), (Y = 30), (Y = 40), (Z = 100), (Z = 300), (Z = 400)} et les
règles retenues sont données ci-dessous, avec leur support.
– ρ1 : (X = 1)→ anti-inflammatoire s = 7/15
– ρ2 : (X = 3)→ antalgique s = 2/15
– ρ3 : (Y = 10)→ antalgique s = 4/15
– ρ4 : (Y = 30)→ anti-inflammatoire s = 5/15
– ρ5 : (Z = 100)→ anti-inflammatoire s = 7/15
– ρ6 : (Z = 400)→ coversyl s = 2/15
Les conditions (X = 2), (Y = 20), (Y = 40) et (Z = 300) ne correspondent à aucune règle,
car une telle règle aurait son membre droit égal à all. En effet, par exemple pour (X = 2),
les valeurs à considérer sur l’attribut prescription sont successivement betsenol, coversyl et
aspegique et ont all comme unique ancêtre commun dans H(Ai0).
Au niveau 2, les conditions élémentaires de L1 sont combinées dans l’ensemble C2 et on
obtient L2 = {(X = 1, Y = 10), (X = 1, Y = 30), (X = 1, Z = 100), (X = 1, Z =
300), (X = 2, Y = 20), (X = 2, Y = 30), (X = 2, Z = 300), (X = 3, Y = 10), (X =
3, Z = 100), (Y = 10, Z = 100), (Y = 20, Z = 300), (Y = 30, Z = 100), (Y = 30, Z =
300)}. Après la dernière boucle de l’algorithme principal, l’ensemble R2 est alors réduit aux
règles suivantes :
– ρ7 : (X = 2, Y = 30)→ antalgique s = 2/15
– ρ8 : (Y = 30, Z = 100)→ antalgique s = 2/15
En effet, pour (Y = 20, Z = 300), les valeurs à considérer sont betsenol et coversyl, dont
le seul ancêtre commun dans H(Ai0) est all. De plus, par exemple pour (X = 1, Y = 10)
les valeurs à considérer sont efferalgan et aspegique, ce qui donnerait la règle (X = 1, Y =
10)→ antalgique, qui est retirée à cause de ρ3.
Au niveau 3, on a L3 = {(X = 1, Y = 10, Z = 100), (X = 1, Y = 30, Z = 300), (X =
2, Y = 20, Z = 300), (X = 3, Y = 10, Z = 100)}, mais on peut voir que finalement,
aucune règle prédite n’est retenue à ce niveau car toutes les règles de prédiction potentielles
sont redondantes. Par suite, l’ensemble des règles produites dans notre exemple est constitué
des règles ρ1, . . . , ρ8 mentionnées précédemment.
T. Jen et Al.
Algorithme 1 : algorithme principal
Entrée : la table R, un seuil de support s, la hiérarchieH(Ai0)
Sortie : l’ensemble des règles retenues.
Méthode
//Calcul des conditions fréquentes élémentaires et des règles retenues
//Nécessite une passe sur la table de données
C1 := ∅
Pour tout t de R faire
Pour tout A 6= Ai0 faire
Si (A = t.A) ∈ C1 alors
sup(A = t.A) := sup(A = t.A) + 1
XA=t.A := min(XA=t.A, t.Ai0)
Sinon
C1 := C1 ∪ {(A = t.A)}
sup(A = t.A) := 1
XA=t.A := t.Ai0
Fin Si
Fin Pourtout
Fin Pourtout
L1 := {Γ1 ∈ C1 | sup(Γ1) ≥ s}
R1 := {(Γ1 → XΓ1) | Γ1 ∈ L1 ∧XΓ1 6= all}
k := 2
R2 := ∅
Tant que Lk−1 6= ∅ faire
//Génération et élagage des candidats selon la méthode de Agrawal et Srikant (1994)
Ck := join(Lk−1)
Ck := Ck − {Γk ∈ Ck | (∃γ ∈ Γk)(Γk − γ /∈ Lk−1)}
//Calculs de Lk et Rk. Nécessite une passe sur la table de données
Calculer Lk et Rk
k := k + 1
Rk := ∅
Fin Tantque
Pour tout Γi → XΓi et Γj → XΓj de
⋃
k
Rk faire
Si Γi est une restriction de Γj etXΓi = XΓj alors
Retirer Γj → XΓj de
⋃
k
Rk
Fin Si
Fin Pourtout
Retourner
⋃
k
Rk
FIG. 2 – Algorithme d’extraction des règles retenues
Utilisation des règles d’association pour la prédiction de valeurs manquantes
Algorithme 2 : Calculs de Lk et Rk
Entrée : ensemble des candidats Ck
Sortie : les ensembles Lk et Rk
Méthode
Pour tout Γk de Ck faire
XΓk := NIL
sup(Γk) := 0
Fin Pourtout
Pour tout t de R faire
Pour tout Γk de Ck faire
Si t |= Γk alors
sup(Γk) := sup(Γk) + 1
SiXΓk = NIL alorsXΓk := t.Ai0 SinonXΓk := min(XΓk , t.Ai0)
Fin Si
Fin Pourtout
Fin Pourtout
Lk := {Γk ∈ Ck | sup(Γk) ≥ s}
Rk := {Γk → XΓk | (Γk ∈ Lk) ∧ (XΓk 6= all)}
Retourner Lk et Rk
FIG. 3 – Algorithme de calcul de Lk et de Rk
4 Méthode de prédiction et résultats expérimentaux
4.1 Méthode de prédiction
Si nous considérons un cas de prédiction comme une condition de prédiction, le but est
alors d’appliquer les règles retenues pour associer une valeur unique de prédiction, quand cela
est possible.
Si P est une condition de prédiction et ρ : Γ → XΓ une règle retenue, on dit que ρ est
applicable pour P si Γ est une restriction de P . On note alors Pred(P ) l’ensemble des règles
applicables pour P .
Notre méthode de prédiction est la suivante : Si Pred(P ) = ∅, alors aucune prédic-
tion n’est possible, puisque aucune règle retenue ne peut être appliquée. Sinon, soit µ =
min({XΓ | (Γ→ XΓ) ∈ Pred(P )}),
– si µ 6= all, alors µ est la valeur prédite,
– sinon (µ = all), aucune prédiction fiable n’est possible et l’intervention de l’utilisateur
est alors requise.
On notera à propos du dernier cas ci-dessus, qu’un critère de choix peut être de déterminer la
valeur prédite en ne considérant que la ou les règles de Pred(P ) dont le support est maximum.
Exemple 2. Nous illustrons cette méthode sur l’exemple de la table 1, à partir des règles
retenues calculées dans l’exemple 1, et en considérant différents cas de prédiction.
– Pour le n-uplet d’identifiant 4 de la table R, i.e., pour P = (X = 1, Y = 30, Z = 100),
on a Pred(P ) = {ρ1, ρ4, ρ5, ρ8}. Dans ce cas, on a µ = min({antalgique, anti-
inflammatoire}) = anti-inflammatoire, qui est ainsi la valeur prédite.
T. Jen et Al.
– Pour le n-uplet d’identifiant 11, i.e., pour P = (X = 3, Z = 100), on a Pred(P ) =
{ρ2, ρ5} et donc ici, µ = min({antalgique, anti-inflammatoire}) = anti-inflammatoire.
Donc la valeur prédite est de nouveau anti-inflammatoire.
– Pour P = (X = 1, Z = 400), alors on a Pred(P ) = {ρ1, ρ6} et donc µ = min({anti-
inflammatoire, coversyl}), soit µ = all. Dans ce cas aucune prédiction fiable n’est
possible, mais, en se basant sur le support, on peut néanmoins prédire la valeur anti-
inflammatoire, puisque sup(ρ1) = 7/15 et sup(ρ6) = 2/15.
4.2 Résultats expérimentaux
L’algorithme de génération des règles fréquentes a été implémenté en C++ et testé sur un
système Linux et un ordinateur de 2Ghz de CPU et 2 GO de mémoire centrale.
Pour effectuer les tests, nous avons utilisé deux bases de données provenant de UCI Ma-
chine Learning repository : El nino contenant des données océanographiques et météorologi-
ques avec 12 attributs et 178080 n-uplets, et Abalone contenant des données sur une population
d’haliotis (mollusque marin appelé abalone en anglais) avec 8 attributs et 4177 n-uplets.
Nous avons introduit de manière aléatoire, au niveau de la dernière colonne de type numé-
rique dans les deux cas, des valeurs manquantes (5%, 10%, 25%, 40%, 50%), et nous avons
construit une hiérarchie sur chacun de ces attributs.
Avec un support de 3%, le temps d’exécution est inférieur à 7s, le taux de prédiction, qui
est égal au rapport du nombre de prédictions effectuées sur le nombre total de n-uplets ayant
une valeur manquante, dépasse 75%, et plus de 99% des règles extraites prédisent un nœud
parent de la valeur réelle qui a été remplacée par une valeur manquante.
Nous avons également comparé notre méthode avec celle de Jami et al. (2005) sur la base
de la précision définie par (1 − |E||dom(Ai0 )| )100, où |E| est la longueur ou la cardinalité de
l’ensemble prédit.
Nous adaptons cette définition au contexte de l’utilisation des hiérarchies comme suit : la
précision est l’expression (1 − |X||dom(Ai0 )| )100, où |X| est le nombre de feuilles descendant
du nœud X dans le cas discret, et la somme des longueurs des intervalles qui sont les feuilles
descendant de X dans le cas continu.
Pour la base El nino, le taux de précision est de 30,89% avec la méthode de Jami et al.
(2005) et de 55% avec notre méthode. Pour la base Abalone, la précision est de 44% avec la
méthode de Jami et al. (2005) et de 37% avec notre méthode.
Ces résultats s’expliquent d’une part par le choix de la hiérarchie et d’autre part par la
présence de valeurs isolées dans l’attribut à prédire. En effet, lorsqu’un n-uplet a une valeur
isolée sur l’attribut à prédire, la partie droite de toute règle basée sur ce n-uplet est alors
généralisée, impliquant une diminution du taux de précision. Toutefois, l’avantage de notre
méthode par rapport à Jami et al. (2005),est de toujours fournir une seule valeur plus facile-
ment exploitable qu’un intervalle ou un ensemble.
5 Conclusion
Dans cet article, nous avons proposé une méthode de prédiction de valeurs manquantes sur
un attribut discret ou continu en utilisant des règles d’association. Cette méthode, qui utilise en
Utilisation des règles d’association pour la prédiction de valeurs manquantes
outre une hiérarchie définie sur l’attribut à prédire, permet d’extraire des règles fréquentes de
confiance 1 et ayant une conséquence unique, en ne nécessitant qu’un seuil (de support). Nous
projetons dans nos travaux futurs :
– d’étudier la possibilité de déterminer une hiérarchie automatiquement sur la base des
ensembles prédits par la méthode de Jami et al. (2005), et
– d’étendre la méthode proposée par Jami et al. (2005) et celle proposée dans cet article,
en exploitant l’approche de Ragel et Cremilleux (1998, 1999) pour obtenir une méthode
de prédiction sur plusieurs attributs.
Références
Agrawal, R. et R. Srikant (1994). Fast algorithms for mining association rules in large
databases. In VLDB’94, pp. 487–499. Morgan Kaufmann.
Jami, S., T.-Y. Jen, D. Laurent, G. Loizou, et O. Sy (2005). Extraction de règles d’association
pour la prédiction de valeurs manquantes. Revue Africaine de la Recherche en Informatique
et Mathématique Appliquée ARIMA Spécial CARI04, 103–124.
Jami, S., X. Liu, et G. Loizou (1998). Learning from an incomplete and uncertain data set :
the identification of variant haemoglobins. InWorkshop on IDAMP, ECAI’98.
Kamber, M. et J. Han (2005). Data Mining : Concepts and Techniques. Morgan Kaufmann
Publishers Inc.
Ragel, A. et B. Cremilleux (1998). Treatment of missing values for association rules. In
PAKDD ’98, Volume 1394 of Lecture Notes in Computer Science, pp. 258–270. Springer-
Verlag.
Ragel, A. et B. Cremilleux (1999). Mvc - a preprocessing method to deal with missing values.
Knowledge-Based Systems 12, 285–291.
Shen, J.-J., C.-C. Chang, et Y.-C. Li (2007). Combined association rules for dealing with
missing values. J. Inf. Sci. 33(4), 468–480.
Summary
Dealing with missing values is an important issue in the field of data warehousing. Several
solutions have been proposed in the literature for the prediction of missing values. In general,
these approaches are such that: (i) the values to be predicted are either continue or discrete, and
(ii) the prediction is not exact (as associated with a probability or as outputing a set of possible
values). Recently, an approach for the prediction of missing values based on association rule
mining has been introduced. The important features of this approach are that it generates
prediction rules with confidence 1, on any kind of values (numeric or discrete). In this paper,
we enhance this approach based on association rule mining by generating prediction rules for
single values, continuous or discrete, with confidence 1. To this end, our method relies on the
assumption that a hierarchy modeling concepts that generalize the values to be predicted, is
available.
