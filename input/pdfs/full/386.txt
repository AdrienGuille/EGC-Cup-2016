KGRAM: une machine abstraite de graphes de connaissance
Olivier Corby‚àó, Catherine Faron-Zucker‚àó‚àó
‚àóINRIA
2004 route des lucioles - BP 93 - FR-06902 Sophia Antipolis cedex
olivier.corby@sophia.inria.fr
‚àó‚àóI3S, UNS, CNRS
930 route des Colles - BP 145 - FR-06903 Sophia Antipolis cedex
catherine.faron-zucker@unice.fr
R√©sum√©. Cet article pr√©sente la machine abstraite de graphes de connaissance
KGRAM qui unifie les notions d‚Äôhomomorphisme de graphe et de calcul de re-
qu√™tes telles que celles du langage SPARQL sur des donn√©es RDF. KGRAM
impl√©mente un ensemble extensible d‚Äôexpressions qui d√©finissent une famille de
langages abstraits d‚Äôinterrogation de graphes, GRAAL. Nous d√©crivons la s√©-
mantique dynamique de GRAAL en S√©mantique Naturelle et nous pr√©sentons la
machine abstraite KGRAM con√ßue comme l‚Äôinterpr√®te de GRAAL, qui impl√©-
mente les r√®gles de s√©mantique naturelle du langage.
1 Introduction
Dans cet article nous pr√©sentons la machine abstraite de graphes de connaissance KGRAM
(acronyme pour Knowledge Graph Abstract Machine) qui unifie les notions d‚Äôhomomorphisme
de graphe et de calcul de requ√™tes telles que celles du langage SPARQL sur des donn√©es
RDF/S. KGRAM impl√©mente un ensemble extensible d‚Äôexpressions qui d√©finissent une famille
de langages abstraits d‚Äôinterrogation de graphes de connaissance quelconques, que nous appe-
lons GRAAL (acronyme pour GRAph Abstract query Languages). Ce travail d‚Äôabstraction que
nous avons men√© pour d√©finir GRAAL a √©t√© aliment√© par les r√©sultats du projet GRIWES (Ba-
get et al., 2008) auquel nous avons particip√©. Nous d√©finissons ici GRAAL par sa s√©mantique
dynamique en S√©mantique Naturelle et nous d√©finissons KGRAM comme l‚Äôimpl√©mentation
des r√®gles de s√©mantique naturelle de GRAAL.
Quant √† la machine KGRAM proprement dite, nous montrons le haut niveau d‚Äôabstraction
de son impl√©mentation qui ne manipule que des interfaces, aussi bien pour ses structures de
donn√©es que pour ses op√©rations de graphes. Ainsi, diff√©rents gestionnaires de graphes et √©va-
luateurs de contraintes peuvent √™tre connect√©s ‚Äî en impl√©mentant les APIs de KGRAM. Nous
montrons l‚Äôinterop√©rabilit√© de KGRAM en la connectant indiff√©remment aux gestionnaires de
graphes des moteurs s√©mantiques Corese 1 (Corby et al., 2004) et Jena 2 et √† l‚Äô√©valuateur de
contraintes de Corese.
La partie 2 suivante pr√©sente le langage GRAAL et la partie 3 la machine KGRAM.
1. http ://www-sop.inria.fr/edelweiss/software/corese/
2. http ://jena.sourceforge.net/
RNTI-E-19- 423 -
KGRAM: une machine abstraite de graphes de connaissance
2 La famille GRAAL de langages de requ√™te
Syntaxe abstraite. La syntaxe abstraite du c≈ìur de GRAAL est donn√©e par la grammaire
suivante :
Exp ::= NODE | EDGE | FILTER
| and(Exp, Exp) | union(Exp, Exp) | option(Exp)
| graph(NODE, Exp) | query(Exp) | not(Exp) | exist(Exp)
Les primitives que partagent tous les langages de la famille GRAAL sont les expressions NODE
et EDGE permettant de rechercher un n≈ìud ou une relation n-aire (hyperarc) dans un graphe.
Une expressions FILTER permet d‚Äôexprimer des contraintes sur les n≈ìuds recherch√©s dans le
graphe interrog√©. Remarquons que les expressions NODE, EDGE et FILTER sont primitives et
nous verrons dans la partir 3 qu‚Äôelles correspondent √† des interfaces dans la machine abstraite
KGRAM qui interpr√®te GRAAL.
Les expressions AND et UNION permettent d‚Äôexprimer une conjonction ou une disjonction
entre deux expressions.
Une expression OPTION permet de consid√©rer certaines expressions comme optionnelles.
Une expression GRAPH permet de sp√©cifier le graphe de connaissances sur lequel √©valuer une
expression (en l‚Äôabsence d‚Äôune telle expression, c‚Äôest un graphe par d√©faut qui est consid√©r√©).
Une expression QUERY permet d‚Äôexprimer des sous-requ√™tes dont le r√©sultat d√©termine des
liaisons de variables de la requ√™te appelante.
Une expression NOT exprime la n√©gation par l‚Äô√©chec. Une expression EXIST permet de ne
rechercher qu‚Äôune solution (la premi√®re trouv√©e).
D‚Äôautres expressions encore sont disponibles dans GRAAL qui ne sont pas pr√©sent√©es ici faute
de place. En outre, GRAAL est con√ßu pour √™tre extensible.
S√©mantique naturelle. La S√©mantique Naturelle a √©t√© initialement con√ßue par Kahn (1987)
pour fournir une s√©mantique op√©rationnelle aux langages de programmation, les r√®gles de s√©-
mantique naturelle constituant les sp√©cifications des interpr√®tes de ces langages. De mani√®re
analogue, en d√©finissant une s√©mantique op√©rationnelle de GRAAL, nous sp√©cifions la ma-
chine abstraite KGRAM qui peut √™tre vue comme un interpr√®te de GRAAL, les expressions de
celle-ci permettant d‚Äôinterroger des bases de graphes de connaissance.
En S√©mantique Naturelle, la s√©mantique op√©rationnelle d‚Äôun langage est donn√©e sous la
forme d‚Äôun ensemble de r√®gles d‚Äôinf√©rence, o√π les expressions du langage sont √©valu√©es dans
un environnement et l‚Äôapplication d‚Äôune r√®gle d‚Äôinf√©rence produit de nouveaux environne-
ments. Ainsi, les r√®gles d‚Äôinf√©rence de la s√©mantique de GRAAL d√©crivent l‚Äô√©volution de l‚Äôen-
vironnement lors de l‚Äô√©valuation des expressions du langage qui composent une requ√™te. Plus
pr√©cis√©ment, une expression dans une requ√™te est √©valu√©e dans un environnement consistant en
une liste de variables apparaissant dans la requ√™te et li√©es √† des n≈ìuds du graphe interrog√©, ces
liaisons r√©sultant de l‚Äô√©valuation pr√©c√©dente d‚Äôautres expressions de la requ√™te. L‚Äô√©valuation
d‚Äôune expression peut produire plusieurs environnements (dans le cas de plusieurs solutions)
et les autres expressions de la requ√™te √©valu√©es ensuite le sont dans chacun d‚Äôeux. Lorsque
toutes les expressions d‚Äôune requ√™te ont √©t√© √©valu√©es, chaque environnement qui en r√©sulte
correspond √† une solution trouv√©e.
Nous d√©crivons ici l‚Äôop√©rationalisation des expressions NODE, EDGE et FILTER de GRAAL
au travers de r√®gles de s√©mantique naturelle. Faute de place, les r√®gles op√©rationalisant les
RNTI-E-19 - 424 -
O. Corby et C. Faron-Zucker
autres primitives de GRAAL ne sont pas d√©crites dans cet article. les r√®gles 1 et 2 suivantes
montrent le calcul des listes d‚Äôenvironnements lors de l‚Äô√©valuation d‚Äôune expression demandant
la recherche d‚Äôun n≈ìud ou d‚Äôune relation dans un graphe. L‚Äô√©valuation d‚Äôune telle expression
dans un environnement ENV requiert de rechercher la liste d‚Äôenvironnements LENV contenant
les appariements possibles du n≈ìud ou de la relation dans le graphe interrog√© et de fusionner
ENV et LENV. Ces deux op√©rations sont synth√©tis√©es dans les r√®gles 1 et 2 par les bases de
r√®gles graph et merge qui d√©crivent la s√©mantique respectivement du gestionnaire de graphe et
du gestionnaire d‚Äôenvironnement.
graph(ENV  NODE ‚Üí LENV ) ‚àß merge(ENV,LENV ‚Üí LENV ‚Ä≤)
ENV  NODE ‚Üí LENV ‚Ä≤ (1)
graph(ENV  EDGE ‚Üí LENV ) ‚àß merge(ENV,LENV ‚Üí LENV ‚Ä≤)
ENV  EDGE ‚Üí LENV ‚Ä≤ (2)
Les r√®gles 3 et 4 suivantes montrent qu‚Äôun filtre est √©valu√© en utilisant les liaisons des
variables de la requ√™te dans l‚Äôenvironnement courant. Si le filtre est √©valu√© √† faux (r√®gle 3),
l‚Äôenvironnement devient vide (il n‚Äôy a pas de solution) ; sinon (r√®gle 4), l‚Äôop√©rateur list trans-
forme l‚Äôenvironnement en une liste d‚Äôun unique environnement.
eval(ENV  FILTER : false)
ENV  FILTER‚Üí œÜ (3)
eval(ENV  FILTER : true)
ENV  FILTER‚Üí list ENV (4)
Des langages GRAAL remarquables. Selon le sous-ensemble des primitives de GRAAL
que l‚Äôon consid√®re, on adopte un langage de requ√™tes particulier ou un autre. Une limitation
aux expressions NODE et NODE d√©finit un langage correspondant √† celui des Graphes Concep-
tuels simples Chein et Mugnier (2008). L‚Äôop√©rationalisation des r√®gles de s√©mantique naturelle
associ√©es √† ces expressions correspond √† la recherche d‚Äôhomomorphismes de graphes √©tique-
t√©s dont les relations peuvent √™tre n-aires. Nous verrons dans la partie 3 que ce calcul des
homomorphismes de graphes est la "colonne vert√©brale" de l‚Äôalgorithme de KGRAM.
En ajoutant au langage des expressions FILTER, on consid√®re le mod√®le des Graphes Concep-
tuels avec contraintes tel que pr√©sent√© par Baget et Mugnier (2002).
En ajoutant au langage les expressions AND, UNION, OPTION et GRAPH, nous d√©finissons
le fragment c≈ìur du langage SPARQL.
3 La machine abstraite KGRAM
Interfaces abstraites. La machine abstraite KGRAM acc√®de au graphe interrog√© au travers
d‚Äôune interface abstraite (API) qui en masque la structure et l‚Äôimpl√©mentation. Autrement dit,
KGRAM op√®re sur une abstraction de graphe, au travers de structures et de fonctions abs-
traites. Le graphe interrog√© est mod√©lis√© sous forme de sommets et d‚Äôarcs d‚Äôarit√© n quelconque
au travers des interfaces Node et Edge. Le langage de requ√™tes de KGRAM permet ainsi d‚Äôin-
terroger tout type de graphe de connaissances, par exemple aussi bien des graphes conceptuels
(dont les relations sont n-aires) que des graphes RDF (dont les relations sont binaires).
Non seulement les structures de donn√©es manipul√©es par KGRAM sont abstraites, mais
aussi ses op√©rateurs :
RNTI-E-19- 425 -
KGRAM: une machine abstraite de graphes de connaissance
‚Äì Le gestionnaire de graphes de KGRAM qui permet d‚Äôacc√©der au graphe interrog√© est
un objet impl√©mentant l‚Äôinterface Producer qui √©num√®re des arcs (resp. sommets) cibles
correspondant √† un arc (resp. sommet) requ√™te.
‚Äì Le test de correspondance entre les sommets (resp. arcs) est effectu√© par un objet im-
pl√©mentant l‚Äôinterface Matcher. Cet objet a la charge de la comparaison des √©tiquettes
(labels et types) de sommets. Selon l‚Äôimpl√©mentation de l‚Äôinterface Matcher, il prendra
en compte dans cette comparaison les relations de subsomption entre types, il pourra
autoriser des appariements approch√©s bas√©s sur des mesures de similarit√©, etc.
‚Äì Les contraintes (ou filtres) sont des objets abstraits qui impl√©mentent l‚Äôinterface Filter
et qui sont √©valu√©s par un objet qui impl√©mente l‚Äôinterface Evaluator. KGRAM ignore
la structure interne des filtres qu‚Äôil manipule, il se contente d‚Äôappeler la fonction eval de
l‚Äôinterface Evaluator sur des objets Filter, en passant en argument un Environment.
Ces interfaces montrent bien le haut niveau d‚Äôabstraction auquel nous nous sommes tenus dans
la conception de KGRAM. L‚Äôalgorithme de KGRAM qui manipule ces interfaces est ainsi
totalement abstrait, ind√©pendant de toute impl√©mentation et de toute structure de donn√©es.
Algorithme. La fonction eval de KGRAM √©value une expression du langage GRAAL sto-
ck√©e sous la forme d‚Äôune pile stack d‚Äôexpressions √©l√©mentaires. Elle fait appel √† un gestion-
naire de graphes abstrait producer qui consid√®re une expression exp de la pile stack et
l‚Äôenvironnement courant memory des liaisons de variables du graphe requ√™te avec des n≈ìuds
du graphe interrog√©. La fonction candidate du gestionnaire de graphes utilise l‚Äôenviron-
nement pour trouver les √©ventuels n≈ìuds dans l‚Äôexpression exp d√©j√† li√©s, de sorte qu‚Äôelle
retourne les seules relations candidates compatibles avec ces liaisons pr√©sentes dans l‚Äôenviron-
nement. Les relations candidates qui respectent les liaisons dans l‚Äôenvironnement sont ajout√©es
dans une pile des relations, ainsi que les n≈ìuds de la relation dans la pile des n≈ìuds de l‚Äôen-
vironnement. Cette pile de n≈ìuds peut √™tre utilis√©e comme environnement d‚Äô√©valuation des
filtres, comme nous le verrons plus loin. La recherche d‚Äôhomomorphisme aboutit et l‚Äôhomo-
morphisme partiel en construction devient complet lorsque le sommet de la pile d‚Äôexpressions
de la requ√™te est atteint : l‚Äôenvironnement courant repr√©sente alors une solution.
KGRAM est con√ßu comme l‚Äôinterpr√®te du langage GRAAL. Son algorithme repose sur
l‚Äôop√©rationalisation des r√®gles 1 et 2 de s√©mantique naturelle associ√©es aux expressions NODE
et EDGE de GRAAL qui permettent de rechercher des homomorphismes de graphe :
eval(stack, n){
if (stack.size() == n){store(); return;}
exp = stack(n);
switch(exp){
case EDGE:
for (Edge r : producer.candidate(exp, memory)){
if (match(exp, r)){ // test bindings, types, etc.
memory.push(exp, r); eval(stack, n+1); memory.pop(exp, r);}}
case NODE: ... // similar to case EDGE
case FILTER:
if (evaluator.eval(exp, memory)){eval(stack, n+1);}
... }}
Dans l‚Äôinstruction de contr√¥le switch, les blocs avec les types NODE et EDGE comme valeur
de la variable exp impl√©mentent les paquets de r√®gles graph et merge des r√®gles 1 et 2 et
RNTI-E-19 - 426 -
O. Corby et C. Faron-Zucker
donc augmentent l‚Äôenvironnement courant par des liaisons des n≈ìuds de la requ√™te avec des
n≈ìuds du graphe interrog√©. KGRAM permet ainsi une recherche d‚Äôhomomorphismes guid√©e
par l‚Äôappariement de n≈ìuds et/ou par l‚Äôappariement de relations.
Le bloc avec le type FILTER comme valeur de la variable de contr√¥le exp op√©rationa-
lise les r√®gles 3 et 4 de s√©mantique naturelle relatives aux expressions FILTER de GRAAL, et
ce faisant KGRAM impl√©mente la recherche d‚Äôhomomorphismes de graphe sous contraintes.
L‚Äôalgorithme de KGRAM utilise un √©valuateur de filtres abstrait evaluator et reste ind√©-
pendant de la nature des filtres trait√©s ‚Äî qui d√©pendent du langage de filtres impl√©ment√© par
l‚Äô√©valuateur appel√©. La fonction d‚Äô√©valuation de l‚Äô√©valuateur de filtres prend en argument le
filtre √† √©valuer et la pile de n≈ìuds qui constitue l‚Äôenvironnement courant d‚Äô√©valuation. Dans le
cas o√π le filtre est √©valu√© √† vrai, la recherche d‚Äôhomomorphismes continue avec comme envi-
ronnement celui issu de l‚Äô√©valuation du filtre. Dans le cas contraire, l‚Äôhomomorphisme partiel
que constituait l‚Äôenvironnement courant n‚Äôaboutit pas √† une solution.
Les r√®gles de s√©mantique naturelle des expressions AND, UNION et OPTION de GRAAL
sont op√©rationalis√©es dans KGRAM en int√©grant √† la "colonne vert√©brale" de l‚Äôalgorithme
pr√©sent√©e ci-dessus trois nouveaux blocs dans l‚Äôinstruction de contr√¥le switch. KGRAM
impl√©mente ainsi le c≈ìur du langage SPARQL et nous avons d√©velopp√© un compilateur qui
traduit des expressions SPARQL en expressions GRAAL. KGRAM op√©rationalise √©galement
les r√®gles de s√©mantique naturelle des autres expressions GRAAL pr√©sent√©es dans la partie 2 :
GRAPH, QUERY, NOT et EXIST. Cela n‚Äôest pas d√©taill√© dans cet article, faute de place.
Interop√©rabilit√©. Nous avons test√© la portabilit√© de KGRAM en r√©alisant une impl√©menta-
tion des interfaces Producer, Matcher et Evaluator de KGRAM par Corese et par Jena. Les
interfaces de KGRAM ont √©t√© con√ßues pour minimiser le "code glue" √† r√©aliser de sorte que
ces maquettes de portage de KGRAM sur un moteur ou sur l‚Äôautre ont demand√© relativement
peu de d√©veloppement. La connexion de Corese √† KGRAM a √©t√© presque imm√©diate, ce qui
s‚Äôexplique par le fait que nous avons con√ßu KGRAM en abstrayant les principes de Corese.
Connect√© √† Corese, KGRAM interpr√®te l‚Äôensemble des expressions de GRAAL. Avec Jena,
le portage a n√©cessit√© 416 lignes de code et quatre classes : EdgeImpl, ProducerImpl,
EvaluatorImpl et NodeImpl. Avec Jena, KGRAM interpr√®te actuellement les expres-
sions EDGE, FILTER, UNION, AND et OPTION. Le travail de maquettage se poursuit.
Ces deux impl√©mentations t√©moignent de la g√©n√©ricit√© de la conception de KGRAM et
laissent supposer une connexion facile de KGRAM √† d‚Äôautres impl√©mentations de gestion-
naires de graphes de connaissance.
4 Conclusion
Nous avons pr√©sent√© dans cet article la machine abstraite de graphes de connaissances
KGRAM et son langage de requ√™te √† base de graphes GRAAL. Nous avons √©tabli des r√®gles de
s√©mantique naturelle pour chacune des expressions de GRAAL, ces r√®gles d‚Äôinf√©rence consti-
tuant les sp√©cifications de KGRAM qui les op√©rationalise et qui peut √™tre vu comme un in-
terpr√®te du langage GRAAL. Nous avons mis en lumi√®re le niveau d‚Äôabstraction de KGRAM,
la simplicit√© de son algorithme reposant sur la manipulation d‚Äôinterfaces aussi bien pour les
op√©rateurs que pour les structures de donn√©es.
RNTI-E-19- 427 -
KGRAM: une machine abstraite de graphes de connaissance
Dans la continuit√© des r√©sultats pr√©sent√©s dans cet article, nous travaillons actuellement √†
l‚Äôint√©gration d‚Äôoptimisations telles que celles propos√©es par (Corby et Faron-Zucker, 2007),
comme le tri des relations dans la pile de l‚Äôenvironnement selon des heuristiques permettant
ensuite des op√©rations de backjump dans la pile, ou encore la possibilit√© de demander plusieurs
relations adjacentes au gestionnaire de graphes plut√¥t que de les demander une √† une.
Dans le prolongement de notre exp√©rience r√©ussie d‚Äôimpl√©mentation des interfaces de
KGRAM par les moteurs Corese et Jena, nos perspectives de travail sont d‚Äôaborder le probl√®me
de la distribution du traitement du web de donn√©es en interconnectant diff√©rents gestionnaires
de graphes responsables chacun d‚Äôune base d‚Äôannotations et impl√©mentant chacun l‚ÄôAPIs de
KGRAM. Nous envisageons KGRAM d‚Äôune part comme un √©l√©ment de r√©ponse au probl√®me
du passage √† l‚Äô√©chelle dans le traitement du web de donn√©es et d‚Äôautre part comme la cl√© de
voute d‚Äôapplications de mashup combinant les r√©sultats de diff√©rents gestionnaires de graphe.
R√©f√©rences
Baget, J., O. Corby, R. Dieng-Kuntz, C. Faron-Zucker, F.Gandon, A. Giboin, A. Gutierrez,
M. Lecl√®re, M. Mugnier, et R. Thomopoulos (2008). GRIWES : Generic Model and Pre-
liminary Specifications for a Graph-Based Knowledge Representation Toolkit. In Proc. of
the 16th International Conference on Conceptual Structures, ICCS 2008, Toulouse, France,
Volume 5113 of Lecture Notes in Computer Science, pp. 297‚Äì310. Springer.
Baget, J. et M. Mugnier (2002). Extensions of Simple Conceptual Graphs : the Complexity of
Rules and Constraints. J. Artif. Intell. Res. (JAIR) 16, 425‚Äì465.
Chein, M. et M. Mugnier (2008). Graph-based Knowledge Representation : Computational
Foundations of Conceptual Graphs. Springer London Ltd.
Corby, O., R. Dieng-Kuntz, et C. Faron-Zucker (2004). Querying the Semantic Web with
Corese Search Engine. In Proc. of the 16th Eureopean Conference on Artificial Intelligence,
ECAI 2004, pp. 705‚Äì709. IOS Press.
Corby, O. et C. Faron-Zucker (2007). Implementation of SPARQL Query Language Based
on Graph Homomorphism. In Proc. of the 15th International Conference on Conceptual
Structures, ICCS 2007, Sheffield, UK, Volume 4604 of Lecture Notes in Computer Science,
pp. 472‚Äì475. Springer.
Kahn, G. (1987). Natural Semantics. In Proc. of 4th Annual Symposium on Theoretical As-
pects of Computer Science, Passau, Germany, STACS 87, Volume 247 of Lecture Notes in
Computer Science, pp. 22‚Äì39. Springer.
Summary
In this paper we present the KGRAM Knowledge Graph Abstract Machine that unifies
graph homomorphism and SPARQL-like query processing on RDF datasets. KGRAM imple-
ments an extensible set of expressions which define the GRAAL family of GRAph Abstract
query Languages. We describe the dynamic semantics of GRAAL in Natural Semantics and e
present KGRAM which is designed as the interpret of GRAAL and implements the rules of
natural semantics of GRAAL.
RNTI-E-19 - 428 -
