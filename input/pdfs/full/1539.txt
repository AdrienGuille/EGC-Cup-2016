Nettoyage des données XML : combien ça coûte ?  
 
Laure Berti-Équille 
 
IRISA, Campus Universitaire de Beaulieu, 35042 Rennes cedex 
berti@irisa.fr 
http://www.irisa.fr 
 
Résumé. L'objectif de cet article est de présenter un travail en cours qui 
consiste à proposer, implanter et valider expérimentalement un modèle pour 
estimer le coût d’un processus de nettoyage de documents XML. Notre 
approche de calcul de coût est basée sur une méthode par calibration selon une 
analyse probabiliste. Pour cela, nous proposons de calculer des probabilités de 
pollution et au préalable de détection des différents types de pollutions. Pour 
valider notre modèle, nous avons choisi de polluer artificiellement une 
collection de données XML avec l'ensemble des types d'erreurs possibles 
(erreurs typographiques, ajout de doublons, de valeurs manquantes, tronquées, 
censurées, etc.) et d'estimer, grâce au  modèle proposé, le nombre et le coût des 
opérations nécessaires au nettoyage des données afin de proposer des stratégies 
de réparation ciblées et économes. Les expérimentations en cours ne sont pas 
rapportées dans cet article. 
 
1 Introduction 
 
Le nettoyage automatique des données se décompose classiquement en trois étapes : 1) 
examiner les données afin de détecter les incohérences, les données manquantes, les erreurs, 
les doublons, etc.  2) choisir les transformations pour résoudre les problèmes, 3) et enfin, 
appliquer les transformations choisies au jeu de données. La plupart des outils utilisés pour le 
nettoyage des données  par Extraction-Transformation-Loading (ETL) permettent l'extraction 
d'expressions régulières et structures (patterns) à partir des données, ainsi que leur 
transformation et formatage par l'application de différentes fonctions (sélection, fusion, 
clustering, etc.) (Vassiliadis 2003) dont généralement, on ignore a priori le coût. Bien qu’il 
existe de nombreux travaux (Dasu 2003), (Winkler 2003), (Rahm 2000) outils et prototypes 
(Telcordia (Caruso 2000), AJAX (Galhardas 2001), Potter’s Wheel (Raman 2001), Arktos 
(Vassiliadis 2000), IntelliClean (Low 2000), Tailor (Elfeky 2002)) développés pour 
« nettoyer » les données relationnelles, très peu de travaux à l’exception des récents travaux 
de Weis et Naumann (Weis 2004), ont jusqu’ici été menés pour le nettoyage de données 
XML et, à notre connaissance, aucun n’a abordé l’estimation du coût d’un nettoyage de 
données a fortiori  pour des données XML. C’est dans ce cadre qu’a débuté notre travail dont 
l’objectif est de proposer, d'implanter et valider expérimentalement un modèle de coût global 
permettant d’estimer combien peut coûter un processus de nettoyage sur un document XML 
artificiellement pollué pour les besoins de nos expériences.  
La suite de l’article s’organise de la façon suivante : la section 2 propose notre démarche 
illustrée par un exemple simple qui énumère les différents types de pollution possibles dans 
un document XML. La section 3 présente plus formellement notre modèle de coût avec ses 
- 379 - RNTI-E-5
Nettoyage de données XML 
 
définitions préliminaires et ses paramètres. Enfin, la section 4 conclut l’article et présente 
brièvement nos perspectives de travail. 
 
2 Problématique 
 
La Figure 1 illustre sur un exemple simple de document XML (clean.xml) quelques-uns 
des types d’erreurs pouvant être introduites artificiellement (dirty.xml) pour valider notre 
modèle. 
 
F R Q V W U D L Q W 9 L R O D W L R Q 
W H [ W 7 \ S R 
W U X Q F D W L Q J 
P L V V L Q J 
2 S p U D W L R Q V  p O p P H Q W D L U H V 
G H  S R O O X W L R Q 
F H Q V R U L Q J 
G X S O L F D W L Q J 
) L F K L H U  F O H D Q  [ P O 
 
< p e r s o n n e  I D = " 1 "  a g e = " 2 1 "  >  
 < n o m > M a h é < / n o m >  
< p r e n o m >  F l o r e n t  < / p r e n o m >  
 < t e l >  0 2 9 9 8 4 7 1 0 0  < / t e l >  
 < s a l a i r e >  2 0 0 0  < / s a l a i r e >  
< / p e r s o n n e >  
< p e r s o n n e  I D = " 2 "  a g e = " 2 3 "  >  
 < n o m > M o n r o y < / n o m >  
 < p r e n o m >  M i c k a e l  < / p r e n o m >  
 < t e l >  0 6 8 3 2 5 8 9 7 7  < / t e l >  
 < s a l a i r e >  1 9 0 0  < / s a l a i r e >  
< / p e r s o n n e >  
< p e r s o n n e  I D = " 3 "  a g e = " 2 2 "  >  
 < n o m >  M o s t e f a o u i  < / n o m >  
< p r e n o m >  S a l a h  < / p r e n o m >  
 < t e l >  0 2 9 9 8 4 7 1 0 0  < / t e l >  
 < s a l a i r e >  1 9 0 0  < / s a l a i r e >  
< / p e r s o n n e >  
< p e r s o n n e  I D = " 4 "  a g e = " 2 4 "  >  
 < n o m >  N y i t r a y  < / n o m >  
< p r e n o m >  R o n a n < / p r e n o m >  
 < t e l >  0 2 9 9 8 4 7 1 0 0  < / t e l >  
 < s a l a i r e >  4 5 0 0  < / s a l a i r e >  
< / p e r s o n n e >  
< p e r s o n n e  I D = " 5 "  a g e = " 2 5 "  >  
 < n o m >  M o r i c e a u  < / n o m >  
< p r e n o m >  J e a n - M a r i e  < / p r e n o m >  
 < t e l >  0 2 9 9 8 4 7 1 0 0  < / t e l >  
 < s a l a i r e >  2 0 0 0  < / s a l a i r e >  
< / p e r s o n n e >  
 
) L F K L H U  G L U W \  [ P O 
 
< p e r s o n n e  I D = " 1 "  a g e = " 2 1 "  >  
 < n o m > M a h é < / n o m >  
< / p r e n o m >  
 < t e l >  0 2 9 9 8 4 7 1 0 0  < / t e l >  
 < s a l a i r e >  2 0 0 0  < / s a l a i r e >  
< / p e r s o n n e >  
< p e r s o n n e  I D = " 2 "  a g e = " 2 3 "  >  
 < n o m > M o n r o y < / n o m >  
 < p r e n o m >  M i c k a e l  < / p r e n o m >  
 < t e l >  0 6 8 3 2 5 8 9 7 7  < / t e l >  
 < s a l a i r e >  1 9 0 0  < / s a l a i r e >  
< / p e r s o n n e >  
< p e r s o n n e  I D = " 2 "  a g e = " 2 3 "  >  
 < n o m > M o n r o y < / n o m >  
 < p r e n o m >  M i c k a e l  < / p r e n o m >  
 < t e l >  0 6 8 3 2 5 8 9 7 7  < / t e l >  
 < s a l a i r e >  1 9 0 0  < / s a l a i r e >  
< / p e r s o n n e >  
< p e r s o n n e  I D = " 3 "  a g e = " 2 2 "  >  
 < n o m >  M o s t e f  < / n o m >  
< p r e n o m >  S a l a h  < / p r e n o m >  
 < t e l >  0 2 9 9 8 4 7 1 0 0  < / t e l >  
 < s a l a i r e >  1 9 0 0  < / s a l a i r e >  
< / p e r s o n n e >  
< p e r s o n n e  I D = " 4 "  a g e = " 2 4 "  >  
 < n o m >  N y i t r a y  < / n o m >  
< p r e n o m >  R a h a n < / p r e n o m >  
 < t e l >  0 2 9 9 8 4 7 1 0 0  < / t e l >  
 < s a l a i r e >  2 0 0 0  < / s a l a i r e >  
< / p e r s o n n e >  
< p e r s o n n e  I D = " 2 5 "  a g e = " 5 5 "  >  
 < n o m >  J e a n - M a r i e  < / n o m >  
< p r e n o m >  M o r i c e a u  < / p r e n o m >  
 < t e l >  9 9 0 2 8 4 7 1 0  < / t e l >  
 < s a l a i r e >  2 0 0 0  < / s a l a i r e >  
< / p e r s o n n e >  
 
F R Q W H Q W ( [ F K D Q J H 
FIG. 1 - Exemple de pollution d’un document XML 
A partir d’une hypothèse assez intuitive qui est que plus la durée de vie d’un document 
XML est longue et ses mises à jour nombreuses, plus le risque d’introduire des erreurs à 
chaque mise à jour est grand, nous avons défini un taux de pollution qui prend en compte la 
probabilité qu’un arbre XML soit (ou non) pollué et préalablement détecté (ou non) comme 
tel. Ce taux de pollution, défini formellement dans la section suivante, peut être utilisé à des 
fins de diagnostic par un classifieur pour estimer la probabilité que le document soit correct 
ou bien pollué. Dans le cas d’un document détecté pollué, le modèle de coût que nous 
proposons permet d’estimer le coût global d’un scénario de nettoyage selon le type de 
pollution. Afin d’évaluer expérimentalement notre approche, nous avons pollué 
artificiellement une collection de documents XML. Pour chaque nœud d’un arbre XML, 
nous calculons la distance de similarité existante entre ce nœud et sa version artificiellement 
polluée et l’identifions au taux de pollution du nœud considéré sous l’hypothèse qu’il n’y a 
pas d’erreur dans la classification (le nœud étant détecté pollué à juste titre). Ceci nous 
permet d’avoir une estimation globale du coût d’un scénario de nettoyage qui est par la suite 
raffiné selon le type de pollution et le coût des opérateurs de nettoyage nécessaires. 
 
3 Modèle de coût 
 
3.1 Définitions préliminaires 
 
Définition 1. [Document XML]  
Un document XML est défini comme un arbre T = (N, E). L’ensemble des nœuds N = NE 
∪ NA ∪ NV, où NE est l’ensemble des éléments, NA l’ensemble des attributs et 
NV est l’ensemble des valeurs d’éléments et d’attributs de type texte ou 
- 380 -RNTI-E-5
Berti-Equille 
numérique. E est l’ensemble des arcs reliant les noeuds, en particulier, l’arc (u, 
v) ∈ E si et seulement si v est une valeur ou un fils de u. Un élément u est un fils 
de l’élément v si (v,u) ∈ E. Un élément u est le parent d’un noeud v si (u,v) ∈ E. 
Un noeud u est un ancêtre d’un noeud v s’il existe une série d’arcs qui relient u à 
v. 
 
Définition 2. [Processus de nettoyage de données XML]  
Un processus de nettoyage de données XML, noté C, est un quadruplet {M, B, O, S}, tel que 
M est le modèle de données XML (basé sur une DTD ou un schéma XSD), B est l’unité de 
base d’information (c’est-à-dire le contenu d’un nœud élément ou d’un nœud attribut), O est 
un ensemble d’opérateurs de nettoyage qui agit sur les instances du modèles de données. 
Chaque opérateur accepte en entrée une à plusieurs collections d’unités de base B et produit 
une collection d’unités de base en sorti. S est un ensemble possible de scénarii de nettoyage, 
c’est-à-dire un ensemble de listes d’opérateurs à utiliser pour le nettoyage.  
 
Définition 3. [Document XML pollué]  
Soit N un ensemble fini de nœuds dont le type est donné par  le modèle de données M, soit P un 
ensemble fini d’estampilles de pollution. Un document XML  pollué est un arbre Tp = (Np,Ep), p 
∈ P, où (i) l’ensemble des noeuds Np ⊆ N ; (ii) l’ensemble des arcs Ep ⊆ Np × Np × Np défini un 
arbre racine valide par rapport à M (c’est-à-dire satisfaisant le schéma imposé par le modèle de 
données entre les différents types de nœuds), ayant le quadruplet (parent, left, flag*(n,p), n) qui 
spécifie que le nœud n a le nœud  ‘‘parent’’ pour parent et le nœud ‘‘left’’ pour nœud frère à 
gauche. Le prédicat flag*(n,p) est vrai si le noeud n contient directement ou 
indirectement une (ou plusieurs) fonction(s) de pollution notée p. 
 
Définition 4. [Fonction de pollution]  
Une fonction de pollution notée p(T, nodeNumber,[minHeight, maxHeight, N, 
parameters]) a pour paramètres l’arbre T, un nombre de nœuds à polluer (qui 
peut être un entier ou exprimé en pourcentage), et de façon optionnelle les 
profondeurs minimale ou maximale localisant la région où est appliquée la 
pollution dans l’arbre T ou encore l’ensemble des noms des nœuds ciblés 
(étiquettes) et un ensemble de paramètres plus spécifiques selon le type de 
pollution. 
 
Définition 5. [Scénario de nettoyage]  
Un scénario de nettoyage Sp consiste à appliquer un ensemble d’opérations à un ensemble de 
nœud pollués selon un type de pollution p afin d’obtenir un ensemble de nœuds majoritairement 
non pollués. 
Notre modèle de coût se base sur le calcul d’une distance de similarité entre les nœuds du 
document XML sain et ceux de son correspondant artificiellement pollué. Cette distance est 
basée sur la distance q-gram entre les chaînes de caractères et elle est définie comme la 
norme L1 de [ ] [ ]vyGvxG qq )()( −  telle [ ] [ ]∑ ∑ −= ∈ qv qqq vyGvxGyxD )()(),(
, avec le q-
gram ∑∈= qqaaav 21  étant une chaîne de caractères dans l’alphabet fini ∑  de 
longueur q et x, y deux chaînes de caractères quelconques dans l’alphabet ∑ . [ ]vxG q )(  (resp. 
- 381 - RNTI-E-5
Nettoyage de données XML 
 
[ ]vyG q )( ) représente le nombre d’occurrences du q-gram v  dans x (resp. y). La distance q-
gram consiste donc à mesurer le nombre de caractères non communs entre les deux chaînes 
de caractères en prenant une fenêtre d’observation de longueur q. Par exemple, prenons q=2, 
et x = "clean" et y="clue", les 2-grams de x et y sont les suivants : (cl,le,ea,an) et (cl,lu,ue), 
on obtient pour x, [ ] 1)(2 =clxG , [ ] 1)(2 =lexG , [ ] 1)(2 =eaxG , [ ] 1)(2 =anxG  et [ ] 0)(2 =vxG  pour les autres 
2-grams de x. En listant les 2-grams commençant par  cl,le,ea,an,lu,ue dans cet ordre. On 
obtient un profil pour x tel que (1,1,1,1,0,0,…) et pour y tel que (1,0,0,0,1,1,0,…) et la 
distance 5),(2 =yxD . 
 
Définition 6 [Distance entre contenu de deux noeuds XML] La distance entre le contenu de 
deux nœuds n1 et n2 est définie telle que : 
pour n1 et n2  des nœuds de type texte 
 
 
pour n1 et n2  des nœuds de type 
élément 
 
      
 
Les fonctions infoSize et attrInfo renvoient respectivement la longueur arrondie du 
contenu et des valeurs d’attribut d’un nœud et sont définies de la façon suivante : 
ct et cv sont des constantes seuils permettant de diminuer la contribution de la similarité des 
textes courts et des valeurs d’attributs par rapport aux autres. Par exemple, une valeur d’attribut de 
plus courte longueur que cv sera traitée comme ayant une longueur de 1. ca, et ce  sont 
respectivement le contenu d’information correspondant au nom de l’attribut, ou au nom de 
l’élément. C est l’ensemble de tous les attributs de n1 et n2. D est le nombre d’attributs de n1 et n2  
non présents à la fois dans les deux nœuds. sametag(.,.) est une fonction qui retourne ce  dans le 
cas où les noms d’éléments sont égaux et 0 sinon. val(n,a) retourne la valeur de l’attribut a du 
nœud n, et text(n) retourne le contenu textuel du nœud n. 
 
3.2 Paramètres du modèle de coût pour l’estimation globale 
 
Suite à ces définitions, nous avons établi plusieurs paramètres permettant de modéliser, 
dans un premier temps, le coût global d’un nettoyage. Soient Pp(n) représentant la probabilité 
qu’un nœud soit détecté pollué, Pc(n) représentant la probabilité qu’un nœud soit détecté 
correct, Pcdp(n) représentant la probabilité qu’un nœud soit détecté pollué alors qu’il est 
correct, Ppdc(n) représentant la probabilité qu’un nœud soit détecté correct alors qu’il est 
pollué. On formuler alors le taux de pollution de type p pour le nœud n tel que : 
( )







++


 +
= ∑
cas autres lespour       1
)()),,(),,((min),(
  ))(),((,
2
)()(
min
),( 2121
21
21
21 DcaattrInfoanvalanvalqdistnnsametag
ntextntextqdistninfoSizeninfoSize
nntancecontentDis a
C
( )


−++
−
= ∑
),(
élément  typede noeudun , ,)1,),(max(
 texte typede noeudun , ),1,)(max(
)(
inattr
vae
t
naveccanvalcc
naveccntext
nSizeinfo
)1,),(min()1,),(min()( 21 vv canvalcanvalattrInfoa −+−=
- 382 -RNTI-E-5
Berti-Equille 
[ ]
∫
∫
∫
∫


 +
+



−


+
−

 +
+



=
Np ccdp
Np ccdp
Nclean ppdc
p
Nclean ppdc
dnnPP
MCost
MCostDCostUCostE
dnnPP
MCost
MCostUCostE
dnnPP
MCost
MCostSCostUCost
E
dnnPP
MCost
MCostUCostEnpPollution
)()(
))(),()(min(
)(1)(
))(),(min(
)(1)(
))(),()(min(
)()(
))(),(min(),(
 
Le terme (1a) définit les nœuds pollués qui sont malencontreusement détectés corrects et 
nous nous intéressons à la probabilité qu’un nœud soit classifié pollué (Pp) lorsque les 
nœuds ont toutes les caractéristiques de noeuds corrects (Nclean), d’où l’intégration sur cette 
surface. Le terme est pondéré par la probabilité qu’un nœud est détecté correct alors qu’il est 
en fait pollué (Ppdc) et par le temps de son traitement (représentant par un écart-type sur les 
temps de mise à jour et de maintenance). Généralement les temps de mise à jour (U), de 
détection (D) et de nettoyage de la pollution p (Sp) sont plus courts que la durée de vie totale 
du fichier et donc que le temps de sa maintenance (M). Le terme (1b) prend en compte les 
nœuds restant classifiés pollués, pondéré par la probabilité que le nœud soit détecté correct 
alors qu’il est pollué et par le temps de traitement (écart-type sur les temps de mise à jour, de 
nettoyage et de maintenance). Les termes (1c) et (1d) sont similaires. Le terme (1d) définit 
les nœuds corrects qui sont malencontreusement détectés pollués, pondéré par la probabilité 
qu’un nœud est détecté pollué alors qu’il est en fait correct (Pcdp) et par le temps de son 
traitement (écart-type sur les temps de mise à jour et de maintenance). Le terme (1d) prend 
en compte les nœuds restants classifiés corrects pondéré par la probabilité que le nœud soit 
détecté pollué alors qu’il est correct et par le temps de traitement incluant la mise à jour, la 
détection et la maintenance. Le taux de pollution peut être réécrit de la façon suivante : 
avec 



−

 +
=


 +
−


=
)(
))(),(min(
)(
))(),()(min(
)(
))(),()(min(
)(
))(),(min(
MCost
MCostUCostE
MCost
MCostDCostUCostEB
MCost
MCostSCostUCost
E
MCost
MCostUCostEA p
 
 
Traditionnellement, dans la théorie de la classification statistique, les variables A et B  
représentent les coûts d’une mauvaise classification. Dans notre formule, ces quantités 
représentent des pourcentages de temps pendant lequel un nœud est classifié correct ou 
pollué. Ainsi, le taux de pollution peut être défini comme le pourcentage de temps d’une 
mauvaise classification avec des temps de traitement additionnels pour résoudre cette 
mauvaise classification. Pour minimiser le taux de pollution Pollution(p,n), le mécanisme de 
détection doit classifier le noeud n soit correct soit pollué selon la règle de décision suivante : 
A
B
nPnP
nPnP
  sicorrect est n
A
B
nPnP
nPnP
  sip type de pollution une par pollué est n
cdpc
pdcp
cdpc
pdcp
<
≥
)().(
)().(
)().(
)().(  
Dans nos expériences, connaissant Cost(U), Cost(M) et la distance entre un nœud n et sa 
version artificiellement polluée np est identifiée à la probabilité de pollution du nœud, et 
nous évaluons A et B et déterminons Cost(Sp) et Cost(D) de façon à ce que soit vérifiée 
l’inégalité suivante : 


 +
−





−

 +
≥
)(
))(),()(min(
)(
))(),(min(
)(
))(),(min(
)(
))(),()(min(
),(
MCost
MCostSCostUCost
E
MCost
MCostUCostE
MCost
MCostUCostE
MCost
MCostDCostUCostE
npnstancecontentDi
p
 
4 Conclusion 
cdp
pdc
p
Np ccdpNclean ppdc
P
MCost
MCostUCostE
P
MCost
MCostSCostUCost
E
dnnPPBdnnPPAnpPollution



+


 +
+
+= ∫∫
)(
))(),(min(
)(
))(),()(min(
)(.)(.),(
(1a) 
 
(1b) 
 
(1c) 
 
(1d) 
- 383 - RNTI-E-5
Nettoyage de données XML 
 
 
Cet article présente succinctement un travail en cours d’expérimentation qui consiste à 
proposer, implanter et valider un modèle permettant d’estimer globalement le coût probable 
d’un processus de nettoyage de documents XML. Pour cela, nous proposons de calculer des 
probabilités de pollution et de détection sur les différents types d'erreurs possibles sur les 
données (erreurs typographiques, ajout de doublons, de valeurs manquantes, etc.) qui 
préservent la validité structurelle des documents XML par rapport à leur modèle de données 
(DTD ou XSD). Selon les résultats des expériences de pollution artificielle en cours qui 
permettent de corroborer notre modèle global, nous envisageons de raffiner notre approche 
au niveau du coût de chaque type d’opérateur de nettoyage, notamment en utilisant les 
historiques des scénarii de nettoyage sur des documents XML. 
 
Références 
 
Caruso F., Cochinwala M., Ganapathy U., Lalk G. et  Missier P. (2000), Telcordia’s 
Database Reconciliation  and Data Quality Analysis Tool, Conf. VLDB, 2000.  
Dasu T. et Johnson T. (2003), Exploratory Data Mining and Data Cleaning, Wiley, 2003. 
Elfeky M.G., Verykios V.S., et Elmagarmid A.K. (2002), Tailor: A Record Linkage 
Toolbox, Intl. ICDE Conf., 2002. 
Galhardas H., Florescu D., Shasha D., Simon E.  et Saita C. (2001), Declarative Data 
Cleaning: Language, model and algorithms, Intl. Conf. VLDB, 2001. 
Low W.L., Lee M.L.  et Ling T.W.  (2001), A Knowledge-Based Approach for Duplicate 
Elimination in Data Cleaning, Information System, Vol. 26 (8), 2001. 
Rahm E. et Do H.,  (2000)Data Cleaning: Problems and Current Approaches. IEEE Data 
Eng. Bull., 23(4): 3-13, 2000. 
Raman V.  et Hellerstein J. M.  (2001), Potter’s Wheel: An Interactive Data Cleaning 
System, Intl. Conf. VLDB, 2001. 
Vassiliadis P., Vagena Z., Skiadopoulos S.  et Karayannidis N. (2003), ARKTOS: A Tool 
For Data Cleaning and Transformation in Data Warehouse Environments. IEEE Data 
Eng. Bull., 23(4): 42-47, 2000. 
Vassiliadis P., Simitsis A., Georgantas P.  et Terrovitis M.  (2003), A Framework for the 
Design of ETL Scenarios, Conf. on Advanced Information Systems Engineering 
(CAiSE ’03), Klagenfurt, Austria, 2003. 
Weis M. et Naumann F. (2004), Detecting Duplicate Objects in XML Documents, ACM 
Workshop on Information Quality in Information Systems, 2004. 
Winkler W. (2003), Data Cleaning Methods, Intl. Conf. KDD, 2003. 
 
- 384 -RNTI-E-5
