Auto-administration des entrepo^ts
de donnees complexes
Kamel Aouiche
Jero^me Darmont, Omar Boussaid, Fadila Bentayeb
Laboratoire ERIC, Universite Lumiere Lyon 2
5 avenue Pierre Mendes-France
69676 Bron Cedex
 kaouiche@eric.univ-lyon2.fr
fjdarmont,boussaid,bentayebg@univ-lyon2.fr
http://eric.univ-lyon2.fr
Resume. Les reque^tes denies sur les entrepo^ts de donnees sont souvent
compliquees et utilisent plusieurs operations de jointure qui sont cou^teuses
en terme de temps de calcul. Dans le cadre de l'entreposage de donnees
complexes, les adaptations apportees aux schemas classiques d'entrepo^ts
induisent des jointures supplementaires lors des acces aux donnees. Ce
cou^t devient encore plus important quand les reque^tes operent sur de tres
grands volumes de donnees. Il est donc primordial de reduire ce temps
de calcul. Pour cela, les administrateurs d'entrepo^ts de donnees utilisent
en general des techniques d'indexation comme les index de jointure en
etoile ou les index bitmap de jointure. Cela demeure neanmoins complexe
et fastidieux.
La solution proposee s'inscrit dans une optique d'auto-administration des
entrepo^ts de donnees. Dans ce cadre, nous proposons une strategie de
selection automatique d'index. Pour cela, nous avons recouru a une tech-
nique de fouille de donnees, plus particulierement la recherche de motifs
frequents, pour determiner un ensemble d'index candidats a partir d'une
charge donnee. Nous proposons ensuite des modeles de cou^t permettant
de selectionner les index engendrant le meilleur prot. Ces modeles de
cou^t evaluent en particulier le temps d'acces aux donnees a travers des
index bitmap de jointure, ainsi que le cou^t de maintenance et de stockage
de ces index.
Mots cles : Entrepo^ts de donnees, donnees complexes, auto-administration,
selection d'index, motifs frequents, modeles de cou^t, index bitmap de join-
ture.
1 Introduction
Les entrepo^ts de donnees classiques sont generalement modelises selon un schema en
etoile contenant une table de faits centrale volumineuse et un certain nombre de tables
dimensions representant les descripteurs des faits [Inmon, 2002] [Kimball et Ross, 2002].
La table de faits contient les cles (etrangeres) des tables dimensions et les mesures. La
Figure 1 montre un exemple d'entrepo^t de donnees modelise en etoile compose de la
Auto{administration des entrepo^ts de donnees complexes
table de faits Sale et des tables dimensions Products et Customers.
 
Customers 
C_ID 
Gender 
City 
State 
Sales 
P_ID 
C_ID 
Total 
Products 
P_ID 
Weight 
Size 
Type 
‚Ä¶ 
Fig. 1 { Exemple d'entrepo^t de donnees modelise en etoile
Les entrepo^ts de donnees classiques permettent d'analyser des activites representees
sous la forme de donnees numeriques. Cependant, les donnees exploitees dans le cadre
des processus decisionnels sont de plus en plus complexes. L'avenement du Web et la
profusion de donnees multimedias ont en grande partie contribue a l'emergence de cette
nouvelle sorte de donnees. Nous considerons que des donnees sont complexes si elles
sont :
{ multiformats (donnees numeriques, symboliques, textes, images, sons, videos...)
et/ou
{ multistructures (bases de donnees relationnelles, collections de documents XML...)
et/ou
{ multisources (bases de donnees reparties, Web...)
et/ou
{ multimodales (un me^me phenomene decrit par plusieurs canaux ou points de vue,
comme des radiographies et le diagnostic audio d'un medecin pour evaluer l'etat
de sante d'un patient, des donnees exprimees dans des echelles ou des langues
dierentes...)
et/ou
{ multiversions (bases de donnees temporelles, recensements periodiques dont les
criteres evoluent...).
Les donnees complexes sont representees par un ensemble de descripteurs de bas
niveaux et semantiques. Leur manipulation s'opere par l'intermediaire de ces descrip-
teurs. Leur multiplication permet d'obtenir une information de plus en plus complete
sur les donnees complexes elles-me^me, mais complique egalement leur exploitation.
Le choix des descripteurs les plus pertinents a considerer dans le cadre d'un pro-
cessus decisionnel devient alors un vrai probleme. Les concepts de l'entreposage de
RNTI - E -
Kamel Aouiche et al.
donnees demeurent cependant valides dans ce contexte. Les mesures, bien que non
necessairement numeriques, restent des indicateurs pour l'analyse et cette derniere
s'eectue vraisemblablement selon dierentes perspectives representees par des dimen-
sions. La volumetrie des donnees et leur datation jouent egalement en faveur d'une
approche d'entreposage.
Dans le cadre d'un projet dans le domaine de la medecine du sport, nous avons
concu un entrepo^t de donnees medicales complexes (qualitatives, numeriques, textes,
images...) concernant un grand ensemble de sportifs de haut niveau. Cet entrepo^t, base
sur une modelisation relationnelle des donnees, a necessite des adaptations des schemas
en etoile classiques incluant notamment un eclatement de la table de faits en plusieurs
relations. Or, avec ce type de modele, une reque^te decisionnelle necessite deja une ou
plusieurs jointures entre la table de faits et les tables dimensions. Notre adaptation pour
les donnees complexes accentue donc ce phenomene. De plus, le schema de l'entrepo^t
comporte des hierarchies au niveau des dimensions (schema en ocon de neige), ce qui
entra^ne des jointures additionnelles. La multiplication des jointures rend complexe le
choix des meilleurs index a construire. Le cou^t de ces jointures en terme de temps de
calcul devient prohibitif et s'amplie davantage lorsque celles-ci operent sur de tres
grands volumes de donnees. Il est alors crucial de le reduire.
Plusieurs techniques ont ete proposees pour ameliorer le temps de calcul des join-
tures dans les bases de donnees, telles la jointure par hachage, par tri-fusion et la
jointure imbriquee [Mishra et Eich, 1992]. Cependant, ces techniques ne sont ecaces
que lorsque la jointure s'applique a deux tables et que le volume de donnees est rela-
tivement faible. Lorsque le nombre de jointures est superieur a deux, il faut alors les
ordonner en fonction des tables a joindre (probleme d'ordonnancement des jointures).
D'autres techniques, utilisees dans les entrepo^ts de donnees, exploitent des index de
jointure pour precalculer ces dernieres an d'assurer un acces rapide aux donnees. L'ad-
ministrateur de l'entrepo^t de donnees a donc pour ta^che cruciale de choisir les meilleurs
index a construire (probleme de selection d'index).
Avec le developpement des bases de donnees en general et des entrepo^ts de donnees
en particulier, il est devenu tres important de reduire la fonction d'administration
des Systemes de Gestion de Bases de Donnees (SGBD) [Weikum et al., 2002] ou du
moins de fournir des outils d'aide pour l'administrateur. Ces fonctionnalites sont par-
ticulierement critiques dans le cas des entrepo^ts de donnees complexes, du fait de
l'heterogeneite me^me des donnees stockees. Les systemes auto-administratifs ont pour
objectif de s'administrer et de s'adapter eux-me^mes, automatiquement, sans perte (ou
me^me avec un gain) de performance. Dans ce cadre, nous avons propose une demarche
de selection automatique d'index dans les bases de donnees fondee sur l'extraction de
motifs frequents a partir d'une charge [Aouiche et al., 2003a] [Aouiche et al., 2003b],
puis quelques pistes pour l'adaptation de cette demarche dans le contexte des entrepo^ts
de donnees [Aouiche et al., 2004]. Notons que la selection d'index est neanmoins un
processus complexe aussi bien dans le cas ou les donnees sont simples ou complexes.
Dans cet article, nous presentons la poursuite de nos travaux dans cette voie avec
pour objectif une application sur notre entrepo^t de donnees medicales complexes. Par-
tant du constat que tous les index candidats fournis par la phase d'extraction des
motifs frequents ne peuvent pas e^tre construits en pratique (contraintes systemes ou
RNTI - E -
Auto{administration des entrepo^ts de donnees complexes
d'espace de stockage), nous proposons une strategie permettant de selectionner les
plus avantageux gra^ce a des modeles de cou^t. Ces modeles nous permettent d'estimer
le cou^t d'acces aux donnees a travers ces index et le cou^t de leur maintenance et de
leur stockage. Un algorithme glouton exploite ces modeles an de recommander une
conguration d'index pertinente.
Par ailleurs, nous avons choisi dans ce travail de nous focaliser sur les index bitmap
de jointure car ils sont bien adaptes a l'environnement des entrepo^ts de donnees. En
eet, les bitmaps de ces index rendent ecace l'execution d'operations courantes comme
And, Or, Not ou Count qui operent sur les bitmaps (donc en memoire) et non plus sur
les donnees sources. De plus, les jointures sont prealablement calculees au moment
de la creation de ces index. Elles ne sont donc pas calculees lors de l'execution des
reque^tes. D'autre part, l'espace disque occupe par les bitmaps est faible, notamment
quand la cardinalite des attributs indexes n'est pas elevee [Sarawagi, 1997] [Wu, 1999].
Ces attributs sont souvent utilises dans les clauses Where et Group by des reque^tes
decisionnelles [Hu et al., 2003].
Cet article est organise comme suit. Nous presentons tout d'abord un etat de l'art
concernant les index de jointure et les approches proposees pour la selection d'index
dans les entrepo^ts de donnees (Section 2). Nous rappelons le principe de notre demarche
de selection automatique d'index a base d'extraction de motifs frequents (Section 3).
Nous presentons ensuite nos modeles de cou^t (Section 4) et detaillons notre strategie
de selection d'index (Section 5). An de valider celle-ci, nous l'avons experimentee sur
un entrepo^t de donnees test (Section 6). Nous terminons enn par une conclusion et
des perspectives de recherche (Section 7).
2 Etat de l'art
2.1 Techniques d'indexation dans les entrepo^ts de donnees
Au dela des index structures en b-arbre et de leurs variantes, il existe d'autres
techniques d'indexation plus adaptees a l'environnement des entrepo^ts de donnees. Ces
approches prennent en compte la volumetrie des donnees et la complexite des reque^tes
decisionnelles.
Dans un premier temps, les index de jointure ont ete proposes dans les bases de
donnees [Valduriez, 1987]. Ce type d'index, utilise pour pre-joindre deux tables, a ete
etendu aux entrepo^ts de donnees. En eet, les index de jointure en etoile (star join
index ) peuvent contenir toutes combinaisons de cles etrangeres de la table de faits et de
cles primaires des tables dimensions resultantes de la jointure de ces tables [Brick, 1997].
Un index de jointure en etoile est dit complet s'il est construit en joignant toutes les
tables de dimensions avec la table de faits. Il est dit partiel s'il est construit en ne
joignant que certaines dimensions avec la table de faits. En consequence, l'index complet
est beneque pour n'importe quelle reque^te mais exige beaucoup d'espace disque pour
son stockage et son cou^t de maintenance est eleve.
Les index bitmap [Wu et Buchmann, 1998] sont ecaces quand la cardinalite (nom-
bre de valeurs distinctes) de l'attribut indexe n'est pas elevee. A chaque valeur de ce
dernier est associe un bitmap contenant autant de bits que de n-uplets de la table
RNTI - E -
Kamel Aouiche et al.
indexee. Le ieme bit du bitmap associe a une valeur est mis a 1 si cette derniere est
presente dans le ieme n-uplet de la table, autrement, il est mis a 0.
Une variante des index bitmaps sont les index bitmap de jointure (bitmap join in-
dexes) [O'Neil et Graefe, 1995]. Un bitmap contenant autant de bits que de n-uplets
de la table de faits est cree pour chaque valeur distincte de l'attribut indexe d'une
dimension. Le ieme bit du bitmap est mis a 1 si le n-uplet de la table de dimen-
sions contenant la valeur associee a ce bitmap peut e^tre joint avec le iieme n-uplet
de la table de faits. Dans le cas contraire, ce bit est mis a 0. Dans l'entrepo^t de
donnees de la Figure 1, nous montrons un index bitmap de jointure sur la table de
faits Sales en utilisant l'attribut \Gender" de la table de dimension Customers (Fi-
gure 2) [Vanachayobon et Gruenwald, 1999]. Notons que l'attribut indexe \Gender" ne
se trouve pas dans la table indexee Sales.
100513
400210
100911
20910
100511
900110
100610
10710
500515
100211
100510
TotalC_IDP_ID
Sales
F105022
I104021
E105019
I105018
H10517
D105016
B105015
A103014
C105013
A105012
B105011
A101010
TypeSizeWeightP_ID
Products
OKMooreF10
OKNormanM9
TXDallasF8
OKNormanM7
OKOKCF6
VARonoakeF5
OKNormanM4
OKOKCM3
OKNormanF2
OKNormanF1
StateCityGenderC_ID
Customers
01
01
10
10
01
01
01
10
01
01
01
MF
Index bitmap de jointure
Fig. 2 { Exemple d'index bitmap de jointure
Un index bitmap de jointure peut egalement e^tre construit sur plusieurs attributs
appartenant a des tables dimensions dierentes, jointes avec la table de faits (par
exemple, l'attribut \Gender" de la table Customers et l'attribut \Type" de la table
Products). Dans ce cas, l'index est appele index bitmap de jointure multiple (multiple
bitmap join) [Vanachayobon et Gruenwald, 1999].
Par ailleurs, les index de jointure de dimensions (dimension join) ont ete proposes
pour les entrepo^ts de donnees modelises en ocon de neige [Bizarro et Madeira, 2001].
Le principe de ces index bitmap est de rapprocher la table de faits des tables dimensions
(hierarchies) en realisant le pre-calcul des jointures dans une me^me hierarchie. L'index
de jointure de dimensions represente un \plus court chemin" entre la table de faits et
les tables dimensions.
2.2 Selection d'index dans les entrepo^ts de donnees
Le probleme de selection d'index dans les bases de donnees est
etudie depuis plusieurs annees [Finkelstein et al., 1988] [Frank et al., 1992]
RNTI - E -
Auto{administration des entrepo^ts de donnees complexes
[Chaudhuri et Narasayya, 1998] [Agrawal et al., 2000] [Valentin et al., 2000]
[Feldman et Reouven, 2003] [Kratica et al., 2003]. Ce probleme reste pose dans
les entrepo^ts de donnees. Les travaux qui s'y rapportent peuvent e^tre classes
en deux familles : les algorithmes cherchant a optimiser le temps de mainte-
nance [Labio et al., 1997] et ceux cherchant a optimiser le temps d'execution des
reque^tes [Gupta et al., 1997] [Agrawal et al., 2001] [Golfarelli et al., 2002]. Dans les
deux cas, l'optimisation est realisee sous la contrainte d'espace de stockage alloue
aux index par l'administrateur. Nous nous interessons dans cet article aux trois
algorithmes de la deuxieme famille qui se rapprochent de notre travail.
Le premier algorithme parcourt un multi-graphe bipartie en exploitant un modele
de cou^t pour recommander un ensemble de vues materialisees et d'index minimisant
le cou^t d'execution des reque^tes [Gupta et al., 1997]. Ce multi-graphe relie les index
et les vues aux reque^tes ou ils sont presents. Le deuxieme algorithme, implante dans
SQL serveur, enumere tous les index et vues materialisees pouvant contribuer a la
reduction du temps d'execution d'un ensemble de reque^tes [Agrawal et al., 2001]. Des
appels a l'optimiseur de reque^tes permettent ensuite de reduire le nombre de candidats
(index et vues). Un ensemble nal d'index et de vues materialisees est alors propose.
Le troisieme algorithme se base sur une approche heuristique permettant progressive-
ment de choisir a partir d'un ensemble de candidats (index et vues) les index les plus
avantageux [Golfarelli et al., 2002]. Le choix est realise en comparant le cou^t des plans
d'execution possibles, generes par l'optimiseur de reque^tes, de chaque reque^te de la
charge.
3 Demarche de selection automatique d'index
Dans cette section, nous presentons une extension de nos travaux sur la selection au-
tomatique d'index [Aouiche et al., 2003a] [Aouiche et al., 2003b] [Aouiche et al., 2004].
La demarche que nous proposons (Figure 3) exploite le journal des transactions (en-
semble de reque^tes resolues par le SGBD) pour recommander une conguration (en-
semble) d'index ameliorant le temps d'acces aux donnees.
Tout d'abord, nous extrayons de la charge des attributs indexables (c'est-a-dire
les attributs utiles lors de l'execution des reque^tes s'ils sont indexes). Ces attributs
sont stockes dans une matrice, dite \reque^tes-attributs", qui correspond a un contexte
d'extraction exploite par l'algorithme de fouille de donnees Close [Pasquier et al., 1999].
Nous obtenons alors un ensemble de motifs frequents fermes. Chaque motif de cet
ensemble est analyse an de generer un ensemble d'index candidats en s'appuyant sur
les metadonnees (schema : cles primaires, cles etrangeres; statistiques...) de l'entrepo^t
de donnees. Enn, nous procedons a un processus d'elagage, suivant les modeles de cou^t
presentes dans la Section 4, avant de construire eectivement la conguration d'index.
Nous detaillons chacune des ces etapes dans les sections qui suivent.
3.1 Analyse de la charge
Les reque^tes presentes dans la charge (journal des transactions) sont traitees
par un analyseur syntaxique de reque^tes SQL an d'extraire tous les attri-
RNTI - E -
Kamel Aouiche et al.
M√©tadonn√©es 
(Sch√©ma, statistiques ‚Ä¶) 
G√©n√©ration des index 
 
Entrep√¥t de 
donn√©es  
Extraction  
des attributs indexables
 
Cr√©ation des index 
 
Mod√®les de co√ªt 
 
Configuration d‚Äôindex 
 
Index  candidats
 
Ensemble de motifs fr√©quents
 
Charge 
Matrice requ√™tes-attributs 
(Contexte d‚Äôextraction)
 
Application de Close  
 
S√©lection d‚Äôindex 
 
Fig. 3 { Strategie de selection automatique d'index
buts susceptibles d'e^tre des supports d'index. Ces attributs sont ceux presents
dans les clauses Where des reque^tes (attributs servant a la recherche dans les
reque^tes d'interrogation). Dans les systemes decisionnels, les reque^tes sont de
type Select (read only) et les rafra^chissements (batch update) sont realises
periodiquement [Vanachayobon et Gruenwald, 1999]. Nous ne construisons la matrice
\reque^tes-attributs" qu'a partir des reque^tes d'interrogation.
3.2 Construction du contexte d'extraction
A partir des attributs extraits dans l'etape precedente, nous construisons une ma-
trice \reque^tes-attributs" qui a pour lignes les reque^tes de la charge et pour colonnes
les attributs a indexer. L'existence d'un attribut indexable dans une reque^te est sym-
bolisee par 1 et son absence par 0. Nous illustrons la construction de cette matrice a
travers l'exemple suivant.
RNTI - E -
Auto{administration des entrepo^ts de donnees complexes
Soit un entrepo^t de donnees compose de la table de faits Sales et de cinq
tables dimensions Channels, Customers, Products, Times et Promotions. La Figure 4
represente un extrait d'une charge compose de trois reque^tes.
(1) select sales.time id, sum(quantity sold), sum (amount sold)
from sales, times
where sales.time id = times.time id
and times.scal year = `2000'
group by sales.time id;
(2) select sales.prod id, avg(amount sold)
from sales, products, promotions
where sales.prod id = products.prod id
and sales.promo id = promotions.promo id
and promotions.promo category = `newspaper'
group by sales.prod id;
(3) select sales.cust id, avg(amount sold)
from sales, customers, products, times
where sales.cust id = customers.cust id
and sales.prod id = products.prod id
and sales.time id = times.time id
and times.scal year = `2000'
and customers.cust marital status =`single'
and products.prod category =`Women'
group by sales.cust id;
. . .
Fig. 4 { Extrait d'une charge
La matrice \reque^tes-attributs" obtenue apres l'analyse syntaxique de la charge
est composee de dix colonnes et trois lignes (Figure 5). Elle est subdivisee suivant les
tables utilisees dans la charge pour des raisons de clarte et de lisibilite. Cette matrice
exploitee par l'algorithme Close donne lieu a un ensemble de motifs frequents fermes.
Nous detaillons dans la Section 5.1, apres la presentation des modeles de cou^t, comment
sont generes les index bitmap de jointure candidats a partir de ces motifs.
4 Modeles de cou^t
Generalement, le nombre d'index candidats est d'autant plus important que la
charge en entree est volumineuse. La creation de tous ces index peut ne pas e^tre
realisable en pratique (nombre d'index par table limite dans le SGBD utilise ou espace
de stockage alloue aux index restreint). Pour pallier ces limitations, nous proposons
des modeles de cou^t permettant de ne conserver que les index les plus avantageux. Ces
modeles estiment l'espace en octets occupe par les index bitmap de jointure, les cou^ts
d'acces aux donnees a travers ces index et de maintenance de ces index en terme de
RNTI - E -
Kamel Aouiche et al.
Customers Promotions Products
cust id marital status promo id promo category prod id prod category
(1) 0 0 0 0 0 0
(2) 0 0 1 1 1 0
(3) 1 1 0 0 1 1
Sales Times
pod id cust id promo id time id time id scal year
(1) 0 0 0 1 1 1
(2) 1 0 1 0 0 0
(3) 1 1 0 1 1 1
Fig. 5 { Matrice reque^tes-attributs
nombre d'entrees/sorties. Le Tableau 1 resume les notations adoptees dans l'elaboration
des modeles.
Symbole Description
j X j Nombre de n-uplets de la table X ou cardinalite de l'attribut X
Sp Taille en octets d'une page disque
pX Nombre de pages necessaires pour stocker la table X
Spointeur Taille en octets du pointeur d'une page
m Ordre d'un b-arbre
d Nombre de bitmaps utilises pour evaluer une reque^te donnee
w(X) Taille en octets d'un n-uplet de la table X ou de l'attribut X
Tab. 1 { Parametres des modeles de cou^t
4.1 Taille d'un index bitmap de jointure
L'espace requis pour stocker un index bitmap simple depend lineairement de la
cardinalite de l'attribut indexe et du nombre de n-uplets de la table a laquelle il ap-
partient. L'espace de stockage d'un index bitmap construit sur un attribut A de cardi-
nalite jAj appartenant a une table T composee de jT j n-uplets est egal a jAjjT j8 octets
[Wu et Buchmann, 1998] [Wu, 1999].
Les index bitmap de jointure sont construits sur des attributs de tables dimensions
et chaque bitmap contient autant de bits que de n-uplets de la table de faits F . La
taille de l'espace de stockage requis est donc S = jAjjF j8 octets.
Le temps de construction d'un index bitmap depend a la fois de la cardinalite de
l'attribut sur lequel il est construit et le nombre de n-uplets de la table. La complexite
est donc en O(jAjjF j) [Wu, 1999].
RNTI - E -
Auto{administration des entrepo^ts de donnees complexes
4.2 Cou^t de maintenance d'un index bitmap de jointure
Les operations de mise a jour ont un impact direct sur la taille des index bitmap
de jointure, notamment lorsque leur nombre est eleve. Ces operations peuvent e^tre
realisees au niveau de la table de faits ou de la table de dimension. La variation de la
taille et les cou^ts de ces operations sont presentes dans les sections suivantes.
4.2.1 Variation de la taille d'un index bitmap de jointure
Les mises a jour des donnees entra^nent systematiquement celles des index. Cela
peut engendrer des variations dans l'espace de stockage. Une mise a jour peut e^tre
avec ou sans expansion du domaine de l'attribut indexe. On parle d'expansion quand
la mise a jour provoque l'ajout d'une nouvelle valeur au domaine de cet attribut.
Dans le cas contraire, la mise a jour est sans expansion. Par exemple, si le domaine de
l'attribut Type de la table Products est fA;B;Cg alors la commande SQL Insert Into
Products (Type) Values (`K') provoque l'expansion du domaine de cet attribut.
{ Mise a jour sans expansion : Dans ce cas, un nouveau bit correspondant au
n-uplet insere est ajoute a chaque bitmap deja cree. La valeur du bit insere est a
1 dans le bitmap correspondant a la valeur inseree et elle est a 0 dans les bitmaps
restants. La variation de l'espace de stockage est
S =
jAj(jF j+ 1)
8
 
jAjjF j
8
=
jAj
8
et la complexite est en O(jAj) [Wu et Buchmann, 1998].
{ Mise a jour avec expansion : Le domaine de l'attribut indexe est etendu avec
la nouvelle valeur inseree. Un nouveau bitmap correspondant a cette valeur est
alors cree. La variation de l'espace de stockage est
S =
(jAj+ 1)(jF j+ 1)
8
 
jAjjF j
8
=
jAj
8
+
jF j+ 1
8
et la complexite est en O(jAj) +O(jF j) [Wu et Buchmann, 1998].
4.2.2 Cou^t d'insertion dans la table de faits
Soit un index bitmap de jointure construit sur l'attribut A de la table dimension T .
Lors d'une insertion dans la table de faits, il faut tout d'abord trouver le n-uplet de la
table T pouvant e^tre joint avec celui insere dans la table de faits F . Au pire, toute la
table T est parcourue (pT pages sont lues). Il faut ensuite mettre a jour les bitmaps de
l'index. Au pire, tous les bitmaps sont parcourus : jAjjF j8Sp pages sont lues, ou Sp denote
la taille d'une page disque. Le cou^t de maintenance de l'index bitmap de jointure est
donc
Cmaintenance = pT +
jAjjF j
8Sp
:
RNTI - E -
Kamel Aouiche et al.
4.2.3 Cou^t d'insertion dans les tables dimensions
Une insertion dans la table de dimension T peut provoquer ou non une expansion du
domaine de l'attribut indexe A. En cas de non expansion, la table de faits est parcourue
pour rechercher les n-uplets pouvant e^tre joints avec celui insere dans la table T . Ce
parcours necessite la lecture de pF pages. Il faut ensuite mettre a jour les bitmaps de
l'index avec un cou^t egal a jAjjF j8Sp . En cas d'expansion, il faut ajouter le cou^t de creation
du nouveau bitmap ( jF j8Sp pages). Le cou^t de maintenance est donc
Cmaintenance = pF + (1 + )
jAjjF j
8Sp
ou  est egal a 1 s'il y a une expansion et a 0 dans le cas contraire.
4.3 Cou^t d'acces aux donnees
Nous proposons deux modeles de cou^t pour estimer le nombre d'entrees/sorties
necessaires pour acceder aux donnees. Dans le premier modele, nous ne prenons au-
cune hypothese sur la facon dont sont implementes physiquement les index bitmap de
jointure. Dans le deuxieme modele, nous supposons que l'acces aux bitmaps de l'index
se fait a travers un b-arbre comme c'est le cas dans le SGBD Oracle, par exemple. Nous
detaillons chacun de ces modeles dans les sections suivantes.
4.3.1 Acces direct aux bitmaps
Deux phases sont necessaires pour evaluer une reque^te exploitant un index bitmap :
la phase de parcours des bitmaps de l'index et la phase de lecture des n-uplets de la
table indexee.
La phase de parcours des bitmaps de l'index correspond a toutes les operations
d'entrees/sorties necessaires pour rechercher les bitmaps permettant d'evaluer une
reque^te donnee. La phase de lecture des n-uplets de la table indexee inclut des
operations d'entrees/sorties additionnelles permettant de lire directement les donnees
a partir du disque. Nous supposons que les donnees sont uniformement distribuees.
Nombre d'entrees/sorties pour la phase de parcours des bitmaps
Au pire, tous les bitmaps doivent e^tre parcourus pour rechercher le bitmap
correspondant a une valeur de l'attribut indexe. Dans les SGBD, les operations
d'entrees/sorties portent sur une page de donnees pluto^t que sur un n-uplet. Cela
signie que lorsqu'un n-uplet d'une page est accede, toute cette page est lue. Si Sp
est la taille d'une page disque, alors le nombre de pages parcourues pour lire un seul
bitmap est jF j8Sp .
Le cou^t en terme d'entrees/sorties necessaires pour rechercher un seul bitmap est
jAjjF j
8Sp
. Si la lecture de d bitmaps est requise, alors le cou^t de la phase de parcours
des bitmaps de l'index est Cparcours = d
jAjjF j
8Sp
. La valeur de d est egale au nombre de
predicats appliques sur l'attribut indexe et lies par l'operateur Or ou la cardinalite de
RNTI - E -
Auto{administration des entrepo^ts de donnees complexes
la liste d'une clause In. Par exemple, la valeur de d de l'attribut indexe A est egale a
2 dans les deux clauses suivantes : A=5 Or A=10, A In (5,10).
Nombre d'entrees/sorties pour la phase de lecture des n-uplets
Pour un index bitmap construit sur l'attribut A, le nombre de n-uplets lus est egal
a jF jjAj (donnees uniformement distribuees).
De facon plus generale, le nombre total de n-uplets lus pour une reque^te utilisant
d bitmaps peut e^tre donne par Nr = d
jF j
jAj .
Etant donne le nombre de n-uplets lus,
deni par la formule precedente, le nombre d'entrees/sorties de la phase de lecture est
Clecture = pF (1   e
 NrpF ) [O'Neil et Quass, 1997], ou pF designe le nombre de pages
necessaires pour stocker la table de faits.
Nombre total d'entrees/sorties
Le nombre total d'entrees/sorties est la somme du nombre d'entrees/sorties calcule
dans la phase de parcours des bitmaps et celui de la phase de lecture des n-uplets :
Cindex = d
jAjjF j
8Sp
+ pF (1  e
 NrpF ):
Dans cette formule, nous constatons que le cou^t de la phase de parcours des bitmaps
(operations sur les index bitmaps) est eleve quand la cardinalite des attributs indexes
est grande. D'autre part, le cou^t de la phase de lecture diminue lorsque la cardinalite
augmente.
4.3.2 Acces aux bitmaps par b-arbre
Dans ce modele, nous supposons que l'acces aux index bitmaps est realise a
travers un b-arbre (metaindexation) dont les nuds feuilles pointent vers les bit-
maps (Figure 6). Le cou^t d'utilisation des index bitmap de jointure en terme
d'entrees/sorties pour evaluer une reque^te d'interrogation peut e^tre ecrit comme suit :
C = Cdescente + Cparcours + Clecture, ou Cdescente designe le cou^t de descente du
b-arbre de la racine jusqu'aux nuds feuilles, Cparcours denote le cou^t de parcours des
nuds feuilles an de trouver les cles de recherche correspondantes et le cou^t de lecture
des bitmaps associes, et enn Clecture donne le cou^t de lecture des n-uplets de la table
indexee.
Le cou^t de descente du b-arbre depend de sa hauteur. La hauteur d'un b-arbre
construit sur un attribut A est logmjAj, ou m designe l'ordre du b-arbre. Cet ordre est
egal a K + 1 ou K represente le nombre de cles de recherche dans chaque nud du b-
arbre. Le nombreK est egal a
Sp
w(A)+Spointeur
, ou w(A) et Spointeur sont, respectivement,
la taille en octets de l'attribut A et du pointeur d'une page. Si nous n'ajoutons pas le
niveau des nuds feuilles du b-arbre, alors le cou^t de descente du b-arbre est Cdescente =
logmjAj   1.
Le cou^t de parcours des nuds feuilles est jAjm 1 (au pire, tous les nuds feuilles
sont lus). L'acces aux donnees est realise via les bits mis a 1 de chaque bitmap. Dans
RNTI - E -
Kamel Aouiche et al.
       
    
    
             


	







	




	







	








 
Fig. 6 { Index bitmap de jointure indexe par un b-arbre
ce cas, il faut lire chaque bitmap. Le cou^t de lecture de d bitmaps est d jF j8Sp . Ainsi, le
cou^t de parcours des nuds feuilles est
Cparcours =
jAj
m  1
+ d
jF j
8Sp
:
Le cou^t de lecture des n-uplets de la table indexee est calcule de la me^me facon que
dans la phase de lecture des n-uplets du modele de cou^t de la Section 4.3.1.
En resume, le cou^t d'evaluation d'une reque^te exploitant un index bitmap de jointure
est
Cindex = logmjAj   1 +
jAj
m  1
+ d
jF j
8Sp
+ pF (1  e
 NrpF ):
4.4 Cou^t de jointure
Dans les cas ou les index bitmap de jointure ne sont pas utilises pour evaluer
une reque^te, nous supposons que les jointures sont realisees par hachage. Le
RNTI - E -
Auto{administration des entrepo^ts de donnees complexes
nombre d'entrees/sorties necessaires pour joindre les tables R et S est alors
Chachage = 3 (pS + pR) [Mishra et Eich, 1992].
5 Strategie de selection d'index bitmap de jointure
Notre strategie de selection d'index procede en plusieurs etapes. Dans un premier
temps, l'ensemble des index candidats est construit a partir de l'ensemble des motifs
frequents obtenus a partir de la charge (Section 3). Un algorithme glouton exploite
ensuite une fonction objectif basee sur les modeles de cou^t presentes a la Section 4 an
d'elaguer les index les moins avantageux. Le detail de ces etapes et de la construction
de la fonction objectif est donne dans les sections suivantes.
5.1 Construction de l'ensemble d'index candidats
A partir de l'ensemble de motifs frequents (Section 3) et du schema de l'entrepo^t
de donnees (cles etrangeres de la table de faits, cles primaires des tables dimensions,
etc.), nous construisons un ensemble d'index candidats.
L'instruction de construction d'un index bitmap de jointure est composee de trois
clauses : On, From et Where. La clause On est composee des attributs sur lesquels est
construit l'index (attributs non cles des tables dimensions), la clause From contient les
tables jointes et la clause Where est constituee des predicats de jointure. La Figure 7
montre un exemple d'une commande SQL permettant de construire un index bitmap
de jointure sur l'attribut FISCAL YEAR de la table de dimension TIMES (SALES est la
table de faits), sous Oracle 9i.
CREATE BITMAP INDEX BIJ TIMES
ON Sales (Times.Fiscal Year)
FROM Sales,Times
WHERE Sales.Time ID=Times.Time ID
Fig. 7 { Commande SQL de construction d'un index bitmap de jointure
Nous considerons un motif frequent < Table:attribut1;:::;T able:attributn > comme
etant une suite nie d'elements de la forme Table:attribut. Chaque motif frequent
est analyse pour determiner les dierentes clauses d'un index bitmap de jointure.
Tout d'abord, nous extrayons les elements contenant les cles etrangeres de la table
de faits. Les motifs ne contenant pas de tels elements ne donnent pas d'index bitmap
de jointure car ces elements sont necessaires pour denir les clauses From et Where
de l'index. Nous recherchons ensuite, dans le motif frequent, les elements contenant
les cles primaires des tables dimensions an de construire la clause Where. Les tables
trouvees au cours de cette analyse constituent la clause From. Les elements contenant
des attributs non cles des tables dimensions forment la clause On. Si de tels elements
n'existent pas, l'index bitmap de jointure ne peut pas e^tre construit car la clause On
est formee des attributs non cles des tables dimensions. Par exemple, le motif frequent
RNTI - E -
Kamel Aouiche et al.
<Times.Time id,Sales.Time id,Times.Fiscal Year> donne l'index bitmap de join-
ture BIJ TIMES dont la commande SQL est presentee dans la Figure 7.
5.2 Fonctions objectifs
Dans cette section, nous decrivons trois fonctions objectifs evaluant la reduction
ou l'augmentation du cou^t d'execution, en terme d'entrees/sorties, des reque^tes de la
charge lorsqu'un nouvel index est cree. Le cou^t d'execution d'une reque^te est assimile
au cou^t de calcul des jointures par hachage si aucun index bitmap de jointure n'est
exploite, ou au cou^t d'acces aux donnees a travers cet index dans le cas contraire. Le
cou^t d'execution des reque^tes de la charge est la somme de tous les cou^ts d'execution
de ses reque^tes.
La premiere fonction objectif privilegie les index apportant le plus de prot lors de
l'execution des reque^tes, la deuxieme fonction privilegie les index apportant le plus de
prot tout en occupant le moins d'espace de stockage et la troisieme fonction combine
les deux premieres an de selectionner dans un premier temps les index apportant
le plus de prot et de ne conserver dans un deuxieme temps que ceux qui occupent
le moins d'espace de stockage lorsque celui-ci devient faible. La premiere fonction est
utilisable quand l'espace de stockage n'est pas limite, la deuxieme fonction est utile
quand l'espace de stockage est faible et la troisieme est interessante quand cet espace
est moyennement grand. Nous detaillons dans la suite chacune de ces fonctions.
5.2.1 Fonction objectif prot
Soient I = fi1;:::;ing un ensemble d'index bitmap de jointure candidats,
Q = fq1;:::;qmg un ensemble de reque^tes (la charge) et S l'ensemble d'index nal
a creer.
La fonction objectif prot, notee P , est denie comme suit :
P=S(ij) = 
 
C=S(Q)  C=S[fijg(Q)   Cmaintenance(fijg)

; ij =2 S:
{ Le coecient  estime le rapport entre le cou^t des jointures evitees gra^ce a l'index
ij lors de l'execution des reque^tes de la charge exploitant cet index et le cou^t total
des jointures de toutes les reque^tes de cette charge. Plus la valeur de  est grande,
meilleur est l'index. En eet, un index evitant le calcul d'un plus grand nombre
de jointures est le plus avantageux. Le coecient  est calcule comme suit :
 = jQj support(ij)
hachage(tables(ij))PjQj
i=1 hachage(tables(qi))
ou jQj, support(ij), hachage(tables(ij)) et
PjQj
i=1 hachage(tables(qi)) sont res-
pectivement le nombre de reque^tes de la charge, le support du motif frequent
generateur de l'index ij , le cou^t de jointure par hachage des tables pre-jointes
dans ij et le cou^t total des jointures par hachage des tables jointes dans les
reque^tes de la charge.
RNTI - E -
Auto{administration des entrepo^ts de donnees complexes
{ C=S(Q) represente le cou^t d'execution des reque^tes de la charge lorsque l'en-
semble d'index S est utilise. Si cet ensemble est vide, C=;(Q) est egal a la somme
des cou^ts de calcul des jointures par hachage des tables de chaque de reque^te.
Lorsqu'un index ij est ajoute a S, C=S[fijg(Q) =
PjQj
k=0 C(qk ;fijg) represente le
cou^t d'execution des reque^tes de la charge en considerant les index de l'ensemble
S [fijg. Si la reque^te qk exploite l'index ij alors le cou^t C(qk ;fijg) est egal a Cij
(cou^t d'acces aux donnees a travers cet index). Dans le cas contraire, C(qk ;fijg)
est egal a la valeur minimum entre Chachage (cou^t de calcul des jointures par
hachage des tables jointes par la reque^te qk) et les valeurs de C(qk;fig) (cou^ts
d'execution des reque^tes qk exploitant i 2 S avec i 6= ij).
{ Le coecient  = jQj p(ij) permet d'estimer le nombre de mises a jour de l'index
ij est lors du rafra^chissement de l'entrepo^t de donnees. La probabilite de mise a
jour p(ij) de l'index ij est egale a
1
nombre d0index
%rafraichissement
%interrogation
ou le rapport %rafraichissement%interrogation represente la proportion de mises a jour de l'en-
trepo^t de donnees par rapport aux interrogations.
{ Cmaintenance(fijg) represente le cou^t de maintenance de l'index ij .
5.2.2 Fonction objectif ratio prot/espace
Si la selection d'index est realisee sous la contrainte de l'espace de stockage alloue
aux index, la fonction objectif ratio prot/espace R=S(ij) =
P=S(ij)
taille(ij )
est utilisee. Cette
fonction calcule le prot apporte par l'index ij par rapport a l'espace de stockage
taille(ij) qu'il occupe. La fonction ratio prot/espace privilegie les index accelerant le
mieux l'acces aux donnees, tout en occupant le moins d'espace possible.
5.2.3 Fonction objectif hybride
La contrainte sur l'espace de stockage peut e^tre relaxee si l'espace alloue aux index
est relativement eleve. La fonction objectif hybride H ne penalise les index \gour-
mands" en espace que si le rapport espace restantespace stockage est superieur a un seuil  donne
(0 <   1), ou espace restant et espace stockage sont respectivement l'espace res-
tant apres l'inclusion de l'index ij et l'espace reserve pour stocker tous les index. Cette
fonction est calculee en combinant les fonctions P et R comme suit :
H=S(ij) =

P=S(ij) si
espace restant
espace stockage > ,
R=S(ij) sinon.
L'intere^t de cette fonction est de prendre dans un premier temps les index ameliorant
le plus le temps d'execution des reque^tes, sans prendre en compte la contrainte sur
l'espace de stockage. Lorsque le rapport entre l'espace restant et l'espace de stockage
atteint le seuil critique indique par la valeur de , on penalise les index occupant
beaucoup d'espace disque. Cela est interessant lorsque l'administrateur dispose d'un
RNTI - E -
Kamel Aouiche et al.
espace moyennement grand pour stocker les index et qu'il ait plusieurs index apportant
une amelioration importante au temps d'execution des reque^tes et occupant beaucoup
d'espace.
5.3 Construction de la conguration d'index
L'algorithme de selection d'index (Algorithme 1) se base sur une recherche glou-
tonne dans l'ensemble des index candidats I donne en entree. La fonction objectif F
doit e^tre l'une des fonctions P , R ouH decrites dans la section precedente. Si la fonction
R est utilisee, nous ajoutons en entree de l'algorithme la taille de l'espace de stockage
M reserve aux index. Si la fonction H est utilisee, nous y ajoutons le parametre .
A la premiere iteration de l'algorithme, les valeurs de la fonction objectif sont
calculees pour chaque index de l'ensemble I . Le cou^t d'execution des reque^tes de la
charge Q (premier terme de la fonction F ) est egal au cou^t total de calcul des jointures
par hachage des tables jointes dans chaque reque^te. L'index imax maximisant la fonction
objectif, s'il existe (F=S(imax) > 0), est ensuite ajoute a l'ensemble S. Si l'une des
fonctions R ou H est utilisee, l'espace de stockage M est diminue de l'espace occupe
par imax.
Les valeurs de la fonction objectif F sont ensuite recalculees pour chaque index
restant dans I   S puisqu'elles dependent de l'ensemble d'index selectionnes S. Cela
permet de prendre en compte les interactions qui peuvent exister entre les index.
Algorithme 1 Construction de la conguration d'index
S  ;
repeter
imax  ;
Fmax  0
pour tout ij 2 I   S faire
si F=S(ij) > Fmax alors
Fmax  F=S(ij)
imax  ij
n si
n pour
si F=S(imax) > 0 alors
S  S [ fimaxg
n si
jusqu'a (F=S(imax)  0 ou I   S = ;)
Ces iterations sont repetees jusqu'a ce qu'il n'y ait plus d'amelioration de la fonction
objectif (F=S(i)  0) ou que tous les index soient selectionnes (I   S = ;). Si la
fonction R ou H est utilisee, l'algorithme s'arre^te egalement quand l'espace de stockage
disponible est sature.
RNTI - E -
Auto{administration des entrepo^ts de donnees complexes
6 Experimentations
An de valider notre strategie de selection d'index bitmap de jointure, nous l'avons
appliquee sur un entrepo^t de donnees test implante au sein du SGBD Oracle 9i installe
sur un PC sous Windows XP Pro dote d'un processeur Pentium 4 a 2.4 GHz, d'une
memoire centrale de 512 Mo et d'un disque dur IDE de 120 Go. Cet entrepo^t de
donnees est compose d'une table de faits Sales et de cinq tables dimensions Customers,
Products, Promotions, Times et Channels. Le Tableau 2 detaille le nombre de n-uplets
et la taille en Mo de chaque table de cet entrepo^t. Nous avons mesure pour dierentes
valeurs du support minimal de l'algorithme Close le temps d'execution des reque^tes de
la charge. En pratique, ce parametre permet de limiter le nombre d'index candidats
a generer en ne selectionnant que ceux qui sont les plus frequemment sollicites par la
charge. Notons que dans ces experimentations, nous nous basons volontairement sur des
donnees classiques, an d'assurer une bonne comprehension de la demarche que nous
presentons. Cette derniere reste neanmoins valable dans le cas des donnees complexes.
Table Nombre de n-uplets Taille (Mo)
Sales 16 260 336 372;17
Customers 50 000 6;67
Products 10 000 2;28
Times 1 461 0;20
Promotions 501 0;04
Channels 5 0;0001
Tab. 2 { Caracteristiques de l'entrepo^t de donnees test
Pour calculer les dierents cou^ts, nous avons xe respectivement les valeurs des
parametres Sp (taille d'une page disque) et de Spointeur (taille du pointeur d'une page)
a 8 Ko et 4 Ko. Ces valeurs sont celles indiquees dans le chier de conguration d'Oracle.
Nous n'avons applique dans ces experimentations que le modele d'acces aux bitmap
par b-arbre (Section 4.3.2) car c'est la methode utilisee dans Oracle 9i. La charge
est composee de quarante reque^tes decisionnelles comportant plusieurs jointures. Nous
avons mesure le temps total d'execution des reque^tes de cette charge selon que l'on ait
construit ou pas les index et selon que l'on ait applique ou pas les modeles de cou^t
exploites par les trois fonctions objectifs : prot, ratio prot/espace et hybride. Nous
avons egalement mesure l'espace disque occupe par les index.
6.1 Experimentations avec la fonction prot
La Figure 8 montre que les index selectionnes ameliorent le temps d'execution des
reque^tes de la charge avec ou sans application des modeles de cou^t jusqu'a ce que le
support minimal depasse 47,5%. De plus, ce temps se degrade de maniere continue au
fur et a mesure que le support minimal augmente. Cela est du^ au fait que le nombre
d'index diminue quand le support minimal augmente. Pour les grandes valeurs du
support (plus de 47,5%), le temps d'execution est proche de celui obtenu sans index.
RNTI - E -
Kamel Aouiche et al.
680,00
730,00
780,00
830,00
880,00
930,00
980,00
1030,00
1,0
%
5,0
%
10
,0%
15
,0%
17
,5%
20
,0%
25
,0%
40
,0%
45
,0%
>=
 
47
,5%
Support minimal
Te
m
ps
 
d'e
x
√©c
u
tio
n
 
(en
 
se
co
n
de
s
)
Sans index Avec index et sans mod√®le de co√ªt
Avec index et avec mod√®le de co√ªt
Fig. 8 { Fonction prot
0
20
40
60
80
100
120
1,0
0%
5,0
0%
10
,00
%
15
,00
%
17
,50
%
20
,00
%
25
,00
%
40
,00
%
45
,00
%
> 
=
 
47
,5%
Support minimal
Ta
ille
 
de
s 
in
de
x
 
(en
 
M
o
)
Sans mod√®le de co√ªt Avec mod√®le de co√ªt
Fig. 9 { Espace de stockage des index
Ce cas est previsible, dans le sens ou, pour un support minimal tres grand, aucun index
ou tres peu d'index candidats sont generes.
Le gain maximal en temps total d'execution de la charge dans les deux cas est
respectivement de 30,50% et de 31,85%. Malgre une legere baisse de 1,32% du gain en
temps d'execution lorsque les modeles de cou^t sont utilises (nombre plus reduit d'index
construits), nous constatons en contre partie un gain signicatif en terme d'espace de
stockage (egal a 32,79% dans le cas le plus favorable) comme le montre la Figure 9. La
reduction du nombre d'index est interessante lorsque la frequence de rafra^chissement
de l'entrepo^t de donnees est elevee car le cou^t de rafra^chissement est proportionnel
au nombre d'index construits. D'autre part, le gain en espace de stockage permet a
l'administrateur de limiter l'espace disque alloue aux index.
6.2 Experimentations avec la fonction ratio prot/espace
Dans ces experimentations, nous avons xe la valeur du support minimal a 1%.
Cette valeur donne le plus grand nombre de motifs frequents et, par consequent, le plus
grand nombre d'index bitmap de jointure candidats. Cela permet de faire varier l'espace
de stockage dans un plus grand intervalle. Nous avons mesure le temps d'execution
des reque^tes en fonction du pourcentage de l'espace de stockage alloue aux index. Ce
pourcentage est calcule par rapport a l'espace total occupe par tous les index.
La Figure 10 montre que le temps d'execution diminue quand l'occupation de l'es-
pace de stockage augmente. Cela est previsible, dans le sens ou, on peut creer un plus
grand nombre d'index et donc ameliorer davantage le temps d'execution. Nous consta-
tons aussi que le gain maximal en temps d'execution egal a 28,95% est atteint pour
une occupation de l'espace de stockage de 59,64%. Cela signie qu'en xant l'espace
de stockage a cette valeur et en appliquant la fonction objectif ratio prot/espace,
nous obtenons des gains en temps d'execution proches de ceux obtenus en appliquant
la fonction objectif prot (30,50%). Ce cas est interessant quand l'administrateur ne
dispose pas de beaucoup d'espace pour stocker les index.
RNTI - E -
Auto{administration des entrepo^ts de donnees complexes
6.3 Experimentations avec la fonction hybride
Nous avons reproduit les experimentations precedentes avec la fonction objectif
hybride. Nous avons fait varier les valeurs du parametre  entre 0,1 et 1 par pas de
0,1. Les resultats obtenus dans ces experimentations avec  allant de 0,1 a 0,7 et 
allant de 0,8 a 1 sont respectivement egaux a ceux obtenus avec  = 0;1 et  = 0;7.
Nous ne representons donc a la Figure 11 que les resultats obtenus avec  = 0;1 et
 = 0;8. Cette gure montre que pour  = 0;1, on se rapproche des resultats obtenus
en utilisant la fonction objectif ratio espace/prot, et pour  = 0;8, on se rapproche
des resultats obtenus en utilisant la fonction objectif prot. Le gain maximal en temps
d'execution est egal a 28,95% et 29,85% pour les valeurs 0,1 et 0,8 de .
Nous expliquons ces resultats par le fait que les index bitmap de jointure construits
sur plusieurs attributs necessitent un espace de stockage important. En revanche,
comme ils pre-calculent un plus grand nombre de jointures, ils ameliorent davantage
le temps d'execution de ces dernieres. L'espace alloue aux index se remplit donc tres
vite au bout de quelques iterations de l'algorithme glouton de selection d'index. Ceci
explique pourquoi le parametre  n'inue pas signicativement sur l'algorithme de
selection et donc sur les resultats de ces experimentations.
680
730
780
830
880
930
980
1030
0,0
0%
11
,93
%
23
,86
%
35
,79
%
47
,71
%
59
,64
%
71
,57
%
83
,50
%
95
,43
%
Pourcentage de l'espace de stockage occup√© par les index
Te
m
ps
 
d'e
x
√©c
u
tio
n
 
(en
 
s
ec
on
de
s
)
Sans index Avec index et mod√®le de co√ªt
Fig. 10 { Fonction ratio prot/espace
680
730
780
830
880
930
980
1030
0,0
0%
11
,93
%
23
,86
%
35
,79
%
47
,71
%
59
,64
%
71
,57
%
83
,50
%
95
,43
%
Pourcentage de l'espace de stockage occup√© par les index
Te
m
ps
 
d'
e
x√©
cu
tio
n
 
(en
 
se
co
n
de
s)
Sans index Avec index et mod√®le de co√ªt (   =0,1) 
Avec index et mod√®le de co√ªt (   =0,8) 
Fig. 11 { Fonction hybride
7 Conclusion et perspectives
Dans cet article, nous avons presente une strategie automatique de selection d'index
bitmap de jointure dans les entrepo^ts de donnees complexes. Cette strategie exploite
dans un premier temps les motifs frequents obtenus par l'algorithme Close a partir
d'une charge donnee an de generer un ensemble d'index bitmap de jointures can-
didats. Elle s'appuie, dans un deuxieme temps, sur des modeles de cou^t an de ne
conserver parmi ces candidats que ceux qui sont les plus avantageux. Ces modeles es-
timent le cou^t d'acces aux donnees a travers les index bitmap de jointure, ainsi que
RNTI - E -
Kamel Aouiche et al.
le cou^t de maintenance et de stockage de ces index. Nous avons egalement propose
trois fonctions objectifs prot, ratio prot/espace et hybride combinant les modeles
de cou^t an d'evaluer le cou^t d'execution des reque^tes exploitant ou non les index.
Ces fonctions sont exploitees par un algorithme glouton de selection d'index an de
recommander une conguration d'index pertinente. Cela permet a notre strategie de
s'adapter aux contraintes imposees par le systeme (nombre d'index limite par table)
ou par l'administrateur de l'entrepo^t de donnees (taille de l'espace de stockage alloue
aux index).
Nos resultats experimentaux montrent que l'application des modeles de cou^t a notre
strategie de selection d'index reduit le nombre d'index selectionnes sans degrader signi-
cativement les performances. Cette reduction garantit en revanche un gain substantiel
en terme d'espace de stockage alloue aux index, ainsi qu'une diminution des cou^ts de
maintenance de l'entrepo^t de donnees lors des rafra^chissements.
Notre travail montre que l'idee d'utiliser des techniques de fouille de donnees pour
l'auto-administration des entrepo^ts de donnees complexes est une approche promet-
teuse. Face a la volumetrie et a la complexite intrinseque des donnees traitees, il est
en eet devenu crucial de fournir des outils d'aide a l'administrateur de l'entrepo^t,
notamment en ce qui concerne l'optimisation des performances.
Ce travail ouvre par ailleurs plusieurs axes de recherche future. Dans un premier
temps, il para^t indispensable de continuer a tester notre strategie pour mieux evaluer
la surcharge qu'elle engendre pour le systeme, que ce soit en terme de generation des
index ou de leur maintenance. Il sera notamment necessaire de la confronter a notre
entrepo^t de donnees medicales complexes.
Il serait egalement tres interessant de comparer notre approche de maniere plus
systematique a d'autres demarches de selection d'index, que ce soit par des calculs
de complexite des heuristiques de generation de congurations d'index (surcharge)
ou des experimentations visant a evaluer la qualite de ces congurations (gain en
temps d'execution et surcharge due a la maintenance des index), notamment lorsque
les donnees indexees sont complexes.
Etendre ou coupler nos travaux a d'autres techniques d'optimisation de perfor-
mances (vues materialisees, gestion de cache, regroupement physique, etc.) consti-
tue egalement une voie de recherche prometteuse. En eet, dans le contexte des
entrepo^ts de donnees et a plus forte raison lorsque les donnees sont complexes,
c'est principalement en conjonction avec d'autres structures physiques (principale-
ment les vues materialisees) que l'indexation permet d'obtenir des gains de perfor-
mance signicatifs. Dans ce cadre, une classication eectuee sur le contexte d'ex-
traction permettrait de construire des groupes de reque^tes ayant de fortes simila-
rites. Chaque groupe de reque^tes pourrait alors e^tre un point de depart pour la
materialisation des vues. De plus, il serait interessant d'integrer des methodes per-
mettant de partager ecacement l'espace de stockage disponible entre les index et les
vues materialisees [Bellatreche et al., 2000].
Finalement, le travail que nous proposons ici exploite principalement des descrip-
teurs de donnees complexes pour l'indexation. Il n'est specique aux donnees complexes
qu'en raison des modications d'architecture de l'entrepo^t que nous avons introduites
pour stocker nos donnees medicales. Il serait sans doute interessant d'exploiter les
RNTI - E -
Auto{administration des entrepo^ts de donnees complexes
donnees complexes elles-me^me, par exemple en prenant en compte des descripteurs de
bas niveaux, comme la couleur ou la texture pour des images. L'application de tech-
niques de fouille permettant de determiner quelles donnees sont les plus susceptibles
d'e^tre utilisees conjointement pourrait aussi permettre de produire un regroupement
physique de ces donnees sur disque.
Summary
The queries dened on data warehouses are often intricate and use several join ope-
rations that induce an expensive computational cost. In the eld of complex data
warehousing, adaptations from the classical data warehouse schemas induce additional
joins at data access time. This cost becomes even more prohibitive when queries access
very large volumes of data. It is thus crucial to reduce data access costs. To improve
response time, data warehouse administrators generally use indexing techniques such as
star join indices or bitmap join indices. This is nevertheless still complex and fastidious.
The solution we propose lies in the eld of data warehouse auto-administration.
In this framework, we propose an automatic index selection strategy. To release this
selection, we turn to a data mining technique; more precisely frequent itemset mining,
in order to determine a set of candidate indices from a given workload. Then, we
propose several cost models that help creating an index conguration composed by
the indices providing the best prot. These models particularly evaluate the cost of
accessing data using bitmap join indices, and the cost of updating and storing these
indices.
Keywords: Data warehouses, complex data, auto-administration, index selection,
frequent itemset, cost models, bitmap join indexes.
References
[Agrawal et al., 2000] S. Agrawal, S. Chaudhuri, et V.R. Narasayya. Automated se-
lection of materialized views and indexes in SQL databases. In 26th International
Conference on Very Large Data Bases (VLDB 2000), Cairo, Egypt, pages 496{505,
2000.
[Agrawal et al., 2001] S. Agrawal, S. Chaudhuri, et V.R. Narasayya. Materialized view
and index selection tool for Microsoft SQL Server 2000. In ACM SIGMOD Interna-
tional Conference on Management of Data (SIGMOD 2001), Santa Barbara, USA,
page 608, 2001.
[Aouiche et al., 2003a] K. Aouiche, J. Darmont, et L. Gruenwald. Frequent itemsets
mining for database auto-administration. In 7th International Database Engineering
and Application Symposium (IDEAS 2003), Hong Kong, China, pages 98{103, 2003.
[Aouiche et al., 2003b] K. Aouiche, J. Darmont, et L. Gruenwald. Vers l'auto{
administration des entrepo^ts de donnees. Revue des Nouvelles Technologies de l'In-
formation, (1):1{12, 2003.
[Aouiche et al., 2004] K. Aouiche, J. Darmont, et O. Boussaid. Selection automatique
d'index dans les entrepo^ts de donnees. In 1er atelier Fouille de Donnees Complexes
RNTI - E -
Kamel Aouiche et al.
dans un processus d'extraction des connaissances (EGC 2004), Clermont-Ferrand,
France, pages 91{102, 2004.
[Bellatreche et al., 2000] L. Bellatreche, K. Karlapalem, et M. Schneider. On ecient
storage space distribution among materialized views and indices in data warehou-
sing environments. In 9th International Conference on Information and Knowledge
Management (CIKM 2000), McLean, USA, pages 397{404, 2000.
[Bizarro et Madeira, 2001] P. Bizarro et H. Madeira. The dimension-join: A new index
for data warehouses. In 16th Simposio Brasileiro de Banco de Dados (SBDD 2001),
Rio de Janeiro, Brazil, pages 259{273, 2001.
[Brick, 1997] R. Brick. Star schema processing for complex queries. White paper, 1997.
[Chaudhuri et Narasayya, 1998] S. Chaudhuri et V.R. Narasayya. Autoadmin `what-if'
index analysis utility. In ACM SIGMOD International Conference on Management
of Data, Seattle, USA, pages 367{378, 1998.
[Feldman et Reouven, 2003] Y.A. Feldman et J. Reouven. A knowledge{based ap-
proach for index selection in relational databases. Expert System with Applications,
25(1):15{37, 2003.
[Finkelstein et al., 1988] S.J. Finkelstein, M. Schkolnick, et P. Tiberio. Physical da-
tabase design for relational databases. ACM Transactions on Database Systems,
13(1):91{128, 1988.
[Frank et al., 1992] M.R. Frank, E. Omiecinski, et S.B. Navathe. Adaptive and auto-
mated index selection in RDBMS. In 3rd International Conference on Extending
Database Technology (EDBT 1992), Vienna, Austria, volume 580 of Lecture Notes
in Computer Science, pages 277{292, 1992.
[Golfarelli et al., 2002] M. Golfarelli, S. Rizzi, et E. Saltarelli. Index selection for data
warehousing. In 4th International Workshop on Design and Management of Data
Warehouses (DMDW 2002), Toronto, Canada, pages 33{42, 2002.
[Gupta et al., 1997] H. Gupta, V. Harinarayan, A. Rajaraman, et J. D. Ullman. Index
selection for OLAP. In 13th International Conference on Data Engineering (ICDE
1997), Birmingham, U.K., pages 208{219, 1997.
[Hu et al., 2003] X. Hu, T.Y. Lin, et E. Louie. Bitmap techniques for optimizing deci-
sion support queries and association rule algorithms. In 7th International Database
Engineering and Application Symposium (IDEAS 2003), Hong Kong, China, pages
34{43, 2003.
[Inmon, 2002] W.H. Inmon. Building the Data Warehouse. John Wiley & Sons, third
edition, 2002.
[Kimball et Ross, 2002] R. Kimball et M. Ross. The Data Warehouse Toolkit: The
Complete Guide to Dimensional Modeling. John Wiley & Sons, second edition, 2002.
[Kratica et al., 2003] J. Kratica, I. Ljubic, et D. Tosic. A genetic algorithm for the
index selection problem. In Applications of Evolutionary Computing, Essex, England,
volume 2611 of LNCS, pages 281{291, 2003.
[Labio et al., 1997] W. Labio, D. Quass, et B. Adelberg. Physical database design
for data warehouses. In 13th International Conference on Data Engineering (ICDE
1997), Birmingham, U.K., pages 277{288, 1997.
RNTI - E -
Auto{administration des entrepo^ts de donnees complexes
[Mishra et Eich, 1992] P. Mishra et M. Eich. Join processing in relational databases.
ACM Computing Surveys, 24(1):63{113, 1992.
[O'Neil et Graefe, 1995] P.E. O'Neil et G. Graefe. Multi{table joins through bitmap-
ped join indices. SIGMOD Record, 24(3):8{11, 1995.
[O'Neil et Quass, 1997] P.E. O'Neil et D. Quass. Improved query performance with
variant indexes. In ACM SIGMOD International Conference on Management of
Data (SIGMOD 1997), Tucson, USA, pages 38{49, 1997.
[Pasquier et al., 1999] N. Pasquier, Y. Bastide, R. Taouil, et L. Lakhal. Discovering
frequent closed itemsets for association rules. In 7th International Conference on
Database Theory (ICDT 1999), Jerusalem, Israel, volume 1540 of LNCS, pages 398{
416, 1999.
[Sarawagi, 1997] S. Sarawagi. Indexing OLAP data. Data Engineering Bulletin,
20(1):36{43, 1997.
[Valduriez, 1987] P. Valduriez. Join indices. ACM Transactions on Database Systems,
12(2):218{246, 1987.
[Valentin et al., 2000] G. Valentin, M. Zuliani, D. Zilio, G. Lohman, et A. Skelley.
DB2 advisor: An optimizer smart enough to recommend its own indexes. In 16th
International Conference on Data Engineering (ICDE 2000), San Diego, USA, pages
101{110, 2000.
[Vanachayobon et Gruenwald, 1999] S. Vanachayobon et L. Gruenwald. Indexing tech-
niques for data warehouses' queries. Technical report, The University of Oklahoma,
School of Computer Science, 1999.
[Weikum et al., 2002] G. Weikum, A. Monkeberg, C. Hasse, et P. Zabback. Self-tuning
database technology and information services: from wishful thinking to viable engi-
neering. In 28th International Conference on Very Large Data Bases (VLDB 2002),
Hong Kong, China, pages 20{31, 2002.
[Wu et Buchmann, 1998] M.C. Wu et A.P. Buchmann. Encoded bitmap indexing for
data warehouses. In 14th International Conference on Data Engineering (ICDE
1998), Orlando, USA, pages 220{230, 1998.
[Wu, 1999] M.C. Wu. Query optimization for selections using bitmaps. In ACM SIG-
MOD International Conference on Management of Data (SIGMOD 1999), Philadel-
phia, USA, pages 227{238, 1999.
RNTI - E -
