Fragmentation Primaire et DÃ©rivÃ©e: Ã‰tude de ComplexitÃ©,
Algorithmes de SÃ©lection et Validation sous ORACLE10g
Kamel Boukhalfa âˆ—, Ladjel Bellatrecheâˆ— Pascal Richard âˆ—
âˆ— LISI/ENSMA - UniversitÃ© de Poitiers
Futuroscope 86960 France
(boukhalk, bellatreche, richardp)@ensma.fr
RÃ©sumÃ©. La fragmentation horizontale a Ã©tÃ© largement adoptÃ©e par la commu-
nautÃ© des bases de donnÃ©es. Elle a une place Ã  part entiÃ¨re dans la conception
physique. Plusieurs systÃ¨mes de gestion de bases de donnÃ©es (SGBD) commer-
ciaux ont proposÃ© un langage de dÃ©finition de donnÃ©es pour partitionner des
tables relationnelles en utilisant diffÃ©rents modes. Dans ce papier, nous prÃ©sen-
tons dâ€™abord lâ€™Ã©volution de la fragmentation ces derniÃ¨res annÃ©es au sein des
SGBDs. DeuxiÃ¨mement, nous Ã©tudions le problÃ¨me de sÃ©lection de schÃ©ma de
fragmentation dâ€™un entrepÃ´t de donnÃ©es relationnel, et nous montrons quâ€™il est
NP-complet. Vu sa complexitÃ©, nous dÃ©veloppons un algorithme de hill climbing
(mÃ©thode de voisinage) pour sÃ©lectionner un schÃ©ma de fragmentation quasi op-
timal. Nous effectuons des expÃ©rimentations afin de comparer cet algorithme
avec deux autres algorithmes: un gÃ©nÃ©tique et un recuit simulÃ© en utilisant un
modÃ¨le de coÃ»t mathÃ©matique. Finalement, nous effectuons une validation rÃ©elle
de nos algorithmes sous ORACLE10g en utilisant les donnÃ©es issues du banc
dâ€™essai APB1.
1 Introduction
Les entrepÃ´ts de donnÃ©es sont connus par leur volumÃ©trie et requÃªtes complexes caractÃ©-
risÃ©es par des jointures, sÃ©lections et agrÃ©gations. Pour optimiser ces opÃ©rations et faciliter la
gestion de ces donnÃ©es, la fragmentation horizontale est devenue un candidat sÃ©rieux (Papa-
domanolakis et Ailamaki, 2004; Sanjay et al., 2004). Elle permet de partitionner les tables, les
vues matÃ©rialisÃ©es ou les index en plusieurs ensembles disjoints de tuples stockÃ©s physique-
ment et gÃ©nÃ©ralement accÃ©dÃ©s sÃ©parÃ©ment. Une caractÃ©ristique intÃ©ressante liÃ©e Ã  la fragmen-
tation horizontale est le fait quâ€™elle ne duplique pas les donnÃ©es, et par consÃ©quent, elle rÃ©duit
les coÃ»ts de stockage et de maintenance.
Deux versions de la fragmentation horizontale ont Ã©tÃ© dÃ©finies (Ã–zsu et Valduriez, 1999) :
primaire et dÃ©rivÃ©e. La fragmentation horizontale primaire dâ€™une relation est effectuÃ©e en uti-
lisant les attributs dÃ©finis sur cette table. La fragmentation horizontale dÃ©rivÃ©e consiste Ã  par-
titionner une table en utilisant les attributs dÃ©finis sur une ou plusieurs autres(s) table(s). En
dâ€™autres termes, la fragmentation horizontale dÃ©rivÃ©e dâ€™une table est basÃ©e sur le schÃ©ma de
Fragmentation: ComplexitÃ©, Algorithmes de SÃ©lection et Validation sous ORACLE10g
fragmentation des autres tables 1. La fragmentation horizontale dÃ©rivÃ©e dâ€™une table R en fonc-
tion du schÃ©ma de fragmentation de S est possible si, et seulement si, il existe un lien de
jointure entreR et S (R contient une clÃ© Ã©trangÃ¨re de S). A partir de ces deux dÃ©finitions, nous
constatons que la fragmentation primaire pourrait accÃ©lÃ©rer les opÃ©rations de sÃ©lection tandis
que la fragmentation dÃ©rivÃ©e les opÃ©rations de jointure.
Cette optimisation est assurÃ©e par le mÃ©canisme dâ€™Ã©limination de partitions non perti-
nentes : si une requÃªte contient un attribut de partition dans la clause WHERE, lâ€™optimiseur
dirige automatiquement la requÃªte vers les partitions valides : si nous fragmentons une table
CLIENT en utilisant lâ€™attribut SEXE et si une requÃªte possÃ¨de une condition sur cet attribut,
lâ€™optimiseur ne charge que la partition pertinente.
Le partitionnement de donnÃ©es a Ã©tÃ© largement Ã©tudiÃ© dans les bases de donnÃ©es tradition-
nelles (Bellatreche et al., 2000) et les bases de donnÃ©es distribuÃ©es et parallÃ¨les (Navathe et al.,
1995; Ã–zsu et Valduriez, 1999). RÃ©cemment, plusieurs travaux commerciaux et acadÃ©miques
ont montrÃ© lâ€™intÃ©rÃªt de la fragmentation horizontale (Sanjay et al., 2004; Papadomanolakis et
Ailamaki, 2004; Corp., 2007). Plusieurs SGBDs commerciaux ont proposÃ© des langages de dÃ©-
finitions de donnÃ©es pour supporter la fragmentation. Pour Ã©tudier cette Ã©volution, nous nous
concentrons sur le SGBD ORACLE qui offre plusieurs modes de partitionnement.
Le premier mode de partitionnement supportÃ© par Oracle a Ã©tÃ© le partitionnement par in-
tervalle (Range) dans Oracle8i. Il est dÃ©fini par un tuple (c, V ), oÃ¹ c est un type de colonne et
V une sÃ©quence ordonnÃ©e de valeurs dans le domaine de c. Oracle9 et 9i ont ajoutÃ© dâ€™autres
modes de fragmentation qui sont : le partitionnement par hachage (Hash) le partitionnement
par liste (List) et le partitionnement composÃ© (Range-Hash et Range-List). Le partitionnement
par hachage dÃ©compose la table selon une fonction de hachage (fournie par le systÃ¨me) ap-
pliquÃ©e sur les valeurs des attributs de fragmentation. Le partitionnement par liste, dÃ©compose
une table selon les listes de valeurs dâ€™une colonne. Le partitionnement composÃ© est utilisÃ© Ã 
lâ€™aide des instructions PARTITION-SUBPARTITION 2. Les partitionnements Range, List et
Hash sont des modes de base supportÃ©s par la plupart des SGBDs commerciaux.
RÃ©cemment, Oracle 11g a fait Ã©voluer la fragmentation horizontale en proposant plusieurs
modes : (1) Partitionnement par une colonne virtuelle (virtual column partitioning) dans le-
quel, une table est fragmentÃ©e en utilisant un attribut virtuel, qui est dÃ©fini par une expression
utilisant un ou plusieurs attributs. Cette colonne est stockÃ©e seulement dans les mÃ©ta-donnÃ©es.
(2) Le partitionnement par rÃ©fÃ©rence (referential partitioning) : qui permet de fragmenter une
table en utilisant une autre table (Ã  condition quâ€™il y ait une relation de type pÃ¨re-fils entre
les deux tables (Corp., 2007)). Ce partitionnement est similaire Ã  la fragmentation dÃ©rivÃ©e,
mais son inconvÃ©nient majeur est quâ€™une table est fragmentÃ©e en fonction dâ€™une seule autre
table. Dans les entrepÃ´ts de donnÃ©es, une table des faits doit Ãªtre fragmentÃ©e en utilisant les
schÃ©mas de fragmentation de plusieurs tables de dimension pour garantir une optimisation des
requÃªtes complexes. (3) Toutes les combinaisons de modes de base câ€™est-Ã -dire, Range, List et
Hash sont possibles : Range-Range, List-List, Hash-Hash, List-Hash, etc. Malheureusement,
une table donnÃ©e ne pourra pas Ãªtre fragmentÃ©e selon la combinaison de trois modes de base.
Pour une rÃ©elle utilisation de la fragmentation dans les bases de donnÃ©es, ces modes doivent
Ãªtre supportÃ©s ou implÃ©mentÃ©s par un administrateur.
1Un schÃ©ma de fragmentation est le rÃ©sultat du processus de fragmentation dâ€™une table donnÃ©e
2Ces modes de partitionnement sont aussi supportÃ©s par les autres SGBDs commerciaux comme SQL Server,
Sybase, DB2, etc.
K. Boukhalfa et al.
Cette Ã©volution rapide de la fragmentation horizontale nous a motivÃ©s pour lâ€™Ã©tudier en
dÃ©tail. En explorant les travaux acadÃ©miques et industriels les plus importants sur la maniÃ¨re
de sÃ©lectionner des schÃ©mas de fragmentation horizontale, nous constatons que cette sÃ©lec-
tion suppose une dÃ©composition du domaine des valeurs dâ€™attributs participant au processus de
fragmentation 3. Cette dÃ©composition peut Ãªtre rÃ©alisÃ©e de deux maniÃ¨res : (1) une dÃ©composi-
tion orientÃ©e utilisateur et (2) une dÃ©composition orientÃ©e requÃªtes. Dans la premiÃ¨re catÃ©gorie,
lâ€™administrateur dÃ©compose le domaine de valeurs de chaque attribut de fragmentation en se
basant sur ses connaissances des applications (requÃªtes) et impose Ã  priori le nombre de frag-
ments horizontaux gÃ©nÃ©rÃ©s. Les principaux inconvÃ©nients de ce mode de partitionnement sont
(i) lâ€™absence dâ€™une mÃ©trique garantissant lâ€™efficacitÃ© du schÃ©ma de fragmentation obtenu et (ii)
la maniÃ¨re de dÃ©composer chaque domaine en plusieurs sous domaines.
Dans le partitionnement orientÃ© requÃªtes, les domaines des valeurs des attributs de fragmen-
tation sont dÃ©composÃ©s en se basant sur les requÃªtes dÃ©finies sur le schÃ©ma de la base de
donnÃ©es. Dans ce mode, plusieurs algorithmes ont Ã©tÃ© proposÃ©s dans les bases de donnÃ©es tra-
ditionnelles, que nous pouvons classer en trois principales approches : approches basÃ©es sur les
prÃ©dicats (Ã–zsu et Valduriez, 1999; Ceri et al., 1982), approches basÃ©es sur lâ€™affinitÃ© (Navathe
et al., 1995) et approches basÃ©es sur un modÃ¨le de coÃ»t (Bellatreche et al., 2000). Le principal
inconvÃ©nient de cette catÃ©gorie, est que lâ€™administrateur nâ€™a aucun contrÃ´le sur le nombre de
fragments gÃ©nÃ©rÃ©s.
Dans ce papier, nous montrons la NP-complÃ©tude du problÃ¨me de sÃ©lection de schÃ©ma de
fragmentation avec une contrainte reprÃ©sentant le nombre de fragments que lâ€™administrateur
souhaite avoir. Puis, nous proposons un algorithme de type hill climbing que nous comparons
ensuite avec deux algorithmes de sÃ©lection de schÃ©ma de fragmentation. Les schÃ©mas gÃ©nÃ©rÃ©s
sont ensuite validÃ©s sous Oracle10g avec les donnÃ©es du banc dâ€™essai APB-1 Council (1998).
Pour rÃ©aliser cette expÃ©rimentation, nous avons implÃ©mentÃ© la fragmentation horizontale dÃ©ri-
vÃ©e puisquâ€™elle nâ€™est pas bien nativement supportÃ©e par Oracle10g, ainsi que la fragmentation
combinant trois ou plusieurs modes.
Ce papier est divisÃ© en 6 sections. Dans la section 2, nous formalisons le problÃ¨me de sÃ©lec-
tion dâ€™un schÃ©ma de fragmentation horizontale et proposons une preuve de sa NP-ComplÃ©tude.
La section 3 prÃ©sente lâ€™algorithme de Hill Climbing basÃ© sur un mÃ©canisme de codage permet-
tant dâ€™Ã©viter les solutions redondantes. La section 4 prÃ©sente une Ã©tude expÃ©rimentale afin de
comparer trois algorithmes, Ã  savoir le hill climbing, le recuit simulÃ© et le gÃ©nÃ©tique, tous basÃ©s
sur le mÃªme codage. La Section 5 prÃ©sente une validation de notre travail sur ORACLE10G.
La section 6 conclut le papier en rÃ©sumant le travail effectuÃ© et en citant quelques perspectives.
2 Ã‰tude de complexitÃ©
Dans le contexte des entrepÃ´ts de donnÃ©es relationnels, nous avons proposÃ© dans (Bella-
treche et Boukhalfa, 2005), unemÃ©thodologie pour la fragmentation des diffÃ©rentes tables com-
posant un schÃ©ma en Ã©toile (tables de dimension et table de faits) : (1) fragmenter quelques/toutes
les tables de dimension en utilisant la fragmentation horizontale primaire, et (2) fragmenter la
table des faits en utilisant les schÃ©mas de fragmentation des tables de dimension, fragmentÃ©es
Ã  la premiÃ¨re Ã©tape. Cette mÃ©thodologie peut gÃ©nÃ©rer un nombre important de fragments de la
3La dÃ©composition des domaines de valeurs des attributs dâ€™une table implique une fragmentation horizontale de
cette table.
Fragmentation: ComplexitÃ©, Algorithmes de SÃ©lection et Validation sous ORACLE10g
table des faits (notÃ© par N ) N =âˆgi=1mi oÃ¹mi et g sont le nombre de fragments de la table
de dimension Di et le nombre de tables de dimension qui ont participÃ© dans le processus de
fragmentation, respectivement.
Pour Ã©viter lâ€™explosion de ce nombre, nous formalisons le problÃ¨me de sÃ©lection dâ€™un
schÃ©ma de fragmentation horizontale comme un problÃ¨me dâ€™optimisation sous contrainte :
Ã©tant donnÃ© un ensemble de requÃªtes reprÃ©sentatives Q dÃ©finies sur un entrepÃ´t de donnÃ©es
composÃ© dâ€™une table de faits F et n tables de dimension {D1, D2, ..., Dn}, et une contrainte
de maintenanceW reprÃ©sentant le nombre de fragments de faits que lâ€™administrateur souhaite
avoir, fragmenter la table des faitsF enN fragments tel que
âˆ‘
qjâˆˆQ
freqqjÃ—Cost(qj) (freqqj
reprÃ©sente la frÃ©quence dâ€™accÃ¨s de la requÃªte qj) soit minimisÃ© et que la contrainte (N â‰¤ W )
soit respectÃ©e.
2.1 ComplexitÃ© du problÃ¨me de sÃ©lection dâ€™un schÃ©ma de fragmentation
horizontale
Pour Ã©tudier la complexitÃ© du problÃ¨me de sÃ©lection dâ€™un schÃ©ma de fragmentation ho-
rizontale nous considÃ©rons un problÃ¨me de dÃ©cision simplifiÃ© qui prend en considÃ©ration un
seul domaine dâ€™un attribut dâ€™une table de dimension pour partitionner la table des faits. Nous
appelons ce problÃ¨me, ProblÃ¨me de Fragmentation Horizontale Ã  un Seul Domaine (PFHSD).
Le problÃ¨me dâ€™optimisation correspondant consiste Ã  partitionner la table des faits telle que
le nombre de partitions de cette table soit bornÃ© par une constante et le nombre dâ€™opÃ©rations
dâ€™entrÃ©es/sorties (E/S) nÃ©cessaires soit minimisÃ©. Nous prÃ©sentons ce problÃ¨me dâ€™optimisation
comme suit :
ProblÃ¨me : Fragmentation Horizontale Ã  un Seul Domaine
â€“ Instance :
â€“ un ensemble D de sous domaines disjoints {d1, Â· Â· Â· , dn} dâ€™un attribut dâ€™une table de
dimension et le nombre dâ€™E/S nÃ©cessaires pour lire les donnÃ©es correspondant au sous
domaine di dans la table des faits, notÃ© l(di), 1 â‰¤ i â‰¤ n.
â€“ un ensemble de requÃªtes {q1, Â· Â· Â· , qm} et pour chaque requÃªte qj la liste f(qj) âŠ† D
des sous domaines utilisÃ©s pour lâ€™exÃ©cution de la requÃªte : {dj1, Â· Â· Â· , djnj}, oÃ¹ nj est
le nombre de sous domaines utilisÃ©s pour exÃ©cuter qj .
â€“ deux entiers positifsK et L, oÃ¹K est le nombre maximum de partitions qui peuvent
Ãªtre crÃ©Ã©s et L est le nombre maximum dâ€™E/S nÃ©cessaires pour chaque requÃªte, L â‰¥âˆ‘
dâˆˆf(q) l(d).
â€“ Question : Est-ce queD peut Ãªtre partitionnÃ© au maximumenK sous domaines,D1, Â· Â· Â· , DK
tels que chaque requÃªte nÃ©cessite au plus L opÃ©rations dâ€™entrÃ©es sorties.
Le nombre optimal dâ€™opÃ©ration dâ€™E/S nÃ©cessaires pour une requÃªte qj est : l(qj) =
âˆ‘
dâˆˆf(qj)
l(d).
Ce nombre correspond au cas oÃ¹ seules les donnÃ©es nÃ©cessaires sont chargÃ©es en mÃ©moire pour
exÃ©cuter qj . Selon une partition donnÃ©e, le nombre des opÃ©rations dâ€™E/S augmente puisque
toutes les donnÃ©es dâ€™une partition sont chargÃ©es lorsquâ€™elles sont utilisÃ©es par une requÃªte don-
nÃ©e, mÃªme si cette requÃªte ne nÃ©cessite pas toutes les donnÃ©es de la partition (câ€™est-Ã -dire un
sous-ensemble des domaines de la partition).
Ainsi, le nombre des opÃ©rations dâ€™entrÃ©es/sorties requises par une requÃªte aprÃ¨s fragmen-
tation ne dÃ©pend pas des sous domaines utilisÃ©s, mais uniquement des partitions utilisÃ©es. Le
nombre dâ€™E/S pour le chargement dâ€™une partitionDi est dÃ©fini par : l(Di) =
âˆ‘
dâˆˆDi
l(d). En
K. Boukhalfa et al.
consÃ©quence, le nombre dâ€™E/S nÃ©cessaires Ã  lâ€™exÃ©cution dâ€™une requÃªte peut Ãªtre dÃ©fini comme :
l(q) =
âˆ‘
DâˆˆF (q) l(D), oÃ¹ F (q) est la liste des partitions utilisÃ©es par une requÃªte q.
Lâ€™objectif est de rÃ©aliser un partitionnement horizontal de la table de faits tel que le nombre
de partitions est limitÃ© Ã  K et le nombre dâ€™E/S est limitÃ© par L pour chaque requÃªte. Il est
Ã©vident que si K â‰¥ n, un partitionnement horizontal qui satisfait les contraintes est obtenu
en dÃ©finissant exactement une partition pour chaque di âˆˆ D. De cette maniÃ¨re, toutes les
requÃªtes ne chargent que les donnÃ©es requises pendant leur exÃ©cution. Nous verrons que notre
problÃ¨me de dÃ©cision simplifiÃ© devient difficile lorsque K < n. Nous supposerons aussi que
L â‰¥
âˆ‘
dâˆˆf(q) l(d) car sinon il nâ€™existe pas de partitionnement dâ€™un domaine respectant cette
contrainte.
2.2 NP-ComplÃ©tude du problÃ¨me de fragmentation horizontale dÃ©rivÃ©e
Le problÃ¨me de partitionnement horizontal couplÃ© au problÃ¨me dâ€™allocation a Ã©tÃ© montrÃ©
NP-Complet dans Sacca et Wiederhold (1985) dans une architecture de cluster de proces-
seurs. Dans cette preuve, la NP-ComplÃ©tude ne provient pas de la difficultÃ© Ã  fragmenter les
tables puisque les auteurs considÃ¨rent des relations avec exactement une ligne et une colonne,
donc pour lesquelles aucune fragmentation supplÃ©mentaire nâ€™est possible. PrÃ©cisÃ©ment, la NP-
ComplÃ©tude ne provient que de lâ€™allocation des tables sur les diffÃ©rents processeurs du cluster
(voir preuve dans Sacca et Wiederhold, 1985, p.37).". Dans notre cas, nous ne considÃ©rons que
le problÃ¨me de partitionnement et nous montrons quâ€™il est un problÃ¨me NP-Complet au sens
fort 4.
ThÃ©orÃ¨me 1 Le problÃ¨me de fragmentation horizontale Ã  un seul domaine est NP-Complet au
sens fort.
Preuve 1 Le PFHSD appartient clairement Ã  NP car si on effectue un partitionnement de
D, alors un algorithme polynomial peut vÃ©rifier quâ€™au plus K partitions sont utilisÃ©es et que
chaque requÃªte nÃ©cessite au plus L opÃ©rations dâ€™E/S. Nous prouvons maintenant que le pro-
blÃ¨me PFHSD est NP-Complet au sens fort. Nous utilisons le problÃ¨me 3-Partition qui est
NP-Complet au sens fort (Garey et Johnson, 1990) et se dÃ©finit comme suit :
ProblÃ¨me : 3-Partition
â€“ Instance : Un ensembleA de 3m Ã©lÃ©ments, une borneB âˆˆ Z+, et une taille s(a) âˆˆ Z+
pour chaque a âˆˆ A tel que B/4 < s(a) < B/2 et que
âˆ‘
aâˆˆA s(a) = mB.
â€“ Question : Est ce que A peut Ãªtre partitionnÃ© enm ensembles disjoints A1, Â· Â· Â· , Am tels
que, pour 1 â‰¤ i â‰¤ m,
âˆ‘
aâˆˆAi
s(a) = B ? (notons que chaque Ai doit obligatoirement
contenir trois Ã©lÃ©ments de A)
Pour prouver la NP-ComplÃ©tude du problÃ¨me PFHSD, nous rÃ©duisons Ã  partir du problÃ¨me
3-Partition. Pour chaque instance du problÃ¨me 3-Partition, une instance du problÃ¨me PFHSD
est dÃ©finie comme suit :
â€“ pour chaque ai âˆˆ A, un sous domaine di est crÃ©Ã© de sorte que l(di) = s(ai), 1 â‰¤ i â‰¤
3m.
â€“ 3m requÃªtes sont crÃ©Ã©es telles que chaque requÃªte utilise exactement un sous domaine :
f(qi) = {di}, 1 â‰¤ i â‰¤ 3m.
4Câ€™est la classe des problÃ¨mes les plus durs de NP. Nous renvoyons Ã  (Garey et Johnson, 1990) pour une dÃ©finition
prÃ©cise de cette classe de problÃ¨mes
Fragmentation: ComplexitÃ©, Algorithmes de SÃ©lection et Validation sous ORACLE10g
â€“ K = L = B
Il est clair que la transformation est effectuÃ©e en un temps polynomial car elle consiste Ã  une
correspondance un Ã  un des Ã©lÃ©ments de 3-partition, les sous domaines et les requÃªtes. Nous
prouvons maintenant que nous trouvons une solution Ã  une instance du problÃ¨me 3-partition,
si et seulement si, nous trouvons une solution Ã  une instance du problÃ¨me PFHSD.
(Condition nÃ©cessaire) Supposons que nous avons une solution au problÃ¨me PFHSD, alors
elle satisfait les conditions suivantes :
â€“ puisque B/4 < l(d) < B/2, chaque sous ensemble de D doit Ãªtre dÃ©fini avec exacte-
ment 3 sous domaines (comme dans chaque instance 3-partition).
â€“ Puisque nous avons une solution faisable du problÃ¨me PFHSD, alors aucune requÃªte ne
nÃ©cessite plus deB opÃ©rations dâ€™E/S. Par construction nous vÃ©rifions que :
âˆ‘
dâˆˆD l(d) =
mB. Par consÃ©quent, chaque requÃªte nÃ©cessite exactement B E/S dans la table des faits
(sinon, ce nâ€™est pas une solution). En utilisant une correspondance un Ã  un des sous
domaines en Ã©lÃ©ments de 3-Partition, une solution faisable Ã  lâ€™instance 3-partition est
obtenue.
(Condition suffisante) Supposons que nous avons une solution Ã  une instance 3-Partition.
Alors, chaque sous ensemble Ai a une taille totale de B et il est composÃ© de exactement
3 Ã©lÃ©ments de A. CommenÃ§ant par A1, nous dÃ©finissons une partition de sous-domaines en
utilisant les mÃªmes indices des Ã©lÃ©ments appartenant Ã A1. Puisque chaque requÃªte est associÃ©e
a exactement un sous-domaine et que trois sous domaines sont groupÃ©s dans chaque partition,
alors trois requÃªtes utilisent une partition donnÃ©e. Par consÃ©quent, le nombre dâ€™E/S associÃ©es
Ã  ces trois requÃªtes est exactement B. En rÃ©pÃ©tant ce processus pour chaque sous ensemble
restant Ai, alors une solution faisable du problÃ¨me de fragmentation Ã  un seul domaine est
obtenue.
Notre problÃ¨me de fragmentation horizontale est au moins aussi complexe Ã  rÃ©soudre que
notre problÃ¨me simplifiÃ© car plusieurs domaines sont considÃ©rÃ©s et cela pour plusieurs tables de
dimension. Une instance de notre problÃ¨me de fragmentation est une combinaison de plusieurs
instances du problÃ¨me PFHSD, par consÃ©quent il est NP-Complet au sens fort.
3 Algorithmes de SÃ©lection de SchÃ©ma de Fragmentation
En raison de la complexitÃ© du problÃ¨me de fragmentation horizontale, le dÃ©veloppement
des heuristiques pour la sÃ©lection dâ€™une solution satisfaisante est recommandÃ©. Donc, dans
cette section nous prÃ©sentons un algorithme de Hill Climbing. Avant de dÃ©tailler cet algo-
rithme, nous prÃ©sentons un codage pour reprÃ©senter un schÃ©ma de fragmentation sur lequel des
opÃ©rations seront dÃ©finies.
3.1 Codage dâ€™un schÃ©ma de fragmentation
Rappelons que la fragmentation horizontale est effectuÃ©e sur les attributs de prÃ©dicats de
sÃ©lection dÃ©finis gÃ©nÃ©ralement sur les tables de dimension. Chaque attribut a un domaine de
valeurs. Chaque prÃ©dicat de sÃ©lection est dÃ©fini par :A Î¸ V aleur tel queA est un attribut dâ€™une
table de dimension, Î¸ âˆˆ {=, <,>,â‰¤,â‰¥}, et V aleur âˆˆ Domaine(A) (Ceri et al., 1982). Tout
attribut participant dans le processus de partitionnement est appelÃ© un attribut de fragmenta-
tion.
K. Boukhalfa et al.
 


 	 

 

 
 


 

 
 








 









 

 


ff
fi flffi fi fl fi
FIG. 1 â€“ Exemple de sous domaines
La fragmentation horizontale permet dâ€™abord de partitionner les domaines de valeurs des at-
tributs de fragmentation. Pour illustrer cela, supposons que les domaines des attributs Age et
Sexe de la table de dimension CLIENT et Saison de la table TEMPS sont :
Dom(Age) = ]0, 120], Dom(Sexe) = {â€²M â€²,â€² F â€²} et Dom(Saison) = {Â« Printemps Â»,
Â« EtÃ© Â», Â« Automne Â», Â« Hiver Â»}. Nous supposons que lâ€™administrateur dÃ©compose les do-
maines de ces attributs en sous domaines comme suit : Dom(Age) = d11 âˆª d12 âˆª d13, avec
d11 = ]0, 18], d12 = ]18, 60[, d13 = [60, 120], Dom(Sexe) = d21 âˆª d22, avec d21 = {â€˜M â€²},
d22 = {â€˜F
â€²} et Dom(Saison) = d31 âˆª d32 âˆª d33 âˆª d34, avec d31 = {Â« Printemps Â»} et d32 =
{Â« EtÃ© Â»}, d33 = {Â« Automne Â»} et d34 = {Â« Hiver Â»}. Les diffÃ©rents sous domaines des trois
attributs de fragmentation sont reprÃ©sentÃ©s sur la figure 1.
Le partitionnement du domaine de chaque attribut peut Ãªtre reprÃ©sentÃ© par un tableau mul-
tidimensionnel, oÃ¹ chaque ligne reprÃ©sente le partitionnement du domaine de lâ€™attribut de frag-
mentation. La valeur de chaque cellule dâ€™un tableau donnÃ© reprÃ©sentant un attribut Ai appar-
tient Ã  lâ€™intervalle [1..ni], oÃ¹ ni reprÃ©sente le nombre de sous domaines de lâ€™attribut Ai. En se
basant sur cette reprÃ©sentation, le schÃ©ma de fragmentation de chaque table est gÃ©nÃ©rÃ© comme
suit : (1) si toutes les cellules dâ€™un attribut donnÃ© ont des valeurs diffÃ©rentes alors tous les sous
domaines sont considÃ©rÃ©s pour fragmenter la table de dimension correspondante, (2) Si toutes
les cellules dâ€™un attribut donnÃ© ont la mÃªme valeur cela signifie que cet attribut ne participe pas
au processus de fragmentation, (3) Si certaines cellules dâ€™un attribut ont la mÃªme valeur alors
leurs sous domaines correspondants sont fusionnÃ©s en un seul.
La figure 2 montre un exemple de codage dâ€™un schÃ©ma de fragmentation basÃ© sur trois
attributs de fragmentation, Sexe, Saison et Age. Donc la table CLIENT sera fragmentÃ©e en
utilisant les attributs Age et Sexe et la table TEMPS en utilisant lâ€™attribut Saison. Pour matÃ©-
rialiser cette fragmentation, lâ€™administrateur utilise lâ€™instruction suivante pour crÃ©er les tables
CLIENTS et TEMPS fragmentÃ©es.
CREATE TABLE CLIENT
(CID NUMBER, Nom Varchar2(20), Sexe CHAR, Age Number)
PARTITION BY RANGE (Age)
SUBPARTITION BY LIST (SEXE)
SUBPARTITION TEMPLATE (SUBPARTITION Female VALUES (â€™Fâ€™),
SUBPARTITION Male VALUES (â€™Mâ€™))
(PARTITION Cust_0_60 VALUES LESS THAN (61),
PARTITION Cust_60_120 VALUES LESS THAN (MAXVALUE));
CREATE TABLE TEMPS
(TID NUMBER, Saison VARCHAR2(10), AnnÃ©e Number)
PARTITION BY LIST(Saison)
(PARTITION Time_Summer VALUES(â€™Summerâ€™),
PARTITION Time_Spring VALUES (â€™Springâ€™),
PARTITION Time_Autumn_Winter VALUES(â€™Automnâ€™, â€™Winterâ€™));
Fragmentation: ComplexitÃ©, Algorithmes de SÃ©lection et Validation sous ORACLE10g
! "
! " # #
! ! "
$
%& %
$
'( )*+
, -
%
FIG. 2 â€“ Exemple de codage dâ€™un schÃ©ma de fragmentation
Puisque les tables CLIENT et TEMPS ont Ã©tÃ© fragmentÃ©es en 3 et 4 fragments respective-
ment, la table des faits sera fragmentÃ©e en 12 partitions.
3.2 Partitionner un ensemble et les fonctions Ã  croissance restreintes
Notre codage souffre dâ€™un problÃ¨me de multi-instanciation. Pour illustrer ce problÃ¨me,
nous considÃ©rons un ensemble D = {d1, d2, d3} alors chaque ensemble de partitions de D,
par exemple {{d1, d3}, {d2}} peut Ãªtre reprÃ©sentÃ© par un tableau dâ€™entiers. NÃ©anmoins, un
mÃªme partitionnement peut Ãªtre reprÃ©sentÃ© par diffÃ©rents tableaux dâ€™entiers comme lâ€™exemple
prÃ©sentÃ© dans table 1.
Sous Domaines d1 d2 d3
Tableau 1 0 1 0
Tableau 2 1 0 1
TAB. 1 â€“ Exemple de deux codages du mÃªme partitionnement
Il est clair que tableau 1 et 2 diffÃ¨rent seulement par les numÃ©ros utilisÃ©s pour reprÃ©sen-
ter les sous-ensembles. Dans les deux reprÃ©sentations d1 et d3 appartiennent au mÃªme sous-
ensemble et d2 appartient au deuxiÃ¨me sous-ensemble. Pour rÃ©soudre ce problÃ¨me, nous utili-
sons les fonctions Ã  croissance restreinte (Restricted Growth Functions (Er, 1988; Tucker et al.,
2005).
Soit [n] un ensemble {1, Â· Â· Â· , n}, une fonction Ã  croissance restreinte est une fonction f :
[n]â†’ [n] tel que :
f(1) = 0
f(i+ 1) â‰¤ max{f(1), Â· Â· Â· , f(i)}+ 1
f(i) dÃ©finit lâ€™indice du sous ensemble oÃ¹ lâ€™Ã©lÃ©ment i appartient. Par exemple, la partition
{{1, 3, 5}, {2, 6}, {4}} est reprÃ©sentÃ©e en utilisant les fonctions Ã  croissance restreintes par le
codage suivant : [0,1,0,2,0,1] oÃ¹ 0 est lâ€™indice du premier sous- ensemble. Il y a une correspon-
dance dâ€™Ã©quivalence entre les partitions dâ€™un ensemble et les fonctions Ã  croissance restreinte.
Dans lâ€™exemple prÃ©cÃ©dant, seul tableau 1 respecte lâ€™ordre lexicographique introduit par le co-
dage, tandis que tableau 2 ne sera jamais considÃ©rÃ© durant le partitionnement de lâ€™ensemble
D.
ThÃ©orÃ¨me 2 Il y a une correspondance un Ã  un entre lâ€™ensemble des partitionnements et lâ€™en-
semble des fonctions Ã  croissance restreinte.
K. Boukhalfa et al.
Plusieurs algorithmes sont connus pour gÃ©nÃ©rer toutes les partitions dâ€™un ensemble D dans
lâ€™ordre lexicographique (voir Er (1988) par exemple). Les propriÃ©tÃ©s des fonctions Ã  croissance
restreinte ont Ã©tÃ© Ã©tudiÃ©es pour dÃ©finir efficacement les opÃ©rations de mutation et de croisement
dâ€™un algorithme gÃ©nÃ©tique dans Tucker et al. (2005).
Pour Ã©valuer la qualitÃ© dâ€™un schÃ©ma de fragmentation horizontale, nous avons dÃ©fini un
modÃ¨le de coÃ»t mathÃ©matique qui estime le nombre de pages nÃ©cessaires Ã  charger pour exÃ©-
cuter un ensemble de requÃªtes. Pour des raisons de restriction sur le nombre pages, les dÃ©tails
de ce modÃ¨le de coÃ»t sont prÃ©sents dans Boukhalfa et al. (2008).
3.3 Hill Climbing
Lâ€™algorithme de Hill Climbing est une mÃ©thode de voisinage composÃ©e de deux Ã©tapes
essentielles :
1. Trouver une solution initiale reprÃ©sentant un schÃ©ma de fragmentation de lâ€™entrepÃ´t.
2. AmÃ©liorer itÃ©rativement le schÃ©ma initial en utilisant des mouvements locaux tant que la
rÃ©duction du temps dâ€™exÃ©cution des requÃªtes est possible et que la contrainte de mainte-
nance est satisfaite.
Une solution initiale peut Ãªtre obtenue alÃ©atoirement (en assignant des numÃ©ros choisis de ma-
niÃ¨re alÃ©atoire dans chaque cellule du tableau multidimensionnel). Dans ce travail, nous avons
Ã©vitÃ© la gÃ©nÃ©ration alÃ©atoire de la solution initiale. Nous avons utilisÃ© lâ€™algorithme dâ€™affinitÃ©
(Bellatreche et al., 2000) qui permet de regrouper les sous domaines en se basant sur leur affi-
nitÃ©. Une affinitÃ© entre deux sous-domaines est la somme des frÃ©quences dâ€™accÃ¨s des requÃªtes
accÃ©dant simultanÃ©ment Ã  ces deux sous-domaines. Dans la deuxiÃ¨me Ã©tape, des mouvements
sont effectuÃ©es sur la solution initiale pour rÃ©duire le temps dâ€™exÃ©cution des requÃªtes. Ces
mouvements se basent sur lâ€™utilisation de deux fonctions, Merge et Split. La fonction Merge
permet de combiner deux partitions de sous domaines en une seule et ainsi diminuer le nombre
de fragments gÃ©nÃ©rÃ©s. La fonction Split est duale Ã  la fonctionMerge. Elle permet dâ€™Ã©clater une
partition en deux et augmenter ainsi le nombre de fragments gÃ©nÃ©rÃ©s. Ces deux fonctions res-
semblent aux primitives dâ€™Oracle, MERGE PARTITION et SPLIT PARTITION qui permettent
de fusionner deux partitions en une seule et dâ€™Ã©clater une partition en deux respectivement.
â€“ La fonction Merge possÃ¨de la signature suivante : Merge(P ki , P kj , Ak, FS) â†’ FSâ€².
Elle prend en entrÃ©e deux partitions P ki et P kj (P ki 6= P kj ) de lâ€™attribut Ak et un schÃ©ma
de fragmentation FS et donne en sortie un autre schÃ©ma FSâ€² avec les deux partitions
P ki et P
k
j fusionnÃ©es en une seule partition. La fusion de deux partitions consiste Ã  leur
attribuer le mÃªme numÃ©ro. Câ€™est-Ã -dire assigner un mÃªme numÃ©ro Ã  toutes les cellules
appartenant aux deux partitions sur le tableau unidimensionnel correspondant Ã  Ak .
â€“ La fonction Split possÃ¨de la signature suivante : Split(P ki , Ak, FS)â†’ FSâ€. Elle prend
en entrÃ©e une partitionP ki de lâ€™attributAk et un schÃ©ma de fragmentationFS et donne en
sortie un schÃ©ma SFâ€ avec la partitionP ki Ã©clatÃ©e en deux partitionsP k1i et P k2i (P k1i 6=
P k2i ). Cela est effectuÃ© en donnant deux numÃ©ros diffÃ©rents aux cellules reprÃ©sentant
P k1i et celles reprÃ©sentant P k2i . La fonction Split nâ€™est pas appliquÃ©e sur une partition
Ã©lÃ©mentaire contenant un seul sous domaine.
Pour illustrer le fonctionnement des deux fonctions, nous considÃ©rons lâ€™exemple suivant ;
Exemple 1 Supposant le schÃ©ma de fragmentation reprÃ©sentÃ© par la figure 3(a). Dans ce
schÃ©ma, le domaine de lâ€™attribut Sexe est partitionnÃ© en deux partitions, le domaine de lâ€™attri-
Fragmentation: ComplexitÃ©, Algorithmes de SÃ©lection et Validation sous ORACLE10g
./.0 1
2
33/.4
5 678 9
/.4
2 :2
./.0 1
2
../.4
5 678 9
/.4
2:2
3/.0 1
2
../.4
567 89
/.4
2:2
;
2 <
1
2 =
>
/
?
>@
?
4
5678 9
?
4
A
B
FS FSâ€™ FSâ€™â€™
4
C
D
6E =
>
/
?
0 1
2
?
4
A F
B
(a) (b) (c)
FIG. 3 â€“ Exemple dâ€™application de fonctions Merge et Split
but Saison en trois partitions et le domaine de lâ€™attribut Age en deux partitions. Par exemple
pour lâ€™attribut Saison, la partition P1, contient le sous domaine sd1, P2 contient le sous do-
maine sd2 etP3 contient les sous domaines sd3 et sd4. Par consÃ©quent SF gÃ©nÃ¨re 12 fragments.
Lâ€™application de la fonctionMerge sur les partitionsP1 etP3 de lâ€™attribut Saison (Merge(P1,
P3, Saison,SF)) donne le schÃ©ma de fragmentation SFâ€™. Dans SFâ€™ lâ€™attribut Saison possÃ¨de
deux partitions aprÃ¨s la fusion, la partition P â€²1 contient les sous-domaines sd1, sd3 et sd4 et
la partition P â€²2 contient le sous-domaine sd2 (voir figure 3(b)). SFâ€™ gÃ©nÃ¨re ainsi 8 fragments.
Sur le schÃ©ma SFâ€™, nous appliquons la fonction Split sur la partition P1 de lâ€™attribut Age
(Split(P1,Age, SFâ€™)), nous obtenons le schÃ©ma SFâ€. Dans SFâ€, la partition P1 a Ã©tÃ© scindÃ©e en
deux partitions, la premiÃ¨re contient le sous-domaine sd1 et la deuxiÃ¨me le sous-domaine sd3
(voir figure 3(c)). SFâ€ gÃ©nÃ¨re au total 12 fragments.
4 ExpÃ©rimentations
Dans cette section, nous prÃ©sentons les rÃ©sultats expÃ©rimentaux pour comparer les diffÃ©-
rents algorithmes : hill climbing, le gÃ©nÃ©tique et le recuit simulÃ©. Les deux derniers ont Ã©tÃ©
dÃ©veloppÃ©s dans Bellatreche et al. (2006). Dans ce travail, nous avons rÃ©utilisÃ© ces deux algo-
rithmes avec le codage prÃ©sentÃ© dans cet article en utilisant les fonctions Ã  croissance restreinte.
Cette comparaison est effectuÃ©e en utilisant un modÃ¨le de coÃ»t mathÃ©matique.
Lâ€™entrepÃ´t de donnÃ©es Nous avons utilisÃ© lâ€™entrepÃ´t de donnÃ©es issu du benchmark APB1
(Council, 1998). Le schÃ©ma en Ã©toile de ce benchmark possÃ¨de une table de faits Actvars(24
786 000 tuples), et quatre tables de dimension : Prodlevel (9 000 tuples), Custlevel (900 tuples),
Timelevel(24 tuples) et Chanlevel (9 tuples).
Charge de requÃªtes Nous avons considÃ©rÃ© 60 requÃªtes de recherche composÃ©es dâ€™un seul
bloc (pas de requÃªtes imbriquÃ©es) avec 40 prÃ©dicats de sÃ©lection dÃ©finis sur 12 attributs (Class-
Level, GroupLevel, FamilyLevel, LineLevel, DivisionLevel, YearLevel, MonthLevel, Quarter-
Level, RetailerLevel, CityLevel, GenderLevel, AllLevel). Les domaines de ces attributs sont
dÃ©composÃ©s en 4, 2, 5, 2, 4, 2, 12, 4, 4, 4, 2 et 5 sous domaines. Chaque prÃ©dicat possÃ¨de
un facteur de sÃ©lectivitÃ© calculÃ© sur lâ€™entrepÃ´t rÃ©el. Nos algorithmes ont Ã©tÃ© implÃ©mentÃ©s en
utilisant Visual C++ sur une machine Intel Centrino de 1Go de RAM.
K. Boukhalfa et al.
19
23
27
31
100 200 300 400 500
M
il
li
o
n
s
W
E
/S
HC AG RS Buffer=100
FIG. 4 â€“ Effet de W
24
25
26
27
28
29
30
31
20 40 60 80 100 120 140 160 180 200
M
il
li
o
n
s
Buffer
E
/S
HC AG RS W=100
FIG. 5 â€“ Etude de lâ€™impact du buffer
4.1 Comparaison des heuristiques
Les paramÃ¨tres de lâ€™algorithme gÃ©nÃ©tique sont : nombre dâ€™individus : 20, taux de croise-
ment 80 et taux de mutation 20. Les paramÃ¨tres du recuit simulÃ© sont : tempÃ©rature initiale :
1400, facteur de dÃ©croissement de la tempÃ©rature 0,9 et lâ€™Ã©quilibre 10.
La figure 4 montre les performances de chaque algorithme par rapport au seuil W . Nous
avons fait varierW de 100 Ã  500 en utilisant 40 prÃ©dicats et pour chaque valeur de W , nous
exÃ©cutons chaque algorithme. Le recuit simulÃ© et le gÃ©nÃ©tique donnent de meilleurs rÃ©sultats.
Lâ€™algorithme hill climbing est moins performant par le fait quâ€™il est confrontÃ© Ã  une recherche
plus fine dans des optimums locaux. Lâ€™augmentation du seuil amÃ©liore gÃ©nÃ©ralement les perfor-
mances des requÃªtes car en relÃ¢chantW , plus dâ€™attributs sont utilisÃ©s pour fragmenter lâ€™entre-
pÃ´t. LorsqueW est grand les domaines sont dÃ©composÃ©s en plus de partitions et donc chaque
partition est moins volumineuse. Cela implique moins de donnÃ©es chargÃ©es pour exÃ©cuter les
requÃªtes utilisant les attributs de fragmentation.
La figure 5 montre lâ€™effet du tampon (buffer) sur la performance des requÃªtes. Notre modÃ¨le
de coÃ»t est basÃ© sur la gestion du tampon et sa taille. Nous varions la valeur du buffer de 20
Ã  200 pages et nous exÃ©cutons les algorithmes pour chaque valeur. Lâ€™augmentation de la taille
du tampon implique une amÃ©lioration de la performance car un tampon assez large permet
de garder les rÃ©sultats intermÃ©diaires en mÃ©moire oÃ¹ lâ€™accÃ¨s nâ€™est pas coÃ»teux en temps. Un
tampon de petite taille provoque lâ€™Ã©criture des rÃ©sultats intermÃ©diaires sur le disque et leur
rechargement pour les prochaines jointures, ce qui augmente le nombre dâ€™E/S.
La figure 6 montre lâ€™effet de la taille des tables de dimension (en terme de nombre de
tuples). Nous avons considÃ©rÃ© que toutes les tables de dimension ont le mÃªme nombre de
tuples et nous avons fait varier ce nombre entre 10 et 100000. Les rÃ©sultats montrent que pour
les petites tailles des tables (de 10 Ã  1000) les rÃ©sultats sont presque similaires du fait que
pour ces cas les fragments des tables de dimension sont suffisamment petits pour tenir dans
un nombre de pages similaires. Lorsque la taille des tables de dimension devient importante,
le temps dâ€™exÃ©cution augmente car les fragments de ces derniÃ¨res occupent plus dâ€™espace et
provoque plus de donnÃ©es enregistrÃ©es sur le disque lors de leur jointure avec les fragments de
faits.
Pour voir lâ€™effet du nombre de prÃ©dicats utilisÃ©s dans les 60 requÃªtes sur la performance
globale, nous faisons varier ce nombre entre 10 et 40. Nous crÃ©ons quatre classes de requÃªtes
utilisant chacune un nombre de prÃ©dicats diffÃ©rents (10, 20, 30 et 40 prÃ©dicats). Pour chaque
Fragmentation: ComplexitÃ©, Algorithmes de SÃ©lection et Validation sous ORACLE10g
25
26
27
28
29
30
31
32
33
34
35
10 100 1000 10000 100000
M
il
li
o
n
s
Taille des TD
E
/S
HC AG RS Buffer=100
W=100
FIG. 6 â€“ Effet de la taille des TD
20
30
40
50
60
10 20 30 40
M
il
li
o
n
s
Nombre de prÃ©dicats
E
/S
HC AG RS Buffer=100
Seuil=100
FIG. 7 â€“ Effet du nombre de prÃ©dicats
0
50
100
150
200
250
300
350
400
450
T
e
m
p
s
(s
)
HC RS AG
Buffer=100
W=100
FIG. 8 â€“ Temps dâ€™exÃ©cution de chaque algo-
rithme
0
5
10
15
20
25
30
35
40
45
P T C CH PT PC PCH TC TCH CCH PTC PTCH PCCH TCCH PTCCH
M
il
li
o
n
s
E
/S
1 table 2 table 3 table 4 table
FIG. 9 â€“ Choix et nombre de tables de di-
mension
instance, nous exÃ©cutons nos algorithmes pour W=100. Les rÃ©sultats obtenus montrent que le
nombre de prÃ©dicats utilisÃ©s par les requÃªtes Ã  un effet considÃ©rable sur la performance des
requÃªtes. Lorsque ce nombre est petit, la plupart des requÃªtes ne bÃ©nÃ©ficient pas de la fragmen-
tation. Ceci est expliquÃ© par le fait quâ€™elles accÃ¨dent Ã  un nombre important de sous schÃ©mas,
voire la totalitÃ© des sous-schÃ©mas si elles ne possÃ¨dent pas des prÃ©dicats dÃ©finis sur des at-
tributs de fragmentation. Par consÃ©quent, plusieurs opÃ©rations dâ€™union sont nÃ©cessaires pour
avoir le rÃ©sultat final. Par contre si le nombre de prÃ©dicats est important, le nombre de sous
schÃ©mas valides pour chaque requÃªte est rÃ©duit (surtout pour celles nâ€™utilisant que des attri-
buts de fragmentation) ce qui implique le chargement de moins de donnÃ©es (les sous schÃ©mas
valides seulement).
La figure 8 montre le temps moyen dâ€™exÃ©cution de chaque algorithme pour W=100. Le gÃ©-
nÃ©tique et le recuit simulÃ© consomment plus de temps dâ€™exÃ©cution vu quâ€™ils utilisent plusieurs
opÃ©rations. Lâ€™algorithme gÃ©nÃ©tique prend plus de temps car il manipule plusieurs solutions en
mÃªme temps. Le hill climbing est lâ€™algorithme le plus rapide puisquâ€™il est basÃ© sur deux opÃ©-
rations simples Ã  savoir Merge et Split. Si administrateur privilÃ©gie la qualitÃ© de la solution,
il choisira le recuit simulÃ©, sinon le hill climbing sâ€™il privilÃ©gie la rapiditÃ© dâ€™exÃ©cution de son
algorithme de sÃ©lection.
Pour montrer lâ€™effet du choix des tables de dimension Ã  fragmenter, nous avons menÃ© des
expÃ©rimentations en utilisant, 1,2, 3 et 4 tables de dimension pour fragmenter lâ€™entrepÃ´t. Pour
K. Boukhalfa et al.
0
10
20
30
40
50
60
Y M Q YM YQ MQ YMQ
M
il
li
o
n
s
E
/S
1 attribut 2 attributs 3 attributs
FIG. 10 â€“ Choix des attributs de la table Ti-
melevel
0
10
20
30
40
50
60
Prodlevel Timelevel Custlevel
M
il
li
o
n
s
E
/S
1 attribut 2 attribut 3 attribut
FIG. 11 â€“ Effet du nombre dâ€™attributs de
fragmentataion de chaque table
chaque cas, nous avons pris en considÃ©ration toutes les combinaisons possibles. Ces expÃ©ri-
mentations ont Ã©tÃ© effectuÃ©es en utilisant le RS puisque il donne les meilleurs rÃ©sultats. Les
tables utilisÃ©es sont : Prodlevel(P), Timelevel(T), Custlevel(C) et Chanlevel(CH). La figure 9
montre les rÃ©sultats obtenus. Ces derniers montrent que le choix des tables de dimension Ã 
fragmenter est trÃ¨s important. Par exemple, la table Timelevel est la plus adaptÃ©e pour Ãªtre par-
titionnÃ©e, cela est justifiÃ©e que cette table est la table la plus utilisÃ©e par la charge de requÃªtes
et par consÃ©quent ces requÃªtes accÃ©deront Ã  moins de sous schÃ©mas en Ã©toile et donc moins de
donnÃ©es chargÃ©es. Les rÃ©sultats montrent aussi que choisir plus de tables de dimension pour la
fragmentation donne plus de performance Ã  condition de choisir les bonnes tables.
Pour montrer lâ€™effet du choix des attributs, nous avons pris lâ€™exemple de la table Timelevel.
Nous avons considÃ©rÃ© toutes les combinaisons possibles pour le choix des attributs (voir figure
10). Ces attributs sont (Monthlevel(M), Yearlevel(Y) et Quarterlevel(Q). Lâ€™attribut Monthlevel
donne les meilleurs rÃ©sultats. Ceci sâ€™explique par le fait que Monthlevel est lâ€™attribut le plus
utilisÃ© et son utilisation dans la fragmentation permet aux requÃªtes qui lâ€™utilisent dâ€™accÃ©der Ã 
un nombre rÃ©duit de sous-schÃ©mas et de donnÃ©es.
La mÃªme expÃ©rience a Ã©tÃ© menÃ©e pour les deux autres tables de dimension. Nous avons pris
pour chaque table le meilleur temps dâ€™exÃ©cution des requÃªtes pour le cas de 1, 2 ou 3 attributs
choisis pour fragmenter lâ€™entrepÃ´t (voir figure 11). Les rÃ©sultats montrent que lorsquâ€™on choisit
plus dâ€™attributs pour fragmenter lâ€™entrepÃ´t nous obtenons plus de performance car plus de
requÃªtes sont satisfaites (celles utilisant ces attributs) en accÃ©dant Ã  moins de sous schÃ©mas en
Ã©toile.
5 Validation sour ORACLE10g
Pour valider notre travail, nous avons dÃ©veloppÃ© une plate forme sous ORACLE10g pour
gÃ©rer le partitionnement dâ€™un entrepÃ´t de donnÃ©es. Lâ€™architecture de cette plate forme est dÃ©-
crite dans la figure 12.
Cette architecture est composÃ©e de trois modules principaux : (1) le module de sÃ©lection
dâ€™un schÃ©ma de fragmentation, (2) le module de fragmentation de lâ€™entrepÃ´t et (3) le module
de rÃ©Ã©criture des requÃªtes.
Fragmentation: ComplexitÃ©, Algorithmes de SÃ©lection et Validation sous ORACLE10g
Q
DataSet
W
SF
Scripts
QG
EntrepÃ´t global
Fragments Horizontaux
Module de 
fragmentation
Module de 
r
HH
criture
Module de 
SHlection de SFH
(AG,RS, HC)
FIG. 12 â€“ Architecture de notre implÃ©menta-
tion
24,02
17,60
20,76 21,43
0
5
10
15
20
25
Te
m
p(
m
s
)
Millions
AF RS AG HC
FIG. 13 â€“ RÃ©sultats sous Oracle
1. Module de sÃ©lection dâ€™un schÃ©ma de fragmentation horizontale (MSSFH) : Ã  partir dâ€™un
ensemble de requÃªtes, le schÃ©ma de lâ€™entrepÃ´t et le nombre de fragments souhaitÃ©s,
MSSFH permet de sÃ©lectionner un schÃ©ma de fragmentation horizontale en utilisant un
des trois algorithmes proposÃ©s.
2. Module de fragmentation (MF) : Ce module reÃ§oit en entrÃ©e un schÃ©ma de fragmentation
gÃ©nÃ©rÃ© par MSSFH et donne en sortie tous les scripts permettant de fragmenter lâ€™entre-
pÃ´t. Deux types de scripts sont gÃ©nÃ©rÃ©s. Le premier concerne les scripts pour fragmenter
les tables de dimensions en utilisant la fragmentation primaire. Le deuxiÃ¨me type de
scripts est pour fragmenter la table des faits. Plusieurs difficultÃ©s sont apparues pour rÃ©a-
liser ce module. Elles sont liÃ©es au fait quâ€™ORACLE ne supporte pas une fragmentation
primaire sur plus de trois attributs et une fragmentation dÃ©rivÃ©e de la table des faits en
utilisant plus de deux tables de dimension (voir Section 1).
Pour remÃ©dier Ã  ces difficultÃ©s, nous avons dÃ©veloppÃ© une technique permettant dâ€™im-
plÃ©menter la fragmentation horizontale sur plusieurs attributs. La technique consiste Ã 
ajouter une colonne supplÃ©mentaire Coli dans la table de dimension Di Ã  fragmenter.
Selon le schÃ©ma de fragmentation de la table Di notre module de fragmentation gÃ©nÃ¨re
un script PlSql permettant de remplir cette colonne pour chaque instance. La valeur de
cette colonne pour une instance insj dâ€™une table de dimension Di correspond au nu-
mÃ©ro de fragment contenant insj . AprÃ¨s le remplissage, nous fragmentons la table Di
par liste sur cette colonne.
Pour supporter la fragmentation horizontale dÃ©rivÃ©e basÃ©e sur la fragmentation de plu-
sieurs tables de dimension, nous avons dÃ©veloppÃ© la solution suivante : nous crÃ©ons une
colonne supplÃ©mentaire ColF dans la table des faits. Cette colonne contient la concatÃ©-
nation des numÃ©ros de fragments des tables de dimension. Pour remplir cette colonne,
nous effectuons une jointure entre la table des faits et les tables de dimension fragmen-
tÃ©es, et nous concatÃ©nons les valeurs des colonnes Coli utilisÃ©es pour fragmenter les
tables de dimension. Nous fragmentons ensuite la table des faits par liste sur la colonne
ColF . Pour faire cela, nous crÃ©ons une vue matÃ©rialisÃ©e temporaire V comme suit :
CREATE MATERIALIZED VIEW V
BUILD IMMEDIATE
AS
K. Boukhalfa et al.
SELECT a.customer_level, a.product_level,a.channel_level,
a.time_level, a.unitssold, a.dollarsales,a.dollarcost,
prod_col||â€™-â€™||time_col||â€™-â€™||cust_col as Col_F
FROM actvars a, prodlevel p, custlevel c, timelevel t
WHERE a.customer_level = c.store_level
AND a.product_level = p.code_level
AND a.time_level = t.tid
Nous chargeons la vue matÃ©rialisÃ©e V dans la table des faits et nous supprimons ensuite
V.
3. Module de rÃ©Ã©criture (MR) : ce module reÃ§oit en entrÃ©e un schÃ©ma de fragmentation
SF et les requÃªtes globales, il retourne des requÃªte rÃ©Ã©crites sur SF . La rÃ©Ã©criture dâ€™une
requÃªte qj sur SF consiste Ã  identifier les sous schÃ©mas valides pour qj et ensuite la
rÃ©Ã©crire sur ces derniers.
5.1 ImplÃ©mentation sous Oracle
Nous avons implÃ©mentÃ© les schÃ©mas de fragmentation obtenus Ã  partir de chaque algo-
rithme sous Oracle 10g. Nous avons choisi le scÃ©nario suivant pour valider les trois algo-
rithmes : Lâ€™algorithme gÃ©nÃ©tique et le recuit simulÃ© ont gÃ©nÃ©rÃ© un schÃ©ma de fragmentation
composÃ© de 80 sous schÃ©mas en Ã©toile. Le gÃ©nÃ©tique utilise 5 attributs parmi 12 et 3 tables
de dimension (Timelevel, Custlevel et Chanlevel) pour fragmenter lâ€™entrepÃ´t. Le recuit simulÃ©
utilise 5 attributs mais toutes les tables de dimension ont Ã©tÃ© utilisÃ©es pour fragmenter lâ€™entre-
pÃ´t. le Hill Climbing a gÃ©nÃ©rÃ© 96 sous schÃ©mas en Ã©toile en utilisant 4 attributs et 3 tables de
dimension (Prodlevel, Timelevel et Chanlevel).
Nous avons implÃ©mentÃ© chaque schÃ©ma en utilisant notre module de fragmentation. Les
requÃªtes dâ€™origine ont Ã©tÃ© rÃ©Ã©crites par le module de rÃ©Ã©criture sur chaque schÃ©ma de frag-
mentation. Nous avons exÃ©cutÃ© les requÃªtes dâ€™origine sur lâ€™entrepÃ´t non fragmentÃ© (AF) et les
requÃªtes rÃ©Ã©crites sur lâ€™entrepÃ´t fragmentÃ© correspondant. Le tampon est vidÃ© aprÃ¨s chaque
exÃ©cution de requÃªte. La figure 13 montre les rÃ©sultats obtenus. Elle illustre deux points im-
portants : (i) que la fragmentation horizontale dans les entrepÃ´ts de donnÃ©es est cruciale pour
la performance de requÃªtes et (ii) que le choix de lâ€™algorithme de fragmentation a un im-
pact considÃ©rable sur cette performance. Par exemple, lâ€™algorithme de recuit simulÃ© donne de
meilleurs rÃ©sultats (comme dans lâ€™Ã©valuation thÃ©orique) que le gÃ©nÃ©tique ou le hill climbing.
6 Conclusion
La fragmentation horizontale a Ã©tÃ© largement adoptÃ©e par la plupart des systÃ¨mes de gestion
de bases de donnÃ©es commerciaux et les chercheurs, oÃ¹ elle est supportÃ©e dans leurs langages
de dÃ©finition de donnÃ©es. Nous avons prÃ©sentÃ© un Ã©tat de lâ€™art sur lâ€™Ã©volution de cette technique
dâ€™optimisation non redondante au sein de ces systÃ¨mes. Cette Ã©tude nous a permis de confron-
ter les travaux de recherche avec les travaux industriels et surtout de dÃ©gager quelques limites
des travaux industriels. Ainsi, nous avons montrÃ© la NP-complÃ©tude du problÃ¨me de sÃ©lection
de schÃ©ma de fragmentation dâ€™un entrepÃ´t de donnÃ©es. Le schÃ©ma sÃ©lectionnÃ© comprend deux
autres schÃ©mas : un schÃ©ma de fragmentation des tables de dimension (obtenu par la fragmen-
tation horizontale primaire) et un schÃ©ma de fragmentation de la table des faits (obtenu par la
Fragmentation: ComplexitÃ©, Algorithmes de SÃ©lection et Validation sous ORACLE10g
fragmentation horizontale dÃ©rivÃ©e). Pour sÃ©lectionner un schÃ©ma de fragmentation quasi op-
timal, nous avons proposÃ© une heuristique de hill climbing. Pour Ã©valuer la qualitÃ© de cette
heuristique, nous lâ€™avons comparÃ©e avec dâ€™autres autres algorithmes : le gÃ©nÃ©tique et le recuit
simulÃ©. Cette comparaison est rÃ©alisÃ©e avec une Ã©tude expÃ©rimentale basÃ©e sur un modÃ¨le de
coÃ»t calculant le nombre dâ€™entrÃ©es/sorties nÃ©cessaire pour exÃ©cuter un ensemble de requÃªtes.
Pour valider nos algorithmes, nous avons menÃ© une implÃ©mentation rÃ©elle de tous les schÃ©-
mas de fragmentation gÃ©nÃ©rÃ©s par les trois algorithmes sous ORACLE10G avec les donnÃ©es
du banc dâ€™essai APB1. Cette implÃ©mentation comprend la fragmentation horizontale primaire
et dÃ©rivÃ©e. Les rÃ©sultats obtenus montrent lâ€™intÃ©rÃªt et lâ€™impact de la fragmentation horizontale
dans les entrepÃ´ts de donnÃ©es relationnels et le choix de lâ€™algorithme de fragmentation.
Il serait intÃ©ressant dâ€™adapter les algorithmes proposÃ©s pour la fragmentation verticale.
Une adaptation directe consiste Ã  remplacer les sous domaines par les attributs des tables Ã 
fragmenter.
RÃ©fÃ©rences
Bellatreche, L. et K. Boukhalfa (2005). An evolutionary approach to schema partitioning
selection in a data warehouse environment. Proceeding of the International Conference on
Data Warehousing and Knowledge Discovery (DAWAKâ€™2005), 115â€“125.
Bellatreche, L., K. Boukhalfa, et H. I. Abdalla (2006). Saga : A combination of genetic and
simulated annealing algorithms for physical data warehouse design. in 23rd British National
Conference on Databases (212-219).
Bellatreche, L., K. Karlapalem, et A. Simonet (2000). Algorithms and support for horizontal
class partitioning in object-oriented databases. in the Distributed and Parallel Databases
Journal 8(2), 155â€“179.
Boukhalfa, K., L. Bellatreche, et P. Richard (2008). Fragmentation primaire et dÃ©rivÃ©e :
Ã‰tude de complexitÃ©, algorithmes de sÃ©lection et validation sous oracle10g. Techreport
http ://www.lisi.ensma.fr/members/bellatreche, LISI/ENSMA.
Ceri, S., M. Negri, et G. Pelagatti (1982). Horizontal data partitioning in database design.
Proceedings of the ACM SIGMOD International Conference on Management of Data. SIG-
PLAN Notices, 128â€“136.
Corp., O. (2007). Oracle partitioning. White Paper,
http ://www.oracle.com/technology/products/bi/db/11g/ .
Council, O. (1998). Apb-1 olap benchmark, release ii.
http ://www.olapcouncil.org/research/resrchly.htm.
Er, M. C. (1988). A fast algorithm for generating set partitions. Comput. J. 31(3), 283â€“284.
Garey, M. R. et D. S. Johnson (1990). Computers and Intractability ; A Guide to the Theory of
NP-Completeness. New York, NY, USA : W. H. Freeman & Co.
Navathe, S., K. Karlapalem, et M. Ra (1995). A mixed partitioningmethodology for distributed
database design. Journal of Computer and Software Engineering 3(4), 395â€“426.
Ã–zsu, M. T. et P. Valduriez (1999). Principles of Distributed Database Systems : Second
Edition. Prentice Hall.
K. Boukhalfa et al.
Papadomanolakis, S. et A. Ailamaki (2004). Autopart : Automating schema design for large
scientific databases using data partitioning. Proceedings of the 16th International Confe-
rence on Scientific and Statistical Database Management (SSDBM 2004), 383â€“392.
Sacca, D. et G. Wiederhold (1985). Database partitioning in a cluster of processors. ACM
Trans. Database Syst. 10(1), 29â€“56.
Sanjay, A., V. R. Narasayya, et B. Yang (2004). Integrating vertical and horizontal partitioning
into automated physical database design. Proceedings of the ACM SIGMOD International
Conference on Management of Data, 359â€“370.
Tucker, A., J. Crampton, et S. Swift (2005). Rgfga : An efficient representation and crossover
for grouping genetic algorithms. Evol. Comput. 13(4), 477â€“499.
Summary
Horizontal partitioning has been largely advocated by database community, especially dur-
ing the physical design phase. Most of todayâ€™s commercial database systems offer native DDL
(data definition language) support for defining horizontal partitions of a table/view using differ-
ent modes. In this paper, we first present the evolution of horizontal partitioning in commercial
database systems during last decade and we point out some limitations. Secondly, we study
the problem of selecting horizontal partitioning schema of a relational data warehouse and we
show its NP-completeness. Due to its high complexity, we develop a hill climbing heuris-
tic to select a near optimal solution. We conduct extensive experimental studies to compare
using a mathematical cost model the quality of hill climbing with other existing algorithms
(genetic and simulated annealing). Finally, we present a real validation of our algorithms on
ORACLE10G using data set of APB1 benchmark.
