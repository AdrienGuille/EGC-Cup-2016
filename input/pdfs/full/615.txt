1 
 
 
 
Un formalisme pour l’intégration de données hétérogènes 
 
Sana Hamdoun*, Faouzi Boufares* 
 
*Institut Galilée, Université Paris Nord Av. J. B. Clément 93430 Villetaneuse France 
Sh@lipn.univ-paris13.fr 
Boufares@lipn.univ-paris13.fr 
 
 
Résumé. Dans ce papier nous proposons, un formalisme  d’intégration de don-
nées hétérogènes. Nous définissons, d’une manière générale, une source de 
données comme un ensemble de composants muni des relations et fonctions 
qui relient ces composants, et un environnement d’intégration comme un en-
semble de sources  associé à un ensemble de liens d’intégration entre ces 
dernières.  
L’approche générale d’intégration que nous proposons s’inscrit dans le cadre 
de la construction d’entrepôts de données hétérogènes basés sur des sources de 
catégories différentes, structurées, semi-structurées et non structurées telles 
que relationnelles, objet-relationnelles et XML. Le processus d’intégration est 
composé de trois étapes : le filtrage de l’ensemble des composants de 
l’entrepôt, la génération de son schéma global et la construction des vues qui le 
composent. 
 
  
1 Introduction 
Très généralement parlant, une base de données (BD) est une  grande quantité d’informations stoc-
kées sur support informatique de telle sorte que son exploitation (mise-à-jour, recherche, extraction 
d’information, analyse et fouille de données (Benabdeslem et al., 2001) soit facilitée.   
Dans une BD les éléments d’information sont reliés logiquement et physiquement. Ces éléments 
et liens sont organisés selon un modèle de données. Une donnée est une sorte de composition des élé-
ments d’information via les liens envisagés, et dans ce cas une BD est un ensemble de données. 
Dans ce papier, nous faisons l’abstraction des concepts de données et de bases de données, aussi 
bien au niveau logique qu’au niveau sémantique, et ceci indépendamment de tout processus de modéli-
sation. 
Une BD sera vue comme un ensemble de composants muni des liens pour les relier.  
Sémantiquement, les données et leurs liens seront interprétés dans un système de types. Bien que ce 
dernier  puisse dépendre du modèle envisagé, nous faisons aussi l’abstraction d’un tel système pour 
BDs, indépendamment du modèle. 
Gérer plusieurs BDs revient donc à gérer plusieurs ensembles et plusieurs relations (au sens général 
du terme) sur ces derniers. 
L’intégration des données est l’ensemble des transformations que subissent  certaines données et 
leurs organisations afin d’être fusionnées et présentées éventuellement sous une nouvelle forme (entre-
Un formalisme pour l’intégration de données hétérogènes 
pôt de données, bases de données temporelles, versions…). On parle d’intégration quand les données 
proviennent des BDs différentes (éventuellement avec des modélisations différentes). Dans ce cas, 
chaque BD est appelée une source de données (SD). Fusionner les sources nécessite d’envisager aussi 
des liens entre les données provenant de ces dernières. De tels liens peuvent  permettre, par exemple au 
niveau logique, d’identifier deux données ou négliger une donnée en faveur d’une autre mieux défi-
nie. Ces sources et ces liens forment un environnement d’intégration. Donc, un environnement 
d’intégration est un ensemble de SDs munies de liens entre les données provenant de ces sources. Le 
processus d’intégration, proprement, dit devient alors une fonction qui prend en entrée un environne-
ment d’intégration et rend  un nouvel ensemble de données tel qu’un entrepôt de données (ED) ou une 
BD temporelle. Notre démarche n’est pas applicable exclusivement pour la construction d’ EDs. Elle 
peut être utilisée pour d’autres environnements d’intégration. 
Un ED est une collection de données orientées sujet, intégrées, non volatiles et variant dans le 
temps organisées pour le support d’un processus d’aide à la décision (Inmon, 1995). L’environnement 
informationnel actuel se caractérise par des données fortement distribuées. Ces dernières, surabon-
dantes, sont généralement éparpillées et hétérogènes. En effet, avec l’apparition d’Internet et le déve-
loppement des différentes représentations et formats des documents, les données peuvent être de plu-
sieurs catégories : structurées (données relationnelles et objet), semi-structurées (HTML, XML et 
graphes) ou même non structurées (texte, images et son). 
L’hétérogénéité n’est pas un problème récent (Pontieri et al., 2003). Cependant, dans la littérature, 
il n’existe pas de consensus sur la signification de l’hétérogénéité. En effet, selon le domaine et le type 
d’application, le traitement et l’interprétation de l’hétérogénéité ont été fait de plusieurs façons. Dans 
certains travaux, l’hétérogénéité des données réside dans l’utilisation de sources contenant des données 
différentes alors qu’elles sont de même catégorie et de même modélisation (Da Silva et al., 2002). 
D’autres travaux évoquent l’hétérogénéité quand il s’agit de l’utilisation de données de même catégorie 
mais avec des modélisations différentes (Saccol et Heuser, 2002). La différence des modèles a un 
impact sur la représentation et les types des données ce qui les rend hétérogènes. D’autres auteurs 
présentent l’hétérogénéité dans le fait que les données appartiennent à des catégories différentes (Kim 
et Park, 2003) (Beneventano et al., 2002). Ainsi, nous classons les données en trois catégories (structu-
rées, semi-structurées et non-structurées).  L’utilisation de données de structures différentes  revient 
nécessairement à traiter l’hétérogénéité.  
Vu les différentes interprétations de l’hétérogénéité, nous adoptons, dans le cadre de notre travail 
d’intégration, la définition ci-dessous. Ce qui va nous permettre de traiter toutes les catégories à la fois : 
Des sources de données sont dites hétérogènes si elles vérifient l’une des deux propriétés sui-
vantes : 1) Elles appartiennent à la même catégorie de données mais elles ont des modélisations diffé-
rentes ; 2) Elles appartiennent à des catégories de données différentes. Ainsi le traitement d’une BD 
relationnelle et d’une BD objet-relationnelle revient à gérer des sources de données hétérogènes. Il en 
est de même pour une BD relationnelle et une BD XML. 
De nos jours, les applications complexes telles que l’extraction de connaissances, les fouilles de 
données, l’apprentissage (Bennani, 2006) et les applications web utilisent des données hétérogènes et 
distribuées. Dans un  tel contexte, le besoin d’intégration se fait de plus en plus ressentir. Cependant, 
pour répondre à ce besoin, le développement des applications d’intégration se voit contraint de compo-
ser avec la répartition des sources et leur hétérogénéité (Structures et Données). L’utilisation de don-
nées non structurées ou semi-structurées telles que XML dans le cadre de ces applications rend égale-
ment  leur maintenance et leur interrogation non évidente (Wang et al.,2006) (Prakash et al., 2006). 
 
Dans ce papier, nous nous intéressons au domaine d’intégration de données dans le but de cons-
truire des entrepôts dont les sources sont totalement hétérogènes. Il est structuré comme suit. Le para-
graphe deux traite les BD classiques (XML, relationnelles, et objet-relationnelles) revisitées ainsi 
qu’une proposition d’une modélisation générale de ces bases. L’environnement d’intégration ainsi que 
les différents liens sont présentés dans la section trois. Les étapes du processus d’intégration proposé 
sont présentées dans le paragraphe quatre. Nos travaux futurs sont donnés en guise de conclusion. 
S. Hamdoun et al. 
RNTI - X -   
2 Modélisation formelle d’une source de données 
Afin d’uniformiser la modélisation des SDs hétérogènes, nous présentons dans cette section, dans 
un premier temps, les concepts de système de types et de source de données. Dans un deuxième temps, 
nous revisitons les modélisations des BDs structurées et semi-structurées. Les données non structurées 
sont gérées dans des BDs relationnelles étendues avec les types complexes tels que BLOB et CLOB. 
2.1 Système de types pour BD 
Dans un système de types, les types sont construits à partir des types de base (prédéfinis) et de 
constructeurs de types. Un constructeur de type prend une séquence de types et construit un nouveau 
type. Donc, d’une manière générale, les types sont construits par la grammaire ci-dessous : 
 TYPES ::= BASE | CONST TYPES*   où BASE est l’ensemble des types prédéfinis, 
CONST est l’ensemble de constructeurs et TYPES* est l’ensemble de séquences de TYPES.  
Exemple 1 (Système de types) 
  BASE ::=integer | char(n) | varchar(n) | BLOB | CLOB |… 
  CONST ::=set | list | tuple | … 
Dans un système de types pour les BDs, les valeurs des types de base ont par exemple un certain 
format et les formats peuvent être étendus d’une manière naturelle. Par exemple, si  A:char(5) et 
B:char(10), les A-valeurs peuvent être utilisées comme B-valeurs. Ceci ressemble à une relation de 
réécriture. Selon les constructeurs retenus, cette relation peut être étendue aux types construits de même 
structure. 
Utilisons la notation t1 t2 pour dire que tout x : t1 peut être vue comme x : t2.  
Une telle relation parmi les types est transitive. Toutefois, il ne faut pas voir cette relation comme 
une relation d’héritage. Inspirés de la théorie de réécriture, nous notons par * la fermeture transitive 
de . 
Nous supposons que les types d’un Système de Gestion de BD (SGBD) sont munis d’une telle rela-
tion et vérifient la propriété suivante, dite de confluence : Si t1 
*t2  et t1
*t3 alors il existe t4 tels que  
t2
*t4 et t3
*t4. Dans un tel système, définissons la compatibilité de la manière suivante : 
Définition 1 (Compatibilité) : Deux types t1 et t2 sont compatibles s’il existe un type t3 tel que t1
*t3 
et t2
*t3■ 
Dans un système satisfaisant la propriété de confluence, la compatibilité est une relation 
d’équivalence que nous notons par . La preuve est donnée dans (Hamdoun, 2006). Dans la suite, nous 
supposerons que les systèmes de types envisagés vérifient la propriété de confluence. 
2.2 Sources de données 
Rappelons d’abord que si X est un ensemble. |X| désigne sa cardinalité et P(X) l’ensemble de ses 
parties. Les ensembles envisagés seront des ensembles finis, donc |X| est un entier naturel et P (X) est 
aussi fini. 
D’une manière générale, nous appelons source de données un ensemble accompagné d’une ou plu-
sieurs relations. Toutefois, dans ce papier, nous nous restreignons dans un cadre plus restreint et nous 
modélisons une source de données comme suit : 
 
Définition2 (Source de données) : Nous appelons source de données un triplet  BD = (C, ref, comp) 
où :  
C est un ensemble, 
 ref : P( C)  P( C)  est une relation binaire tel que  X ref  Y   |X| = |Y|, 
comp :  C  P( C) est une fonction telle que ccomp(c) pour tout cC ■ 
Un formalisme pour l’intégration de données hétérogènes 
Un élément de C sera appelé un composant de BD. Un composant c est dit simple si comp(c)=. 
Toute source de données est accompagnée d’un système de types dans lequel elle est interprétée. 
Chaque composant simple est interprété par un type de base. Les constructeurs de types doivent per-
mettre d’interpréter tous les composants. 
Revisitons ci-dessous les modèles relationnel, objet-relationnel et XML afin de démontrer que ces 
derniers peuvent être modélisés de la même manière indépendamment du modèle et de la catégorie des 
données 
2.3 Modélisation d’une SD structurée (Modèles relationnel et objet-relationnel 
revisités) 
Dans la suite de notre travail nous désignerons par BD relationnelle-étendue soit une BD relation-
nelles soit une BD objet-relationnelles. La définition d’une BD se fait en prenant en compte la descrip-
tion de la structure des objets du monde réel que l’on souhaite stocker (schéma de la BD) et leur défini-
tion (instance de la BD). 
Soit REL, ATT et DOM trois ensembles disjoints. 
- Un schéma de base de données relationnelle-étendue sur (REL, ATT, DOM) est un triplet (Voir 
Hamdoun, 2006) : 
S=(Rs, ATTs, DOMs) accompagné de trois fonctions : 
doms :  ATTs  DOM 
atts :  Rs  Pf(ATT)\{} 
[[ ]]s :  DOMs  TYPES 
où TYPES désigne les différents types générés par un système de types préalablement envisagé, et 
ATTS=
R Rs
atts (R). 
- Une instance de S est une fonction δs : 
  δs : Rs  RRs(Insts(R))  
telle que δs(R)  Insts(R) pour tout R  Rs, où Insts(R)=Pf(doms(R)) et doms(R)= A 
att
s
(R)(doms(A)]]s). 
- Une base de données est un triplet (S, Ks, s) où S est un schéma, Ks est un ensemble de con-
traintes et s est une instance de S satisfaisant les contraintes. L’état s s’appelle l’état courant. 
Une base relationnelle-étendue, peut ainsi être vue comme une source de données (Cf Défini-
tion 2).   
 
Définition 3 (Source de données relationnelles étendues) : Une source de données relationnelles 
étendues est alors un triplet BD = (C, ref, comp) avec 
+ L’ensemble de composants C = ATTs   Rs. Un composant c de C a donc l’une des deux 
formes suivantes. Soit c=DB.R.A ou bien c=DB.R avec RRs  et  AATTs . 
+ Le lien ref, permet  d’identifier les références externes dans la BD, il est défini comme 
suit : 
X ref Y     X  ATTs , Y ATTs et X est une référence externe de Y.  
+La fonction comp  est définie de la manière suivante : comp : ATTsRs  Pf (ATTs Rs) 
comp(X)=Y     X Rs, Y  ATTs et Y = atts(X) 
ou bien, X  ATTs, X est un attribut composé, et Y  ATTs, Y est l’ensemble des attributs 
qui compsent X ■ 
S. Hamdoun et al. 
RNTI - X -   
2.4 Modélisation d’une SD semi-structurée (Modèle XML revisité) 
La définition d’une BD XML se fait aussi en deux étapes. La description des objets du monde réel 
(schéma de la BD) et la définition de ces derniers (instance de la BD). La description du schéma de la 
BD peut se faire soit à l’aide d’une DTD ou bien à l’aide d’un schéma XML (Cluet et Siméon, 2000).  
Soit ELEM et DOM deux ensembles disjoints.   
- Un schéma de BD XML sur (ELEM, DOM) est un couple S=( ES, DOMS) accompagné de 
trois fonctions (Voir Hamdoun, 2006) : 
doms : ES
s
              DOM 
atts :     Es                Pf(Es) 
[[ ]]s :  DOMs        TYPES 
où TYPES désigne les types générés par un système de types auparavant envisagé. 
- Une instance de S est une fonction δs : ESs  RRs( [[doms(E)]]s) telle que δs(E)  
[[doms(E)]]s pour tout E  ES
s. 
- Une base de données est un triplet (S, Ks, s) où S est un schéma, Ks est un ensemble de con-
traintes et s est une instance de S satisfaisant les contraintes. L’état s est appelé état courant. 
 
Dans la vision du modèle XML présentée ci-dessus, nous n’avons pas tenu en compte la notion 
d’attributs des éléments XML. Nous considérons que les attributs d’un élément peuvent être repré-
sentés comme étant des sous-élements de celui-ci. Nous n’avons pas également considéré les enti-
tés car elles n’interviennent pas dans la structure du document XML.  
Une base XML peut ainsi être vue comme source de données (Cf Définition 2). 
 
Définition 4 (Source de données XML) : Une source de données XML est alors un triplet  
BD=(C, ref, comp) avec :   
+ L’ensemble de composants  C = Es   
+ Le lien ref, permet d’identifier les références externes dans la BD. Il est défini comme suit :  
   X ref  Y     X  ES
s , Y ES
s et X est une référence externe de Y.  
+ La fonction comp  est la fonction atts■ 
 
Remarque 1 
Cette formalisation montre que les modèles des sources n’interviennent pas. En effet, nous avons 
démontré que toute source de données d’un des types étudiés peut être vue comme un triplet BD = (C, 
ref, comp) quel que soit le modèle sous-jacent (cf définitions 2, 3 et 4). Ainsi, les sources peuvent être 
totalement hétérogènes, structurées, semi-structurées et éventuellement non structurées. 
3 Environnement et liens d’intégration 
D’une manière générale, nous définissons un environnement d’intégration de la manière suivante. 
 
Définition 5 (Environnement d’intégration, définition informelle) : Un environnement 
d’intégration est défini par un ensemble de sources de données et un ensemble de liens 
d’intégration entre les composants simples de toutes ces sources ■ 
 
Ces liens vont permettre de définir le processus d’intégration. Insistons sur le fait que la définition, 
que nous avons faite, d’un environnement d’intégration est indépendante de toute modélisation des 
sources de données. Ces dernières peuvent alors être de catégories différentes et donc hétérogènes. 
Un formalisme pour l’intégration de données hétérogènes 
3.1 Liens d’intégration 
Nous proposons deux catégories de liens, un ensemble SS de relations d’équivalence  et un en-
semble II de relations d’ordre strict. Ces liens permettent de comparer les composants en faisant abs-
traction de tous les critères liés aux schémas des sources, à leurs contraintes, aux données, ainsi que 
toute autre information auxiliaire. Ils permettent également de couvrir la plupart des liens qui peuvent 
exister naturellement entre composants (Doan et al., 2002) (Serafini et al., 2003) (Xu et Embley, 2003) 
(Nassis et al., 2004) (Magnani et al., 2005) (Zerdazi et Lamolle, 2006). Dans notre approche, nous 
n’avons considéré qu’un seul lien S d’équivalence (en faisant allusion à la synonymie) et un seul lien I 
d’ordre strict (rappelant l’inclusion). Ces liens, que nous définissons ci-dessous, sont utilisés dans les 
différentes étapes du processus d’extraction et d’intégration des données.  
 
Définition 6 (Liens d’intégration) : l‘ensemble des liens d’intégration est formé d’une relation S 
d’équivalence sur l’ensemble  C= kD(Ck) et d’une relation I d’ordre stricte sur C ■  
 
Afin d’intégrer  des sources hétérogènes, nous avons à préciser les liens d’intégration. Ceci consiste 
donc à définir une relation d’équivalence et une relation d’ordre sur l’ensemble C = (C1  C2). Dans la 
suite, nous allons décrire ces deux relations dans le cadre de l’application aux données structurées et 
semi-structurées. Elles seront appelées SYNonymie et INClusion  et  seront notées par SYN et  INC, 
respectivement. 
 
Etant données deux BDs définies par : BDi = (Ci, refi, compi), i=1,2. En pratique, c’est l’expert 
(l’administrateur) qui définit ces relations ou tout au moins un « noyau » de ces relations. Nous faisons 
l’abstraction de ce travail d’expert en considérant deux parties SY et IN de CXC vérifiant un certain 
nombre de propriétés de « bons sens ».  
 
Plus précisément, considérons les « noyaux » suivants :  
- Soit  SY   CXC tel que  pour tout (c1, c2)  SY, c1  C1, c2  C2   sont des  composants 
simples, doms
1
(c1)doms
2
(c2), et l’ensemble des contraintes de domaine de c1 est logiquement 
équivalent à l’ensemble des contraintes de domaine de c2. 
- Soit  IN   CXC tel que pour tout (c1, c2)  IN, c1  C1, c2  C2 sont des  composants simples, 
doms
1
(c1)doms
2
(c2), et toute contrainte de l’ensemble des contraintes de domaine de c2 est 
impliquée par l’ensemble des contraintes de domaine de c1. 
 
Etant donnés ces noyaux, donnons, ci-dessous, les deux définitions de synonymie et d’inclusion. 
 
Définition7 (Synonymie) : SYN  est la fermeture de  SY  construite récursivement par les règles  
ci-dessous :    
- pour tout c C ,  c SYN c  et si c1  SY  c2 alors c1  SYN  c2  (base de la récursion)  
- si c1  SYN  c2  alors  c2  SYN  c1  (symétrie), 
- si c1  SYN  c2, et c2  SYN  c3  alors  c1  SYN  c3 (transitivité), 
- si c1  C1  et   c2  C2   sont   composés et |comp1(c1)| = |comp2(c2)|  et il existe une bijec-
tion   b : comp1(c1)  comp2(c2)  telle que   c  SYN b( c ) pour tout c  comp1(c1),  alors c1  
SYN  c2 , 
- SYN est construite seulement par  les clauses ci-dessus ■ 
 
La relation SYN  définie ci-dessus est une relation d’Equivalence (Voir Hamdoun, 2006). 
 
Définition 8 (Inclusion) : INC  est la fermeture de  IN construite récursivement par les règles ci-
dessous :    
S. Hamdoun et al. 
RNTI - X -   
- pour tout c C ,   (c INC c) et si c1 IN c2 alors c1 INC c2  (base de la récursion)  
- si c1  INC  c2,  alors   (c2  INC  c1)  (antisymétrie), 
- si c1  INC  c2, et c2  INC  c3  alors  c1  INC  c3 (transitivité), 
- si c1  C1  et   c2  C2   sont   composés et |comp1(c1)| ≥ |comp2(c2)|  et il existe P1 
Pf(comp1(c1)) et  une bijection b : P1  comp2(c2) telle que  c INC b( c ) pour tout c  P1,  
alors c1 INC  c2 , 
- INC est construite seulement par les clauses ci-dessus ■ 
 
La relation INC  définie ci-dessus est une relation d’ordre strict (Voir Hamdoun, 2006). 
En se basant sur les définitions ci-dessus, on pourra présenter formellement un environnement 
d’intégration. 
3.2 Environnement d’intégration 
Ayant défini informellement un environnement d’intégration comme un ensemble de sources de 
données et un ensemble de liens d’intégration entre les composants simples de ces sources. Nous 
donnons dans la suite sa définition formelle. 
 
Définition 9 (Environnement d’intégration, définition formelle) : Un environnement 
d’intégration est un triplet (E,S,I) où  E ={BDk, k D} est un ensemble de sources de données où 
BDk=(Ck, refk, compk) et D est un ensemble fini dit d’indexage, S est une relation d’équivalence sur 
l’ensemble  C= kD(Ck) et I est une relation d’ordre stricte sur C ■ 
 
Notons que cette définition, comme celles précédemment citées, est indépendante du modèle de 
chaque source. Par conséquent, ces sources peuvent être hétérogènes (modélisées différemment) (cf 
figure 1). 
 
Figure1 : Environnement d’intégration 
 
 
Remarque 2 
Chaque BDk désignant une source différente, nous pouvons supposer que les différents BDk n’ont 
pas d’ingrédients communs. Autrement dit, il n’y a pas de composants de même nom dans deux 
sources différentes. En fait, kD peut être vu comme un nom pour  la source BDk et par conséquent  k 
simule le préfixage des composants de BDk par le nom de la source. 
 
Un formalisme pour l’intégration de données hétérogènes 
Exemple 1 (Environnement d’intégration, Exemple Formel) 
Un exemple d’environnement d’intégration peut être le triplet (E, S, I) tels que : 
- E={BD1, BD2} avec BD1=(C1, ref1, comp1) et BD2=(C2, ref2, comp2). 
- C1={x1, x2, x3, x4, x5, x6}, ref1 =    et comp1(x1)={x2,x3}, comp1(x4)={x5,x6} et comp1 (x) =  
pour tout x{x1,x4} 
- C2={y1, y2, y3, y4, y5, y6, y7, y8, y9, y10}, {y3}ref2{y1} et {y3}ref2{y8} et comp2(y2)={y4,y3},  
comp2(y5)={y1,y6},   comp2(y7)={y8,y9, y10} et comp2(y) =  pour tout y{ y2, y5, y7} 
- x2 S y3 et y3 S x2  et   x S x pour tout  x   C1 C2 
- x3 I y4  
Cet exemple montre que les modèles des sources n’interviennent pas. 
4 Processus d’intégration de données hétérogènes 
Notre approche d’intégration prend en entrée un environnement d’intégration (contenant un en-
semble de SDs hétérogènes de données) et rend, en sortie par exemple, un ED. Ce dernier est constitué 
d’un ensemble de vues sur les données sources. Deux architectures sont possibles grâce au méta-
modèle présenté dans (Badri, 2008). Une architecture classique telles que les modèles en étoiles ou en 
flocons et une architecture originale plate. 
Soit  (E, S, I) un  environnement  d’intégration  où E ={BDk, k D} et  chaque BDk=(Ck, refk, 
compk) est une SD. Notre approche d’intégration est composée principalement de trois étapes : le fil-
trage des composants de l’ED, la génération du schéma global et la construction des vues.  
4.1 Filtrage des composants de l’ED 
Considérons l’ensemble L des composants sélectionnés. Cette étape permet de filtrer l’ensemble L 
en appliquant tout d’abord une opération de décomposition suivie d’une opération d’élimination des 
composants inutiles. L constitue l’ensemble des composants des sources de données qui doivent figurer 
dans l’entrepôt. Le choix de  L  peut être fait par des critères prenant en compte la nature des données 
ou les objectifs de l’intégration. Nous faisons l’abstraction de ce choix en supposant que l’ensemble des 
composants de l’entrepôt est un sous-ensemble de  tous les composants des différentes sources de 
données. Autrement dit : L
kD
(Ck) avec L=kD(Lk)  où  Lk=L  (Ck ). On supposera que L 
n’est pas vide mais cela n’empêche pas que certains des L
k soient vides.  
Les Ck étant disjoints il en est de même pour les Lk . Donc pour tout  x  L il existe un unique kD tel 
que xLk. Dans la suite, nous notons par skl la fonction suivante : skl : L D  x  L, skl(x)=k  
x  Lk. Cette fonction permet d’identifier la source correspondant à un composant de l’entrepôt. 
Tous les composants non simples de L  doivent être remplacés par les sous-composants qui les 
constituent. Nous avons défini comme composant simple tout composant c tel que comp(c)=. Il s’agit 
donc, dans cette étape, de remplacer récursivement tout composant non simple c de L (comp(c)) par 
tous les éléments de comp(c), jusqu’à qu’il n’y ait que des composants simples. 
Soit BD = (C, ref, comp) une source de données. Notons par CS  l’ensemble des composants 
simples. Afin de réaliser la décomposition de l’ensemble L, nous définissons les fonctions  decomp et 
decomp* de la manière suivante. 
 
Définition 10 (Les fonctions decomp et decomp*) : La fonction decomp : C    P(CS) est dé-
finie  récursivement comme suit : decomp(c)  = if  comp(c)  =   then {c}   else  
 c’comp(c)  
 (de-
comp(c’))  
     La fonction decomp* : P( C)     P(CS)  est défini par decomp*(A) = 
 aA
 (decomp(a))  ■ 
 
S. Hamdoun et al. 
RNTI - X -   
Notons par decomp
k
*   la fonction ainsi définie pour la source BD
k
  
decomp(c) rend l’ensemble de tous les composants simples qui ont participé à la construction de c. 
Puisque L=
kD
(Lk)  et LkCk  on a  decompk*(Lk)C
S
k
. Le résultat de la décomposition de 
l’ensemble des composants de l’entrepôt s’obtient donc par L’=
 kD
(decomp
k
* (L
k
)). Notons que L’ 
n’est formé que de composants simples. L’ensemble L’ est le résultat de la décomposition. 
L’ensemble des composants de l’entrepôt est ensuite raffiné en utilisant les deux relations S et I de 
l’environnement retenu. En effet, deux étapes de filtrage sont effectuées sur l’ensemble L selon ces 
relations. L’ordre est important dans la réalisation de ces deux opérations de filtrage. Un premier fil-
trage est réalisé en utilisant la relation d’ordre I. Cette opération consiste à laisser les composants cor-
respondant aux éléments maximaux de la relation d’ordre I. Un deuxième Filtrage est ensuite effectué 
en  utilisant la relation d’équivalence S. L’ est alors filtré en laissant un seul représentant de chaque 
classe d’équivalence de la relation S.  Le choix du représentant est aléatoire et il n’intervient pas dans 
le processus d’intégration. 
L’ensemble L’’ résultat du filtrage est donc formé : L’’L’. L’’ peut être écrit de la manière suivante : 
L’’=kD(L’’k) avec L’’k=L’’ (Lk ).  
 
Exemple 2 (Ensemble Filtré des composants de l’ED)  
Etant donné L, l’ensemble des composants demandés de l’ED : 
L={x1, x5, y1, y2, y7} avec  L1= {x1, x5} et L2= {y1, y2, y7} 
Le résultat de la décomposition est l’ensemble L’={x2, x3, x5, y1, y4, y3, y8, y9, y10}. 
Le filtrage de L’ donne l’ensemble L’’ des composants gardés pour l’entrepôt : 
 L’’={x2, x3, x5, y1, y8, y9, y10}. 
4.2 Génération du schéma global de l’ED hétérogène 
Cette étape permet de spécifier le nombre de vues de l’ED et la structure de ces dernières. Pour tout 
Lk un graphe non orienté Gk est construit à partir de la source BDk . Les nœuds de Gk sont en corres-
pondance biunivoque avec  cLk(compk(c)). Les Arcs de  Gk sont construits de façon qu’il y a un arc 
entre deux nœuds n(c) et n(c’) de Gk si un ensemble de composants de c est relié à un ensemble de 
composants de c’ par le lien ref.  
La  Détection des sous-graphes connexes permet de rassembler les composants de chaque vue. On 
détecte les sous-graphes connexes pour chaque graphe Gk.Le graphe Gk est donc l’union de ses sous 
graphes connexes.  
Soit k  l’ensemble formé de ces sous graphes, à savoir: k={Gki / iTk} où Tk  désigne une in-
dexation pour k. 
Soit T=
kD
 T
k
 et d = |D|. Pour tout u=(u1,…,ud)on considère le graphe Ru formé de l’union de 
tous les Gui (i=1,…,d). Puisque ces graphes n’ont pas de nœuds ni d’arcs en commun, on entend par 
union leur juxtaposition. 
On dénote par R l’ensemble des graphes ainsi obtenus : R={Ru/ u T}.Un schéma de vue Vu est 
associé à chaque  graphe Ru. Vu est composée de l’ensemble de composants simples issus de 
l’intersection de L’’ et Xu. Xu est l’ensemble de tous les composants simples associés aux composants 
relatifs aux nœuds de Ru (les algorithmes sont présentés dans (Hamdoun, 2006). Notons que le nombre 
de vues ainsi crée  est égal à t=|T|. 
 
Exemple 3 (Schéma global de l’ED)  
G1, le graphe associé à BD1 est composé de deux sous-graphes connexes G11 et G12. G2, le graphe 
associé à BD2 est formé d’un seul sous-graphe connexe G21=G2.  R1 (respectivement R2) est le résultat 
de l’union de G11 et G21 (respectivement G12 et G21). 
Un formalisme pour l’intégration de données hétérogènes 
 
Nous obtenons alors deux vues V1 et V2 avec, 
V1={x2, x3, y1, y8, y9, y10} et V2={x5, y1, y8, y9, y10}. 
4.3 Construction des vues alimentant l’entrepôt 
L’étape précédente a permis d’établir le nombre t de vues de l’entrepôt et leurs structures 
(ED={Vi/i[1..t]}). L’algorithme  ConstruitEntrepôt_ETL () de construction revient à appliquer 
ConstruitVue( ) pour chacune des vues. 
Dans la suite nous notons par S’(k,c,m) et I’(k, c, m), avec kD, mD, km et cCk  les ensembles 
suivants : 
- S’(k,c,m)={c’/ c  Cm  et c’ S c}, il s’agit de tous les composants de BDk appartenant à la 
même classe d’équivalence que c.   
- I’(k,c,m)= {c’/ c  Cm  et c’ I c}, il s’agit de tous les composants de BDk qui sont des prédé-
cesseurs de c.   
 
Algorithme ConstruitEntrepôt_ETL () 
Début 
Pour toute V de l’entrepôt faire {ConstruitVue(V)} Finpour 
Fin 
 
Pour toute vue V à construire, l’algorithme ConstruitVue( ) consiste à intégrer des données de dif-
férentes bases afin d’alimenter la vue. Cet algorithme est présenté dans la suite. 
 
Algorithme ConstruitVue (V){ 
Début 
    Pour tout kD faire 
Q :=vue_vide  /* initialisation vue vide */ 
V :=vue_vide   
V0 := (L’k)V     /* V0 est l’ensemble de composants de V appartenant à BDk */  
V’ := V-V0          /* V’ est l’ensemble de composants de V n’appartenant pas  à BDk */ 
 y := V’    /* y est la cardinalité de V’ */ 
Pour tout v’ V’ faire 
 SIv’ := (S’(skl(v’), v’,k)  I’(skl(v’), v’,k)) 
/* SIv’ contient l’ensemble des composants synonymes à v’ dans BDk et l’ensemble 
des composants de  BDk inclus dans v’  */ 
Fin pour 
Pour tout (a1,…,ay)  v’ V’ (SIv’) faire 
Q :=V0  {a1,…,ay} /* Q correspond à une requête d’interrogation de BDk 
,  
il contient l’ensemble des composants à extraire de 
BDk */ 
  Q := Q  (union) Créer_Vue(Q) /* Q contient le résultat partiel de l’interrogation de 
la base BDk */ 
Fin pour 
V := V (union)  Q  
    Fin pour 
Fin} 
 
La procédure Créer_Vue(Q) consiste à exécuter une requête de sélection des différents composants 
figurant dans Q et éventuellement traduire cette requête suivant le modèle de l’entrepôt. Cette procé-
S. Hamdoun et al. 
RNTI - X -   
dure dépend donc de la modélisation adoptée pour la source et le SGBD utilisé. Elle dépend également 
de la modélisation adoptée pour l’entrepôt. Cette dernière est étroitement liée à celles des sources ainsi 
que le domaine d’application. Par exemple, quand les sources sont de catégories différentes et le do-
maine d’application nécessite un échange fréquent de données entre différents systèmes, le modèle 
adopté pour l’entrepôt est le langage XML. 
La procédure Créer_Vue(Q) permet de créer une vue. Des types sont associés aux différents com-
posants de la vue. Ces types sont étroitement liés aux SGBD utilisés.  
 
Exemple 4 (Construction des vues de l’ED) 
Pour la vue V1, le résultat partiel de l’interrogation de BD1 est : 
Q={ x2, x3, CompNull1, CompNull2, CompNull3, CompNull4} 
Pour la source  BD2, le résultat partiel de l’interrogation de BD2 est : 
Q={ CompNull1, CompNull2, y1, y8, y9, y10} 
Pour la vue V2, le résultat partiel de l’interrogation de BD1 est : 
Q={ x5, CompNull1, CompNull2, CompNull3, CompNull4} 
Pour la source  BD2, le résultat partiel de l’interrogation de BD2 est : 
Q={ CompNull1, y1, y8, y9, y10} 
 
Un ensemble de composants fictifs  (de noms CompNulli) est créé afin d’assurer l’Union-
compatibilité entre les requêtes construites dans le cas où SIv’= . Notons également que tous les types 
correspondant à un composant et ceux qui lui sont liés par la relation S (une classe d’équivalence CE) 
sont compatibles. Soit Ty l’ensemble de ces types. Il existe donc, pour chaque classe d’équivalence, un 
type CE, un type t’ tel que  ti Ty, ti
*t’. Dans ce cas, le type associé au représentant choisi est égal à 
t’. De même, tous les types correspondant à un ensemble EI de composants ordonnés (suivant la rela-
tion d’ordre I) de L’ sont compatibles. Soit Typ l’ensemble de ces types. Il existe donc, pour chaque 
ensemble d’éléments ordonnés EI de L’ un type t’ tel que  tiTyp, ti ti
* t’. t’ sera le type associé aux 
composants correspondant aux éléments maximaux de l’ensemble EI.  
5 Conclusion 
L’originalité de notre travail, contrairement aux différents travaux sur l’intégration, réside dans le 
fait de couvrir l’intégration de toutes les catégories de données considérées en même temps. En effet, la 
plupart des travaux dans la littérature ont porté sur l’intégration de données homogènes (Saccol et 
Heuser, 2002) (Magnani et al., 2005). Dans le cas contraire, ils ont essayé de restreindre les données 
hétérogènes de façon à les rendre homogènes et/ou structurées (Kim et Park, 2003) (Beneventano et al., 
2004) (Zerdazi et Lamolle, 2006). 
Il a fallu donc penser à un cadre formel qui pourrait masquer l’hétérogénéité des données. En effet, 
notre approche théorique constitue les premiers pas vers un formalisme de l’intégration de ces der-
nières. L’accent a ainsi été mis sur le fait que les correspondances (liens d’intégration) peuvent se 
faire entre des composants de sources de données de différentes catégories. C’est ce qui constitue le 
point fort de notre démarche.  
Signalons que la relation d’équivalence et la relation d’ordre strict proposées comme liens 
d’intégration couvrent la plupart des liens cités dans la littérature notamment les liens d’inclusion, de 
compatibilité, de disjonction et de similarité. L’originalité de ces définitions de liens réside dans le fait 
qu’ils sont applicables tant sur les structures que sur les données elles-mêmes.  
Dans ce papier, nous avons présenté également l’application de notre approche d’intégration de 
données hétérogènes dans le cadre des données relationnelle-étendues et XML. Nous avons considéré 
la relation de Synonymie comme étant la relation d’équivalence adoptée sur les sources et l’Inclusion 
comme étant la relation d’ordre strict. Ces relations permettent de filtrer l’ensemble des composants de 
l’entrepôt et par la suite de générer son schéma global en fin de construire les vues de l’entrepôt en les 
alimentant par les données des sources.  
Un formalisme pour l’intégration de données hétérogènes 
Un outil HDI (Heterogeneous Data Integration for Data Warehouses) a été développé à l’aide d’un 
prototype en utilisant Oracle et PL/SQL.  
Une généralisation de notre approche formelle pourrait se faire en considérant les liens 
d’intégration dans un environnement d’intégration comme étant un ensemble de relations d’équivalence 
et un ensemble de relations d’ordre sur les composants des sources. Une étude sur la manière de définir 
ces ensembles de relations et les correspondances éventuelles qui pourraient se faire entre eux devrait 
être menée.  
Références 
Badri, M. (2008). Maintenance des entrepôts de données issus de sources hétérogènes. PhD thesis, 
Université  Paris 5. 
Benabdeslem, K., Y. Bennani et E. Janvier (2001). Connectionist Approach for Website visitors Behav-
iors. 
Beneventano, D., S. Bergamaschi, S. Castano, V. D. Antonellis, A. Ferrara, F. Guerra, F. Mandreoli, G. 
C. Ornetti et M. Vincini (2002). Semantic Integration and query optimization of  heterogenous data 
sources. Lecture Notes in Computer Science (LNCS 2426) LNCS 2426, Proceedings of the wor-
shops on advances in Object-Oriented Information Systems (OOIS), pp 154-165. 
Beneventano, D. et S. Bergamaschi (2004). The MOMIS Methodology for Integrating Heterogeneous 
Data Sources. Proceedings of IFIP World Computer Congress, Toulouse France, pp 22-27. 
Bennani, Y. (2006). Apprentissage connexionniste. Edition Hermes Science Publications, ISBN : 
2746213370. 
Cluet, S. et J. Siméon(2000). YATL : a functional and declarative language for XML. Draft 
manuscript. Mai 2000. 
Da Silva, A. S., I.M.R.E. Filha, A. H. F. Laender et D. W. Embley (2002). Representing and querying 
semistructured Web Data Using Nested Tables With structural Variants. Lecture Notes in Com-
puter Science (LNCS 2503), Proceedings of the 21st International Conference on Conceptual Mod-
eling, Tampere, Finlande,), pp 135-151. 
Doan, A., J. Madhavan, P. Domingos et A. Halevy (2002).  Learning to Map between Ontologies on 
the Semantic Web. Proceedings of the World-Wide Web Conference. (WWW-02), pp 662-673.  
Hamdoun, S. (2006). Construction d’entrepôts de données par intégration de sources hétérogènes.  
Thèse présentée à l’université Paris Nord. 
Inmon, B. (1995). Multidimensional Data Bases and Data Warehousing. Data Management Review.  
Kim, H. H. et S. S. Park (2003). Building a Web-enabled Multimedia Data warehouse. Lecture Notes in 
Computer Science (LNCS 2713), proceedings of the Web Communication Technologies and Inter-
net-Related Social Issues (HSI2003), pp 594-600. 
Magnani, M., N. Rizopoulos, P.J. McBrien et D. Montesi (2005). Schema Integration based on Uncer-
tain Semantic Mappings. Lecture Notes in Computer Science (LNCS 3716), Proceedings of 24th 
International Conference on Conceptual Modeling, Klagenfurt, Austria  (ER05), pp 31-46. 
Mining. Proceedings of the International Conference on Computer Systems and Applications, Beirut, 
Lebanon.  
Nassis, V., R. Rajugan , T. S. Dillon  et W. Rahayu (2004). Conceptual Design of XML Document 
Warehouses. Lecture Notes in Computer Science (LNCS 3181), Proceedings of the 6th Interna-
S. Hamdoun et al. 
RNTI - X -   
tional Conference on Data Warehousing and Knowledge Discovery (DaWaK), Zaragoza, Spain, pp 
1-14. 
Pontieri, L., D. Ursino et E. Zumpano (2003). 
An approach for the extensional integration of data sources with heterogeneous representation  
formats. Data & Knowledge Engineering 45, pp 291-331, 2003.    
Prakash, S., S. S. Bhowmick et S. Madria (2006). Efficient recursive XML query processing using 
relational database systems. Data & Knowledge Engineering 58 (2006), pp 263-298. 
Saccol, D. d. B.  et C. A. Heuser (2002). Integration of XML Data. Lecture Notes in Computer Science 
(LNCS 2590), proceedings of the Very Large Data Bases (VLDB) workshop on Efficiency and Ef-
fectiveness of XML Tools and Techniques (EEXTT2002) and of the international Conference on 
Advanced Information System Engineering (CAISE) workshop on Databases in Telecommunica-
tions and Web (DTWeb2002), Revised papers, pp 68-80.  
Serafini, L., P. Bouquet, B. Magnini et S. Zanobini (2003). An algorithm for matching contextualized 
schemas via SAT. Technical Report 0301-06, ITC-irst, Trento, Italie. 
Wang, L., E. A. Rundensteiner et M. Mani (2006). Updating XML views publihed over relational 
databases: Towards the existence of a correct mapping. Data & Knowledge Engineering 58 (2006), 
pp 263-298.  
Xu, L. et D. W. Embley (2003). Discovering Direct and Indirect Matches for Schema Elements. Pro-
ceedings of the Eighth International Conference on Database Systems for Advanced Applications 
table of contents, pp 39.    
Zerdazi, A. et M. Lamolle (2006). Intégration de sources hétérogènes par matching semi-automatique 
de schémas XML étendus. Proceedings of INFORSID, pp 991-1006. 
 
Summary 
 
This work describes the construction of a data warehouse by the integration of heterogeneous data. 
The data sources can be structured, semi-structured or unstructured (relational, object-relational and 
XML databases). We propose a theoretical approach based on an integration environment definition. 
This environment is formed by data sources and inter-schema relationships between these sources 
(equivalence and strict order relations). We consider a data source as a set of components intercon-
nected by compositions and references’ relationships.  
Our approach is composed of three steps allowing data warehouse component filtering, global 
schema generation and construction of data warehouse views.  
 
 
