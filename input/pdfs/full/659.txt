Recherche de sous-structures frÃ©quentes pour lâ€™intÃ©gration
de schÃ©mas XML
Federico Del Razo LÃ³pez, Anne Laurent
Pascal Poncelet; Maguelonne Teisseire
 LIRMM - UniversitÃ© Montpellier II, 161 rue Ada 34392 Montpellier cedex 5
{delrazo,laurent,teisseire}@lirmm.fr
EMA - LGI2P/Site EERIE, Parc Georges Besse 30035 NÃ®mes cedex 1
Pascal.Poncelet@ema.fr
RÃ©sumÃ©. La recherche dâ€™un schÃ©ma mÃ©diateur Ã  partir dâ€™un ensemble de schÃ©-
mas XML est une problÃ©matique actuelle oÃ¹ les rÃ©sultats de recherche issus
de la fouille de donnÃ©es arborescentes peuvent Ãªtre adoptÃ©s. Dans ce contexte,
plusieurs propositions ont Ã©tÃ© rÃ©alisÃ©es mais les mÃ©thodes de reprÃ©sentation des
arborescences sont souvent trop coÃ»teuses pour permettre un vÃ©ritable passage
Ã  lâ€™Ã©chelle. Dans cet article, nous proposons des algorithmes de recherche de
sous-schÃ©mas frÃ©quents basÃ©s sur une mÃ©thode originale de reprÃ©sentation de
schÃ©mas XML. Nous dÃ©crivons briÃ¨vement la structure adoptÃ©e pour ensuite
dÃ©tailler les algorithmes de recherche de sous-arbres frÃ©quents sâ€™appuyant sur
une telle structure. La reprÃ©sentation proposÃ©e et les algorithmes associÃ©s ont
Ã©tÃ© Ã©valuÃ©s sur diffÃ©rentes bases synthÃ©tiques de schÃ©mas XML montrant ainsi
lâ€™intÃ©rÃªt de lâ€™approche proposÃ©e.
1 Introduction
Ã‰tant donnÃ© lâ€™explosion du volume de donnÃ©es disponibles sur Internet, il devient indispen-
sable de proposer de nouvelles approches pour faciliter lâ€™interrogation de ces grandes masses
dâ€™information afin de retrouver les informations souhaitÃ©es. Lâ€™une des conditions sine qua non
pour permettre dâ€™interroger des donnÃ©es hÃ©tÃ©rogÃ¨nes est de disposer dâ€™un (ou de plusieurs)
â€œschÃ©ma gÃ©nÃ©ralâ€ que lâ€™utilisateur pourra interroger et Ã  partir duquel les donnÃ©es sources pour-
ront Ãªtre directement accÃ©dÃ©es. Malheureusement les utilisateurs ne disposent pas de moyen de
connaÃ®tre les modÃ¨les sous-jacents des donnÃ©es quâ€™ils souhaitent accÃ©der et lâ€™un des challenges
dans ce contexte est donc de fournir des outils pour extraire, de maniÃ¨re automatique, ces schÃ©-
mas mÃ©diateurs. Un schÃ©ma mÃ©diateur est alors considÃ©rÃ© comme une interface permettant Ã 
lâ€™utilisateur lâ€™interrogation des sources de donnÃ©es : lâ€™utilisateur pose ses requÃªtes de maniÃ¨re
transparente et nâ€™a pas Ã  tenir compte de lâ€™hÃ©tÃ©rogÃ©nÃ©itÃ© et de la rÃ©partition des donnÃ©es.
XML Ã©tant maintenant prÃ©pondÃ©rant sur Internet, la recherche de moyens dâ€™intÃ©gration
de tels schÃ©mas est un domaine de recherche actif. Si les recherches permettant lâ€™accÃ¨s aux
donnÃ©es, quand un schÃ©ma dâ€™interrogation est connu, sont maintenant bien avancÃ©es (XylÃ¨me,
2001), les recherches concernant la dÃ©finition automatique dâ€™un schÃ©ma mÃ©diateur restent in-
complÃ¨tes et non satisfaisantes (Tranier et al., 2004). Il est alors intÃ©ressant de considÃ©rer les
- 487 - RNTI-E-6
Recherche de sous-structures frÃ©quentes pour lâ€™intÃ©gration de schÃ©mas XML
travaux rÃ©alisÃ©s dans le contexte de la fouille de donnÃ©es afin dâ€™obtenir un schÃ©ma frÃ©quent ou
un ensemble de sous-schÃ©mas frÃ©quents. Ces derniers offrent alors des Ã©lÃ©ments pertinents pour
la construction du schÃ©ma mÃ©diateur. Dans le but de proposer une approche permettant de rÃ©-
pondre Ã  cette derniÃ¨re problÃ©matique, nous nous focalisons sur la recherche de sous-structures
frÃ©quentes au sein dâ€™une base de donnÃ©es de schÃ©mas XML. Une sous-structure frÃ©quente est
un sous-arbre se trouvant dans â€œla plupartâ€ des schÃ©mas XML considÃ©rÃ©s. Cette proportion
est examinÃ©e au sens dâ€™un support qui correspond Ã  un nombre minimal dâ€™arbres de la base
dans lesquels le sous-arbre doit se retrouver pour Ãªtre considÃ©rÃ© comme frÃ©quent. Une telle
recherche est complexe dans la mesure oÃ¹ il est nÃ©cessaire de traduire lâ€™ensemble des schÃ©-
mas en une structure aisÃ©ment manipulable. Cette transformation des donnÃ©es conduit parfois
Ã  doubler ou tripler la taille de la base initiale dÃ¨s lors que lâ€™on souhaite utiliser des propriÃ©tÃ©s
spÃ©cifiques permettant dâ€™amÃ©liorer le processus de fouille. Il nâ€™existe pas de solution efficace
Ã  ce problÃ¨me alliant une reprÃ©sentation compacte Ã  des propriÃ©tÃ©s intÃ©ressantes. Lâ€™objet de
cet article est la dÃ©finition dâ€™une approche de fouille de donnÃ©es de type XML rÃ©pondant Ã  cet
objectif.
Cet article est structurÃ© de la maniÃ¨re suivante : la section 2 introduit les dÃ©finitions des
diffÃ©rentes inclusions dans le contexte des structures hiÃ©rarchiques et propose un aperÃ§u des
principales approches existantes de fouille de donnÃ©es arborescente. Nous prÃ©sentons Ã©gale-
ment en dÃ©tail la problÃ©matique Ã©tudiÃ©e. La section 3 prÃ©sente notre proposition : une mÃ©thode
de recherche de sous-schÃ©mas frÃ©quents utilisant les propriÃ©tÃ©s dâ€™une structure de donnÃ©es
arborescentes compacte et originale. Les diffÃ©rentes expÃ©rimentations menÃ©es sur des bases
de schÃ©mas XML sont dÃ©crites dans la section 4. Enfin, la section 5 conclut et prÃ©sente les
principales perspectives associÃ©es Ã  nos travaux.
2 DÃ©finitions, problÃ©matique et travaux connexes
2.1 DÃ©finitions prÃ©liminaires
Un arbre est un graphe orientÃ©, connexe sans cycle. Il est composÃ© dâ€™un ensemble de nÅ“uds
reliÃ©s par des arcs et il existe un nÅ“ud particulier nommÃ© racine. Il sâ€™agit dâ€™un arbre ordonnÃ©
sâ€™il existe un ordre entre les fils dâ€™un nÅ“ud et dâ€™un arbre non ordonnÃ© sinon.
DÃ©finition 1 Un arbre enracinÃ©, Ã©tiquetÃ© et ordonnÃ© T = (N;B;;L; r;) est tel que : N
est un ensemble fini de nÅ“uds ; B est un ensemble de branches (B  N 2). Chaque branche
b 2 B est un couple ordonnÃ© (u; v) de nÅ“uds oÃ¹ u est le pÃ¨re de v ;  est un ensemble fini
dâ€™Ã©tiquettes ; L est une fonction L : N ! , L(u) = l, fu 2 N; l 2 g ; r est la racine de
T , r 2 N ; et  est une relation dâ€™ordre entre les fils de chaque nÅ“ud interne. La taille de T ,
notÃ©e jT j, est le nombre de nÅ“uds de T .
Lorsque nous manipulerons plusieurs arbres, nous noterons, pour un arbre T ,NT ,BT , LT ,
et T pour N;B;L; r et . De plus, dans la suite de cet article, nous utilisons le mot arbre
pour un un arbre enracinÃ©, Ã©tiquetÃ© et ordonnÃ©.
DÃ©finition 2 (inclusion) Soient S et T deux arbres, nous disons que S est inclu dans un arbre
T notÃ© par S v T , sâ€™il existe une fonction injective :NS ! NT des nÅ“uds de S aux nÅ“uds
de T ,qui vÃ©rifie les conditions suivantes pour tout nÅ“ud u; v 2 NS :
- 488 -RNTI-E-6
Del Razo et al.
1.  prÃ©serve les Ã©tiquettes, LS(u) = LT ((u))
2.  prÃ©serve la relation dâ€™ordre entre frÃ¨res, si u S v alors (u) T (v)
3.  prÃ©serve les relations :
(a) de parentÃ© tel que 8u; v 2 NS , si (u; v) 2 BS alors ((u); (v)) 2 BT , ou
(b) dâ€™ancestralitÃ© tel que 8u; v 2 NS , si (u; v) 2 BS alors ((u); (v)) 2 B+T .
Une inclusion est dite induite si les relations de parentÃ© sont prÃ©servÃ©es. Par ailleurs, si les
relations dâ€™ancestralitÃ© sont respectÃ©es, il sâ€™agit dâ€™une inclusion incrustÃ©e.
a
b c
a a aT3S T1 T2
b c c b b
c
FIG. 1 â€“ Exemple dâ€™arbres pour lâ€™inclusion induite et incrustÃ©e.
Par exemple, considÃ©rons les arbres S, T1, T2, et T3 reprÃ©sentÃ©s dans la figure 1. Si les
relations de parentÃ© sont respectÃ©es, il sâ€™agit dâ€™une inclusion induite, donc S est inclus de
maniÃ¨re induite dans lâ€™arbre T1 (S v T1). Si les relations dâ€™ancestralitÃ© sont conservÃ©es, alors
on trouve une inclusion incrustÃ©e avec S v T1 et S v T3. S nâ€™est pas inclu dans T2 car  ne
prÃ©serve pas lâ€™ordre entre les frÃ¨res.
Dans la suite de cet article, nous considÃ©rons une inclusion de type induite car nous sou-
haitons traiter lâ€™ordre existant entre les nÅ“uds dans la hiÃ©rarchie de faÃ§on directe et lâ€™ordre
entre les nÅ“uds de mÃªme niveau de faÃ§on indirecte. Nous pouvons donc dÃ©finir le support dâ€™un
sous-arbre selon cette inclusion de la maniÃ¨re suivante :
DÃ©finition 3 (support) Soit D une forÃªt dâ€™arbres. Soit S un arbre de D. Soit  un support
minimal spÃ©cifiÃ© par lâ€™utilisateur.
Le support de S est dÃ©fini par Support(S) = P (S)
N
oÃ¹
P (S) est le nombre dâ€™arbres dansD incluant S (inclusion induite) ;
N est le nombre dâ€™arbres dansD.
Si Support(S)   alors lâ€™arbre S est dit frÃ©quent dansD.
2.2 ProblÃ©matique
La problÃ©matique Ã©tudiÃ©e au sein de cet article est la recherche de sous-structures frÃ©-
quentes, i.e. de sous arbres qui apparaissent suffisamment frÃ©quemment dans des documents
XML. Nous considÃ©rons, par la suite, quâ€™une Ã©tape initiale de prÃ©-traitement est rÃ©alisÃ©e sur
les documents XML de maniÃ¨re Ã  ne retenir que leur structure sous forme dâ€™arbre. Nous consi-
dÃ©rons Ã©galement quâ€™Ã  lâ€™issue de cette phase, lâ€™Ã©tiquetage des nÅ“uds est homogÃ¨ne, i.e deux
nÅ“uds de mÃªme Ã©tiquette dans deux arbres diffÃ©rents partagent non seulement la mÃªme syntaxe
mais Ã©galement la mÃªme sÃ©mantique.
Lâ€™objectif consiste alors Ã  rechercher, Ã  partir de la forÃªt dâ€™arbres obtenueD et en fonction
dâ€™un support minimal spÃ©cifiÃ© par lâ€™utilisateur, les sous arbres qui apparaissent suffisamment
frÃ©quemment, i.e. dont leur nombre dâ€™occurrences dans D est supÃ©rieur ou Ã©gal au support
- 489 - RNTI-E-6
Recherche de sous-structures frÃ©quentes pour lâ€™intÃ©gration de schÃ©mas XML
minimal. Pour rÃ©pondre Ã  cette problÃ©matique, nous nous trouvons donc confrontÃ©s aux deux
problÃ¨mes suivants :
1. Quelle structure de reprÃ©sentation efficace utiliser ? IdÃ©alement, Ã©tant donnÃ© que nous
considÃ©rons de grandes quantitÃ©s dâ€™arbres, nous souhaitons avoir une structure qui non
seulement soit efficace en mÃ©moire mais Ã©galement adaptÃ©e aux traitements que nous
souhaitons faire.
2. Comment tester efficacement lâ€™inclusion dâ€™un arbre dans un sous arbre ? Rechercher
lâ€™ensemble des sous arbres frÃ©quents nÃ©cessite de parcourir tous les arbres et dâ€™effectuer
de trÃ¨s nombreuses comparaisons pour rÃ©ussir Ã  extraire des sous parties communes. Il
est donc indispensable de pouvoir trouver rapidement Ã  partir de quel nÅ“ud la compa-
raison peut Ãªtre effectuÃ©e si nous souhaitons amÃ©liorer lâ€™efficacitÃ© de la recherche.
2.3 Les travaux existants
Dans cette partie, nous nous intÃ©ressons non seulement aux approches de recherche mais
nous examinons Ã©galement les mÃ©thodes de reprÃ©sentation des arbres. Les travaux dans le
domaine de la fouille de donnÃ©es arborescentes peuvent Ãªtre distinguÃ©s selon quâ€™ils traitent les
arbres ordonnÃ©s ou non. Nous situant dans le contexte de schÃ©mas XML, il sâ€™avÃ¨re nÃ©cessaire
de traiter lâ€™ordre des Ã©lÃ©ments si celui-ci est spÃ©cifiÃ©. Nous nous focaliserons donc sur des
propositions prenant en charge les arbres ordonnÃ©s.
A notre connaissance, il existe trÃ¨s peu de travaux proposant des mÃ©thodes dâ€™extraction
pour les arbres ordonnÃ©s (Zaki, 2002; Asai et al., 2002). Ainsi Zaki (2002) propose lâ€™algo-
rithme TreeMiner pour extraire des sous-arbres frÃ©quents selon une inclusion incrustÃ©e. Une
reprÃ©sentation originale des arbres facilite la gestion des candidats et offre des performances
intÃ©ressantes. (Asai et al., 2002) traitent Ã©galement de la problÃ©matique des arbres ordonnÃ©s
selon la dÃ©finition de lâ€™inclusion induite. Lâ€™approche proposÃ©e, FREQT, adopte une structure
de reprÃ©sentation du type Â«first-child/next-siblingÂ» comme illustrÃ©e figure 2. Lors du proces-
sus de fouille, pour chaque structure frÃ©quente, FREQT conserve la liste des nÅ“uds les plus
Ã  droite dans les arbres de la base de donnÃ©es supportant cette structure. Nous illustrons ceci
figure 3 oÃ¹ pour le frÃ©quent a, les 6 positions dans la base de donnÃ©es sont stockÃ©es, et pour le
frÃ©quent c   a les 3 positions les plus Ã  droite sont stockÃ©es. Cette information reprÃ©sente les
positions oÃ¹ cette structure est supportÃ©e dans la base.
Si nous examinons plus attentivement la reprÃ©sentation verticale adoptÃ©e dans TreeMiner,
elle aboutit en fait Ã  stocker trois fois la taille dâ€™un arbre, i.e. 3jT j. De la mÃªme maniÃ¨re la
structure utilisÃ©e dans FREQT offre des performances attractives, mais cette reprÃ©sentation
conduit Ã©galement Ã  tripler la taille de la base afin de stocker les informations nÃ©cessaires.
MÃªme si elles nâ€™abordent pas la mÃªme problÃ©matique, des approches de reprÃ©sentation
efficaces des arbres en 2jT j ont Ã©tÃ© rÃ©cemment proposÃ©es (Wang et al., 2004; Chi et al., 2004,
2003). Cependant, outre le fait quâ€™elles ne considÃ¨rent pas la notion dâ€™ordre, elles nâ€™utilisent
pas des propriÃ©tÃ©s aussi intÃ©ressantes que les travaux prÃ©cÃ©dents afin dâ€™amÃ©liorer le processus
dâ€™extraction.
Notre objectif est donc de permettre une recherche de sous-arbres ordonnÃ©s mais, contrai-
rement aux approches existantes dans ce contexte, dâ€™utiliser une reprÃ©sentation peu coÃ»teuse
en mÃ©moire, i.e. en 2jT j. Cette structure doit en outre possÃ©der des propriÃ©tÃ©s intÃ©ressantes
- 490 -RNTI-E-6
Del Razo et al.
ReprÃ©sentation "first child âˆ’ next sibling" de  T
b a c aa
2 3 410
1 2 3
4next
first
lb
T
a
b a
c
a
T
0
1
2
3
4
FIG. 2 â€“ FREQT : reprÃ©sentation dâ€™un arbre.
b
c
a
c b b
c
c
a
c
b
7
8
9
10
11
12
b
c a b
a
14
15
16 17
13
a
c
a c
c
22
2120
19
18
4T3T1T
a
F1
b
c
(p=0, l=a)
c
a
F2
...
...
{4, 11, 20}
c
a
c {5, 12}
F3
...
...
{4, 11, 13, 16, 18, 20}
{3, 6, 7, 9, 15, 17}
{2, 5, 8 ,10, 12, 14, 19, 21, 22}
(p=0, l=c)
min_supp = 0.5
2
3 4
5 6
D
2T
FIG. 3 â€“ FREQT : stockage de la liste des positions des frÃ©quents.
pour amÃ©liorer le processus dâ€™extraction. Câ€™est dans ce contexte que se situe notre proposition
RSF dÃ©crite Ã  la section 3.
3 Proposition
Dans cette section, nous proposons de nouveaux algorithmes permettant lâ€™extraction effi-
cace de sous-arbres frÃ©quents ordonnÃ©s au sein dâ€™une base de donnÃ©es arborescentes. Dans un
premier temps, nous dÃ©crivons la structure adoptÃ©e et nous en soulignons ses intÃ©rÃªts. Dans
un second temps, nous proposons un survol de notre approche dâ€™extraction et nous montrons
comment les propriÃ©tÃ©s de la structure sont utilisÃ©es pour amÃ©liorer le processus de fouille.
Finalement, nous dÃ©crivons plus formellement les algorithmes proposÃ©s.
Pour illustrer nos propos, nous utiliserons la base dâ€™arbres de la figure 4.
3.1 ReprÃ©sentation des arbres
Pour reprÃ©senter les diffÃ©rents arbres manipulÃ©s au sein de notre approche, nous adoptons
la reprÃ©sentation proposÃ©e dans (Del Razo et al., 2005). Un arbre est ainsi dÃ©crit Ã  lâ€™aide de
deux vecteurs comme proposÃ© dans Weiss (1998). Le premier, nommÃ© st, conserve la position
du pÃ¨re de chaque nÅ“ud. Les nÅ“uds de lâ€™arbre sont numÃ©rotÃ©s en profondeur dâ€™abord. La
racine de T correspond Ã  lâ€™index 0 et a pour valeur s[0] =  1 pour indiquer que la racine nâ€™a
- 491 - RNTI-E-6
Recherche de sous-structures frÃ©quentes pour lâ€™intÃ©gration de schÃ©mas XML
c
e
c
b
b
b e
d
T2 T3T1
a
4
0
1
2
3
5
7
6
a
b a
c
a
0
1
2
3
4
4
1 4 5
a
0
1 4 5
b b c
a
bc
FIG. 4 â€“ La forÃªt dâ€™arbres exemple.
1
a c aa
2 3 410
âˆ’1 0 1 2 0
racine
plus Ã  droite
structure (st)
Ã©tiquettes (lb)
feuille la
(âˆ’1)
a
b a
c
a
0
1
2
3
4
T
b
FIG. 5 â€“ RFS : reprÃ©sentation dâ€™un arbre.
pas de pÃ¨re. Les valeurs st[i]; i = 0; 2; :::; k 1 correspondent aux positions du pÃ¨re des nÅ“uds
i, comme illustrÃ© figure 5.
Cette reprÃ©sentation permet de retrouver en temps constant le pÃ¨re dâ€™un nÅ“ud. De plus,
elle permet la localisation directe de la feuille la plus Ã  droite par rapport Ã  lâ€™index k. En
parcourant lâ€™arbre, il est ainsi possible dâ€™obtenir toutes les relations directes pÃ¨re-fils entre
nÅ“uds. Le deuxiÃ¨me vecteur, nommÃ© lb, est utilisÃ© pour enregistrer les Ã©tiquettes de lâ€™arbre
avec lb[i]; i = 0; 2; :::; k   1 reprÃ©sentant lâ€™Ã©tiquette de chaque nÅ“ud ni 2 T .
La structure adoptÃ©e permet une reprÃ©sentation des arbres peu coÃ»teuse puisquâ€™elle se rÃ©-
duit Ã  2jT j. De plus elle possÃ¨de des propriÃ©tÃ©s intÃ©ressantes, Ã©voquÃ©es au paragraphe suivant,
pouvant Ãªtre utilisÃ©es lors de la recherche de sous-structures frÃ©quentes.
3.2 AperÃ§u gÃ©nÃ©ral
Notre proposition est basÃ©e sur une approche classique de type Â«gÃ©nÃ©rer-Ã©laguerÂ», i.e. Ã 
chaque Ã©tape, nous gÃ©nÃ©rons diffÃ©rents candidats et nous testons si ceux-ci sont inclus dans
la bases dâ€™arbres. Lâ€™inclusion dans notre cas est bien entendu dÃ©finie comme Ã©tant de type
Â«induitÂ».
La mÃ©thode de reprÃ©sentation des arbres que nous proposons permet de gÃ©nÃ©rer de maniÃ¨re
efficace les sous-arbres candidats puis dâ€™Ã©laguer les sous-arbres non frÃ©quents (aprÃ¨s calcul du
support).
st
lb
0 1 2 3 4 5 6 7
c b a b d
âˆ’1âˆ’1 âˆ’1 1 âˆ’1 3 4 4
b
6
7
d
F1={a, b, c ,d}
T2
a
3
4
5
0
c
b
b
b
(âˆ’1)
(âˆ’1)
a
1 3
2
5 6
7
0
e
c
b
b
b e
d
T2
4
FIG. 6 â€“ Transformation dâ€™un arbre de la base aprÃ¨s gÃ©nÃ©ration de F1.
ConsidÃ©rons Ã  prÃ©sent comment les candidats sont gÃ©nÃ©rÃ©s. Les candidats de taille 1 sont
tout dâ€™abord obtenus en parcourant tous les nÅ“uds des arbres de la base de donnÃ©es. Chaque
nÅ“ud voit son support incrÃ©mentÃ© lors de ce parcours et seuls sont conservÃ©s les nÅ“uds dont le
- 492 -RNTI-E-6
Del Razo et al.
support est supÃ©rieur au support minimal dÃ©fini par lâ€™utilisateur. La base de donnÃ©es est alors
transformÃ©e pour ne conserver que les nÅ“uds frÃ©quents, comme illustrÃ© par la figure 6.
0
1
2 3
âˆ’1 0 1 1
0 1 2 3
 
 

0
1
2
4
3
a) b)



0
1
2
3 4


0
1
2
4
3
c)
âˆ’1 0 1 1
0 1 2 3
3
4
âˆ’1 0 1 1
0 1 2 3
1
4
âˆ’1 0 1 1
0 1 2 3
0
4
branche la 
plus Ã  droite
FIG. 7 â€“ GÃ©nÃ©ration des candidats.
Les candidats de taille 2 sont gÃ©nÃ©rÃ©s en combinant deux Ã  deux tous les frÃ©quents de taille
1. La gÃ©nÃ©ration des candidats de taille k  3 sâ€™effectue de la mÃªme maniÃ¨re que dans les ap-
proches classiques de type Apriori (Agrawal et Srikant, 1994), par combinaison des frÃ©quents
de taille k 1. Nous adoptons la stratÃ©gie de gÃ©nÃ©ration de candidats selon la branche la plus Ã 
droite comme proposÃ©e dans (Asai et al., 2002; Zaki, 2002) et illustrÃ©e figure 7. Nous pouvons
ainsi constater lâ€™intÃ©rÃªt de notre structure de reprÃ©sentation puisque, naturellement, il suffit
dâ€™ajouter un nouvel Ã©lÃ©ment dans la reprÃ©sentation de lâ€™arbre en spÃ©cifiant le pÃ¨re du nouveau
nÅ“ud.
Le calcul du support de chaque candidat consiste Ã  compter le nombre dâ€™arbres de la base
qui contiennent ce sous-arbre candidat. Ainsi pour chaque arbre de la base, nous recherchons
les points dâ€™ancrage sur lesquels la racine du sous-arbre Ã  tester peut sâ€™instancier. Ces points
correspondent en fait aux nÅ“uds dans lâ€™arbre qui correspondent Ã  la racine de lâ€™arbre Ã  tester.
Pour chaque point dâ€™ancrage trouvÃ©, on cherche alors Ã  instancier lâ€™ensemble des nÅ“uds de
lâ€™arbre candidat au sein de lâ€™arbre courant testÃ©, i.e. les fils du nÅ“ud Ã  tester. Notons que dans
le cas dâ€™une inclusion induite, nous recherchons une instanciation exacte du candidat au sein
des arbres de la base. Si tous les nÅ“uds du candidat ont Ã©tÃ© trouvÃ©s, lâ€™arbre supporte le candidat
et le support de la structure candidate est alors incrÃ©mentÃ©.
3.3 Les algorithmes
Lâ€™algorithme RFS (Algorithme 1) fonctionne de la maniÃ¨re suivante : un premier parcours
sur la base est rÃ©alisÃ© pour extraire les items dont le nombre dâ€™occurrences est supÃ©rieur au sup-
port minimal. Ces items constituent des arbres rÃ©sumÃ©s Ã  une seule racine, lâ€™item considÃ©rÃ©.
Nous obtenons ainsi lâ€™ensemble F1 des arbres frÃ©quents de taille 1. Ces derniers sont combinÃ©s
entre eux pour former des candidats de taille 2 et un parcours sur la base permet dâ€™obtenir lâ€™en-
semble F2 constituÃ© des arbres de taille 2. Lâ€™algorithme se poursuit en gÃ©nÃ©rant des candidats
de taille k+1 et en effectuant un parcours sur la base pour compter le nombre dâ€™occurrences de
chaque candidats. Lorsque plus aucun candidat ne peut Ãªtre gÃ©nÃ©rÃ© lâ€™algorithme se termine.
Lâ€™algorithme GenCandidats(Fk 1) (Algorithme 2) dÃ©crit la gÃ©nÃ©ration des candidats qui
utilise la branche la plus Ã  droite des sous-arbres frÃ©quents de taille k   1 afin de proposer
des candidats de taille k. Pour chaque arbre frÃ©quent de taille k   1, il gÃ©nÃ¨re un nouveau
candidat en Ã©tendant lâ€™arbre par la branche la plus Ã  droite. Cette gÃ©nÃ©ration est obtenue par
lâ€™intermÃ©diaire de la fonction Bpd. Ainsi, pour chaque nÅ“ud, nous lui ajoutons les seules
extensions possibles, i.e. celles qui sâ€™avÃ¨rent frÃ©quentes dans F2.
- 493 - RNTI-E-6
Recherche de sous-structures frÃ©quentes pour lâ€™intÃ©gration de schÃ©mas XML
EntrÃ©e : D = {T1,T2,..,Tn} base de
donnÃ©es dâ€™arbres ;  le sup-
port minimal.
Sortie : F sous-arbres frÃ©quents.
F1  arbres frÃ©quents de taille 1;
F2  arbres frÃ©quents de taille 2;
F  F1 [ F2;
pour (k = 3;Fk 1 6= ;; k++) faire
Ck  GenCandidats(Fk 1);
pour chaque C 2 Ck faire
si Support(C)   alors
Fk  Fk [ C;
F  F [ Fk;
retourner F ;
Algorithme 1: RSF(D, ).
EntrÃ©e : Fk 1 des (k 1)-sous-arbres
frÃ©quents.
Sortie : Ck des (k)-sous-arbres candi-
dats.
Ck  0;
pour chaque f 2 Fk 1 faire
pour chaque nÅ“ud n 2 Bpd(f)
faire
pour chaque < x; y >2 F2
faire
si L(n) = L(x) alors
tmp f+ < n; y >;
Ck = Ck + tmp;
retourner Ck;
Algorithme 2: GenCandidats(Fk 1).
EntrÃ©e : C candidat.
Sortie : Support du candidat C.
cnt 0;
pour chaque T 2 D faire
trv  faux;
pour (i = 0; i < (jT j   jCj) &&
:trv; + + i) faire
si (L(rc) = L(T [i])) alors
trv  Ancre(C; T; i);
si trv alors
++ cnt;
sup = cnt
jDj
;
retourner sup
Algorithme 3: Support(C).
EntrÃ©e : C candidat , T un arbre, i in-
dex de la racine de lâ€™ancrage.
Sortie : vrai si T supporte C.
nbnÅ“uds 1 ;
Nniv_act  NÅ“udsNivSuiv(C; ;);
while (jNniv_actj! = ; &&
:Poursuit(Nniv_act; T; nbnÅ“uds))
do
Nniv_act  
NÅ“udsNivSuiv(C;Nniv_act);
si (nbnÅ“uds = jCj) alors retourner
vrai;
sinon retourner faux;
Algorithme 4: Ancre(C; T; i).
Le calcul du support de chaque candidat consiste Ã  compter le nombre dâ€™arbres de la base
qui contiennent ce sous-arbre candidat.
Pour chaque arbre de la base, une recherche est effectuÃ©e pour voir sâ€™il existe des points
dâ€™ancrage sur lesquels la racine du sous-arbre Ã  tester peut sâ€™instancier (appel Ã  lâ€™algorithme
Ancre). Si un sous-arbre existe son nombre dâ€™occurrences est alors incrÃ©mentÃ© et son support
est retournÃ©.
ConsidÃ©rons lâ€™algorithme de gestion des points dâ€™ancrage (Algorithme 4). Pour chaque
point dâ€™ancrage trouvÃ©, i.e. pour chaque nÅ“ud du sous arbre candidat c qui possÃ¨de le mÃªme
- 494 -RNTI-E-6
Del Razo et al.
label dans lâ€™arbre T , on cherche Ã  instancier lâ€™ensemble des nÅ“uds de lâ€™arbre candidat au
sein de lâ€™arbre couramment testÃ© T . En dâ€™autres termes, nous souhaitons projeter le sous-arbre
candidat c dans lâ€™arbre T . Ceci est rÃ©alisÃ© par lâ€™intermÃ©diaire des algorithmes Ancre et Poursuit
(cf. algorithmes 4 et 5).
Lâ€™algorithme Poursuit est utilisÃ© pour chercher une instanciation exacte du candidat au sein
des arbres de la base. Si tous les nÅ“uds du candidat ont Ã©tÃ© trouvÃ©s, lâ€™algorithme retourne alors
la valeur V RAI (lâ€™arbre supporte le candidat). Il retourne la valeur FAUX si tous les nÅ“uds
de lâ€™arbre ont Ã©tÃ© parcourus sans trouver lâ€™ensemble des nÅ“uds du candidat.
Algorithme : Poursuit(Nniv_act; T; nbnÅ“uds))
EntrÃ©e : Nniv_act ensemble de nÅ“uds Ã  trouver ; T lâ€™arbre ; nbnÅ“uds le nombre de
nÅ“uds vÃ©rifiÃ©s.
Sortie : vrai si tous les nÅ“uds deNniv_act ont Ã©tÃ© trouvÃ©s.
pour chaque n 2 Nniv_act faire
si (L(n) = L((n)) && Pere(n) = Pere((n))) alors
++nbnÅ“uds;
si (nbnÅ“uds= jNniv_actj) alors retourner vrai;
sinon retourner faux;
Algorithme 5: Poursuite de la recherche.
4 ExpÃ©rimentations
Nos expÃ©rimentations ont Ã©tÃ© rÃ©alisÃ©es avec un PC Pentium ayant 512 Mo RAM sous le
systÃ¨me Linux 2.4. Les programmes ont Ã©tÃ© dÃ©veloppÃ©s en C++ et compilÃ©s avec gcc 3.2.2.
Nous avons utilisÃ© 6 bases de donnÃ©es construites en employant le programme de gÃ©nÃ©ra-
tion dâ€™arbres XML proposÃ© par (Termier et al., 2002). Ce programme propose diffÃ©rents pa-
ramÃ¨tres pour spÃ©cifier le nombre dâ€™arbres Ã  gÃ©nÃ©rer, leur profondeur, le nombre dâ€™Ã©tiquettes
maximales. Les diffÃ©rentes valeurs utilisÃ©es pour les gÃ©nÃ©rations lors de nos expÃ©rimentations
sont indiquÃ©es dans le tableau 1.
ParamÃ¨tres Valeurs
Nombre dâ€™arbres Ã  gÃ©nÃ©rer (x 1000) 10, 40, 70, 100, 130, 150
Profondeur maximal dâ€™un arbre 5
Nombre maximal de branches par nÅ“ud 5
Nombre maximal dâ€™Ã©tiquettes 50
Arbres frÃ©quents semÃ©s dans la base gÃ©nÃ©rÃ©e 10
ProbabilitÃ© quâ€™un nÅ“ud soit pÃ¨re 0.4
TAB. 1 â€“ ParamÃ¨tres pour la construction de la base de donnÃ©es synthÃ©tiques.
- 495 - RNTI-E-6
Recherche de sous-structures frÃ©quentes pour lâ€™intÃ©gration de schÃ©mas XML
Nous avons souhaitÃ© Ã©valuer notre proposition selon deux aspects : temps de rÃ©ponse et
occupation mÃ©moire. En effet, nous argumentons notre proposition comme Ã©tant plus efficace
pour un rÃ©el passage Ã  lâ€™Ã©chelle mais ceci nâ€™est pas toujours synonyme dâ€™efficacitÃ© en temps
de rÃ©ponse. En fait, les expÃ©rimentations rÃ©alisÃ©es prouvent que notre proposition rÃ©pond aux
deux critÃ¨res.
Pour Ã©valuer les performances sur les temps dâ€™exÃ©cution, nous nous sommes comparÃ©s Ã 
lâ€™algorithme FREQT-nodd sans dÃ©tection des duplicats de (Asai et al., 2002) permettant de
rechercher des inclusions induites puis Ã  une optimisation de celui-ci FREQT-dd limitant le
parcours dans les arbres lors de la vÃ©rification des candidats.
La figure 8-(a) reprÃ©sente lâ€™occupationmÃ©moire utilisÃ©e pour la reprÃ©sentation de la base de
schÃ©mas XML. Comme nous nous y attendions RSF occupemoins dâ€™espace mÃ©moire puisquâ€™il
adopte une structure de reprÃ©sentation plus rÃ©duite que FREQT-nodd et FREQT-dd. Ces deux
derniers adoptent la mÃªme structure.
Les figures 8-(b,c,d) indiquent les temps dâ€™exÃ©cution obtenus par FREQT-nodd et RSF
pour diffÃ©rents supports et diffÃ©rentes tailles de la base de schÃ©mas. Nous pouvons constater
que RSF obtient dans tous les cas de meilleurs rÃ©sultats.
 1
 10
 100
 0  20  40  60  80  100  120  140  160
M
Ã©m
oi
re
 e
m
pl
oy
Ã©e
 (M
o)
Taille de la base de donnÃ©es (x1000)
FREQTâˆ’dd
RSF
(a)min_sup = 0:1
 1
 10
 100
 1000
 10000
 100000
 0  20  40  60  80  100  120  140  160
Te
m
ps
 d
â€™e
xÃ©
cu
tio
n 
(se
cs
)
Taille de la base de donnÃ©es (x1000)
FREQTâˆ’nodd
RSF
(b)min_sup = 0:05
 1
 10
 100
 1000
 10000
 100000
 0  20  40  60  80  100  120  140  160
Te
m
ps
 d
â€™e
xÃ©
cu
tio
n 
(se
cs
)
Taille de la base de donnÃ©es (x1000)
FREQTâˆ’nodd
RSF
(c)min_sup = 0:1
 0.1
 1
 10
 100
 1000
 10000
 0  20  40  60  80  100  120  140  160
Te
m
ps
 d
â€™e
xÃ©
cu
tio
n 
(se
cs
)
Taille de la base de donnÃ©es (x1000)
FREQTâˆ’nodd
RSF
(d)min_sup = 0:5
FIG. 8 â€“ Temps dâ€™exÃ©cution par rapport Ã  la taille de la base, FREQT-nodd et RSF.
En analysant les rÃ©sultats indiquÃ©s par la figure 9 comparant FREQT-nodd, FREQT-dd et
RSF, il sâ€™avÃ¨re que les temps dâ€™exÃ©cution sont nettement amÃ©liorÃ©s pour FREQT-dd. Le gain
obtenu en terme dâ€™espace mÃ©moire de RSF est donc Ã  comparer avec les temps dâ€™exÃ©cution ob-
- 496 -RNTI-E-6
Del Razo et al.
tenus Ã  lâ€™aide dâ€™une optimisation basÃ©e sur le stockage dâ€™informations supplÃ©mentaires comme
indiquÃ© au paragraphe 2.3.
Nous souhaitons Ã  prÃ©sent mettre en Å“uvre une optimisation de parcours de la structure
proposÃ©e afin dâ€™amÃ©liorer les performances en terme de temps dâ€™exÃ©cution. Une telle optimi-
sation est tout Ã  fait rÃ©alisable et constitue lâ€™une de nos perspectives principales. Nous devrions
alors obtenir des performances supÃ©rieures Ã  celles obtenues pour FREQT-dd tout en conser-
vant une structure en 2jT j.
 0.1
 1
 10
 100
 1000
 10000
 100000
 0  20  40  60  80  100  120  140  160
Te
m
ps
 d
â€™e
xÃ©
cu
tio
n 
(se
cs
)
Taille de la base de donnÃ©es (x1000)
FREQTâˆ’nodd
RSF
FREQTâˆ’dd
(a)min_sup = 0:05
 0.1
 1
 10
 100
 1000
 10000
 0  20  40  60  80  100  120  140  160
Te
m
ps
 d
â€™e
xÃ©
cu
tio
n 
(se
cs
)
Taille de la base de donnÃ©es (x1000)
FREQTâˆ’nodd
RSF
FREQTâˆ’dd
(b)min_sup = 0:5
FIG. 9 â€“ MÃ©moire et Temps dâ€™exÃ©cution FREQT-nodd, RSF, et FREQT-dd.
5 Conclusion et perspectives
Dans cet article, nous proposons une approche efficace dâ€™extraction de sous-arbres frÃ©-
quents. RSF est la premiÃ¨re proposition de recherche de sous-arbres frÃ©quents selon une in-
clusion induite Ã  lâ€™aide dâ€™une reprÃ©sentation de la base de schÃ©mas en 2jT j. Les premiÃ¨res
expÃ©rimentations rÃ©alisÃ©es sur des donnÃ©es synthÃ©tiques soulignent lâ€™intÃ©rÃªt de notre propo-
sition par rapport aux approches de rÃ©fÃ©rence. Les perspectives immÃ©diates concernant RSF
suivent deux axes :
â€“ Tout dâ€™abord, il est possible dâ€™amÃ©liorer lâ€™algorithme en optimisant les parcours rÃ©alisÃ©s
lors de la vÃ©rification des candidats comme proposÃ© dans lâ€™optimisation de FREQT (Asai
et al., 2002). Toutefois, nous souhaitons mettre en place un procÃ©dÃ© moins coÃ»teux en
terme dâ€™espace mÃ©moire.
â€“ Ensuite, nous souhaitons utiliser la mÃªme structure de reprÃ©sentation des arbres pour
rÃ©aliser une recherche de sous-arbres frÃ©quents en se basant sur une inclusion incrustÃ©e.
Ces travaux ont pour objectif dâ€™Ãªtre utilisÃ©s dans le cadre de la mÃ©diation de donnÃ©es, les
sous-arbres frÃ©quents extraits servant de support Ã  la construction automatique dâ€™un schÃ©ma
mÃ©diateur. Une telle solution peut Ã©galement Ãªtre adoptÃ©e dans le cadre de la fouille de don-
nÃ©es en ligne (data streams) pour le traitement Ã  la volÃ©e de donnÃ©es XML. Cette perspective
permettra de traiter les gros volumes de donnÃ©es transitant sur Internet de maniÃ¨re efficace et
rapide.
- 497 - RNTI-E-6
Recherche de sous-structures frÃ©quentes pour lâ€™intÃ©gration de schÃ©mas XML
RÃ©fÃ©rences
Agrawal, R. et R. Srikant (septembre 1994). Fast algorithms for mining association rules in
large databases. In Proceedings of the 20th VLDB Conference (VLDB 02), Santiago, Chile,
pp. 487â€“499.
Asai, T., K. Abe, S. Kawasoe, H. Arimura, et H. Sakamoto (2002). Efficient substructure dis-
covery from large semi-structured data. In Proceedings of the 2nd Annual SIAM Symposium
on Data Mining, (SDM 02), Arlington, VA, USA, pp. 158â€“174.
Chi, Y., Y. Yang, et R. Muntz (2003). Indexing and mining free trees. In Proceedings of the
International Conference on Data Mining (ICDM 2003), Florida, USA, pp. 509â€“512.
Chi, Y., Y. Yang, et R. Muntz (2004). CMTreeMiner : Mining both closed and maximal
frequent subtrees. In Proceedings of the Eighth Pacific-Asia Conference on Knowledge
Discovery and Data Mining (PAKDD 04), Sydney, Australia, pp. 63â€“73.
Del Razo, F., A. Laurent, et M. Teisseire (2005). ReprÃ©sentation efficace des arborescences
pour la recherche des sous-structures frÃ©quentes. In Actes de lâ€™atelier Fouille de donnÃ©es
complexes, ConfÃ©rence Extraction et Gestion des Connaissances (EGC 2005), pp. 113â€“120.
Termier, A., M.-C. Rousset, et M. Sebag (2002). TreeFinder, a first step towards xml data
mining. In Proceedings of the IEEE Conference on Data Mining (ICDM 02), pp. 450â€“457.
Tranier, J., R. Baraer, Z. Bellahsene, et M. Teisseire (July, 7th - 9th 2004). Whereâ€™s Char-
lie : family based heuristics for peer-to-peer schema integration. In Proceedings of the 8th
International Database Engineering and Applications Symposium (IDEAS 04), Coimbra,
Portugal, pp. 227â€“235.
Wang, C., Q. Yuan, H. Zhou,W. Wang, et B. Shi (May 2004). Chopper : An efficient algorithm
for tree mining. Journal of Computer Science and Technology 19, 309â€“319.
Weiss, M. A. (1998). Data Structures And Algorithm Analysis In C.
XylÃ¨me, L. (2001). A dynamic warehouse for XML data of the Web. IEEE Data Engineering
Bulletin 24(2), 40â€“47.
Zaki, M. (2002). Efficiently mining frequent trees in a forest. In Proceedings of the
SIGKDDâ€™02 Conference, Edmonton, Alberta, Canada, pp. 71â€“80.
Summary
The research of a mediator schema from XML schemas is a current problem where the
results stemming from the mining of tree databases can be adopted. In this context, several
propositions were proposed but the methods of representation of tree databases are often very
memory-consuming when querying huge volumes of data. In this paper, we propose an algo-
rithm of research of frequent sub-structures based on an original method of representation of
XML schemas. We describe the structure adopted and the algorithms of research for frequent
sub-trees leaning on such structure.
- 498 -RNTI-E-6
