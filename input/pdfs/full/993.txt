ParAdmin: Un Outil dâ€™Assistance Ã  lâ€™Administration et
Tuning dâ€™un EntrepÃ´t de DonnÃ©es
Ladjel Bellatreche âˆ—, Kamel Boukhalfa âˆ—, Sybille Caffiau âˆ— âˆ—âˆ—
âˆ— LISI/ENSMA - UniversitÃ© de Poitiers - Futuroscope
(bellatreche, boukhalk, caffiaus)@ensma.fr,
âˆ—âˆ— INRIA Domaine de Volucean, Rocquencourt
RÃ©sumÃ©. Les entrepÃ´ts de donnÃ©es ont rendu les tÃ¢ches dâ€™administration et de
tuning plus complexes que dans les bases de donnÃ©es traditionnelles. Cela est
dÃ» aux caractÃ©ristiques des entrepÃ´ts de donnÃ©es : la volumÃ©trie, les requÃªtes
complexes, les dÃ©lais de rÃ©ponse exigÃ©s par les dÃ©cideurs et la gestion de lâ€™Ã©vo-
lution. Dans ce contexte, une panoplie de techniques dâ€™optimisation ont Ã©tÃ© pro-
posÃ©es durant la phase de conception physique. Pour chacune dâ€™entre elles un
nombre important dâ€™algorithmes de sÃ©lection existe, chacun ayant ses propres
paramÃ¨tres. Un autre choix dÃ©terminant est Ã  faire entre les techniques dâ€™optimi-
sation similaires - pour optimiser une requÃªte donnÃ©e, deux techniques peuvent
Ãªtre candidates. Durant la tÃ¢che de conception physique, lâ€™administrateur doit
donc effectuer de multiple choix. Dans ce papier, nous montrons dâ€™abord les
difficultÃ©s quâ€™un administrateur peut rencontrer durant la phase de conception
physique. DeuxiÃ¨mement, nous prÃ©sentons une mÃ©thode de tuning basÃ©e sur la
fragmentation horizontale et les index de jointure binaires. Finalement, nous pro-
posons un outil dâ€™administration, appelÃ© ParAdmin, qui permet dâ€™assister lâ€™ad-
ministrateur en proposant la rÃ©alisation interactive des tÃ¢ches de conception phy-
sique et de tuning. Elles sont dÃ©finies Ã  lâ€™aide des choix: de la ou des structures
dâ€™optimisation, des algorithmes de sÃ©lection, des paramÃ¨tres, de tuner ou non et
de visualiser les recommandations de performance.
1 Introduction
Les entrepÃ´ts de donnÃ©es ont largement contribuÃ© Ã  lâ€™Ã©volution de la conception physique
traditionnelle dÃ©diÃ©e aux applications de type OLTP, oÃ¹ la tÃ¢che dâ€™un administrateur Ã©tait
concentrÃ©e sur la gestion des utilisateurs et dâ€™un nombre restreint de techniques dâ€™optimisa-
tion (les index, les diffÃ©rentes implÃ©mentations de jointure - boucles imbriquÃ©es, sort merge,
hash, etc.). Lâ€™apparition des entrepÃ´ts de donnÃ©es a rendu la tÃ¢che dâ€™administration de plus
en plus complexe. Cette complexitÃ© est due Ã  leurs caractÃ©ristiques. Lâ€™une dâ€™entre elles est le
volume de donnÃ©es. Par exemple, le schÃ©ma en Ã©toile de lâ€™entrepÃ´t de donnÃ©es relationnel de
la compagnie General Motors Corporation dÃ©passe 1.5 tÃ©raoctets et la table des faits a plus
de deux milliard dâ€™instances (Gill, 2000). De plus, les requÃªtes dÃ©cisionnelles sont complexes
car elles contiennent des jointures, des sÃ©lections et des agrÃ©gations. De mÃªme, il est impÃ©ra-
tif dâ€™exÃ©cuter ces requÃªtes en un temps raisonnable. Enfin, les entrepÃ´ts de donnÃ©es Ã©voluent
ParAdmin: Outil dâ€™Assistance Ã  lâ€™Administration
constamment. Cette Ã©volution concerne Ã  la fois les requÃªtes dÃ©cisionnelles, le schÃ©ma et les
instances de lâ€™entrepÃ´t. Pour garantir une meilleure utilisation de lâ€™entrepÃ´t de donnÃ©es, lâ€™ad-
ministrateur doit rÃ©aliser deux Ã©tapes principales : la conception physique et le tuning.
Durant la phase de conception physique, lâ€™administrateur doit sÃ©lectionner des techniques
dâ€™optimisation pour satisfaire les requÃªtes dÃ©cisionnelles (figure 1). Plusieurs techniques ont
Ã©tÃ© proposÃ©es, chacune a ses propres avantages, ses inconvÃ©nients et certaines ont de fortes si-
milaritÃ©s. Pour chaque technique, plusieurs algorithmes de sÃ©lection sont possibles. En consÃ©-
quence, lâ€™administrateur doit faire des choix au niveau (1) des techniques dâ€™optimisation, (2)
de la nature de sÃ©lection et (3) des algorithmes de sÃ©lection.
Le choix des techniques dâ€™optimisation : Si nous explorons la littÃ©rature et les Ã©diteurs de
gestion de bases de donnÃ©es commerciaux, nous trouvons une large panoplie de techniques
que nous pouvons classer en deux catÃ©gories : (i) les techniques redondantes qui nÃ©cessitent
un espace de stockage et un coÃ»t de maintenance (les vues matÃ©rialisÃ©es, les index avancÃ©es, la
fragmentation verticale, etc.) et (ii) les techniques non redondantes ne nÃ©cessitant ni un espace
de stockage ni un coÃ»t de maintenance (la fragmentation horizontale, le traitement parallÃ¨le,
etc.). Pour optimiser ses requÃªtes, lâ€™administrateur peut choisir une ou plusieurs techniques
parmi ces deux catÃ©gories.
Le choix de la nature de la sÃ©lection : Deux types de sÃ©lection de techniques dâ€™optimisation
existent : la sÃ©lection isolÃ©e et la sÃ©lection multiple. Dans la premiÃ¨re sÃ©lection, une seule
technique (redondante ou non redondante) est sÃ©lectionnÃ©e. Cette sÃ©lection a Ã©tÃ© largement
Ã©tudiÃ©e (Aouiche et al., 2005; Bellatreche et al., 2006, 2008; Chaudhuri, 2004; Johnson, 1999;
Chee-Yong, 1999; Golfarelli et al., 2002; Oâ€™Neil et Quass, 1997). La sÃ©lection multiple permet
de sÃ©lectionner plusieurs techniques Ã  la fois. Elle est principalement motivÃ©e par les fortes
similaritÃ©s entre les techniques dâ€™optimisation. Les travaux majeurs dans cette catÃ©gorie sont
principalement concentrÃ©s sur la sÃ©lection des vues matÃ©rialisÃ©es et les index (Labio et al.,
1997; Sanjay et al., 2000; Talebi et al., 2008).
Le choix de lâ€™algorithme de sÃ©lection : Dans chaque classe de sÃ©lection, nous trouvons
un large choix dâ€™algorithmes de sÃ©lection simples (glouton par exemple) et complexes (algo-
rithmes basÃ©s sur la programmation linÃ©aire, gÃ©nÃ©tique, recuit simulÃ©, etc.). Chaque algorithme
a ses propres paramÃ¨tres que lâ€™administrateur doit configurer.
Cet Ã©tat de lâ€™art montre les difficultÃ©s dâ€™administration dâ€™un entrepÃ´t de donnÃ©es. Elles
sont liÃ©es Ã  la fois aux diffÃ©rents choix citÃ©s au dessus et Ã©galement au choix des tables et des
attributs participant Ã  la dÃ©finition de ses techniques. Pour mieux comprendre ces difficultÃ©s,
considÃ©rons le scÃ©nario suivant dans lequel un administrateur a un ensemble de requÃªtes Ã 
optimiser. Pour ce faire, il doit rÃ©pondre aux questions suivantes :
1. Quelles techniques dâ€™optimisation dois-je choisir ?
Dans ce scÃ©nario, nous supposons quâ€™il choisit une seule technique concernant les index
de jointure en Ã©toile (Aouiche et al., 2005).
2. Quels tables et attributs dois-je indexer ?
3. Quel algorithme de sÃ©lection dois-je utiliser ?
Deux types majeurs dâ€™algorithmes ont Ã©tÃ© proposÃ©s pour sÃ©lectionner des index de join-
L. Bellatreche et al.
ture binaires : les algorithmes gloutons (Bellatreche et al., 2007) et les algorithmes basÃ©s
sur les techniques de fouille de donnÃ©es (Aouiche et al., 2005; Bellatreche et al., 2008).
4. Quels paramÃ¨tres dâ€™algorithmes de sÃ©lection dois-je configurer ?
La conception physique obtenue aprÃ¨s avoir rÃ©pondu aux diffÃ©rentes questions gÃ©nÃ¨re une
configuration âˆ† contenant diffÃ©rentes techniques dâ€™optimisation et leurs paramÃ¨tres. Lâ€™entre-
pÃ´t de donnÃ©es Ã©volue au cours de sa durÃ©e de vie, en consÃ©quence, il doit pouvoir Ãªtre tunÃ©
par lâ€™administrateur. Cette Ã©volution concerne plusieurs aspects : (i) le contenu des tables, (ii)
la taille des techniques dâ€™optimisation sÃ©lectionnÃ©es lors de la conception physique (les vues
matÃ©rialisÃ©es, les index et les partitions), (iii) les frÃ©quences des requÃªtes/mises Ã  jour, (iv)
lâ€™ajout et la suppression de requÃªtes, etc. Ces changements nÃ©cessitent une phase de rÃ©glage de
maniÃ¨re Ã  maintenir une meilleure performance de lâ€™entrepÃ´t et surtout Ã©viter sa dÃ©gradation.
Le rÃ´le principal de la phase de tuning est de surveiller et de diagnostiquer lâ€™utilisation de la
configurationâˆ† et des diffÃ©rentes ressources qui lui sont affectÃ©es (comme le tampon, lâ€™espace
de stockage, etc.).
RÃ©cemment, plusieurs travaux sur le tuning ont Ã©tÃ© dÃ©veloppÃ©s, spÃ©cialement des laboratoires
de grands Ã©diteurs de SGBDs : SQL Server, BD2, ORACLE. (Chaudhuri et Narasayya) du
groupe de Microsoft ont montrÃ© lâ€™intÃ©rÃªt du tuning et ses effets sur la performance de requÃªtes
1
.
Malheureusement, peu dâ€™outils existent pour assister et accompagner un administrateur
dans sa tÃ¢che de conception physique et de tuning. Certains Ã©diteurs de SGBDs ont mis en place
des outils pour gÃ©rer les techniques dâ€™optimisation, comme Index Advisor Tool (dÃ©veloppÃ©
par DB2 (Valentin et al., 2000)) et Data Partitioning Advisor (dÃ©veloppÃ© par ORACLE11g)
qui offre des recommandations de partitionnement des tables (Sheet, 2007). Les principales
limitations de ces outils sont : lâ€™administration dâ€™une et une seule technique dâ€™optimisation,
lâ€™absence du choix de lâ€™algorithmes de sÃ©lection (algorithme de sÃ©lection est imposÃ©), et la non
prise en compte des similaritÃ©s entre les diffÃ©rentes techniques. (Kraft et al., 2007) ont proposÃ©
un outil, appelÃ© Statistics API qui permet " dâ€™interroger " une base de donnÃ©es afin de collecter
les diffÃ©rentes statistiques. Celles-ci concernent : la mÃ©ta donnÃ©e des tables, mÃ©ta donnÃ©e des
colonnes, mÃ©ta donnÃ©e des index, les statistiques sur les tables, les facteurs de sÃ©lectivitÃ©, etc.
Dans ce papier, nous prÃ©sentons lâ€™Ã©laboration dâ€™un outil dâ€™administration et de tuning per-
mettant dâ€™assister lâ€™administrateur durant la conception physique et le tuning. Il doit lui per-
mettre de choisir la ou les techniques dâ€™optimisation quâ€™il souhaite utiliser, les algorithmes de
sÃ©lection, les attributs et les tables participant Ã  la dÃ©finition des techniques dâ€™optimisation. Vu
le nombre important de techniques dâ€™optimisation, nous avons concentrÃ© notre travail sur trois
dâ€™entre elles, Ã  savoir la fragmentation horizontale primaire, dÃ©rivÃ©e et les index de jointure
binaires. Ce choix est dÃ» Ã  la similaritÃ© entre ces deux techniques.
Ce papier est divisÃ© en 6 sections. Dans la section 2, nous dÃ©crivons briÃ¨vement les deux
types de fragmentation et leurs problÃ¨mes de sÃ©lection. La section 3 prÃ©sente les index de
jointure en Ã©toile en dÃ©crivant leurs principes et leurs diffÃ©rents algorithmes de sÃ©lection. La
section 4 montre la forte similaritÃ© entre les index et la fragmentation horizontale dÃ©rivÃ©e et
lâ€™exploitation de cette similaritÃ© comme un moyen de tuning dans les entrepÃ´ts de donnÃ©es.
La section 5 dÃ©taille la conception et le dÃ©veloppement de notre outil en montrant ses princi-
pales fonctionnalitÃ©s. La section 6 conclut le papier en rÃ©sumant le travail effectuÃ© et en citant
quelques perspectives.
1Ce papier a Ã©tÃ© consacrÃ© le meilleur papier de VLDBâ€™2007
ParAdmin: Outil dâ€™Assistance Ã  lâ€™Administration
Conception
physique
Tables 
(modÃ©lisation logique)
Profils des tables
Profils requÃªtes
1. Techniques dâ€™optimisation
2. Contraintes liÃ©s Ã  la sÃ©lection
Techniques dâ€™optimisation
SchÃ©ma de placement
Ressources utilisÃ©es
FIG. 1 â€“ La conception physique
2 Fragmentation Horizontale
La fragmentation horizontale a Ã©tÃ© largement adoptÃ©e par la communautÃ© des entrepÃ´ts de
donnÃ©es relationnels. Elle permet de dÃ©composer une table/vue matÃ©rialisÃ©e en plusieurs sous
tables, appelÃ©es fragments horizontaux, oÃ¹ chacun contient un sous ensemble dâ€™instances de
la table globale. Deux types de fragmentation sont possibles : (i) la fragmentation primaire et
(2) la fragmentation dÃ©rivÃ©e. Dans le premier type, une table est dÃ©composÃ©e en fonction de
ses attributs. La fragmentation dÃ©rivÃ©e consiste quant Ã  elle Ã  fragmenter une table en utilisant
des attributs dâ€™une autre table. Cette fragmentation est possible uniquement sâ€™il y a un lien de
jointure entre les deux tables. Les fragmentations primaire et dÃ©rivÃ©e peuvent Ãªtre appliquÃ©es
respectivement aux tables de dimension et Ã  la table des faits (Bellatreche et Boukhalfa, 2005).
Les deux types de fragmentation optimisent les requÃªtes de jointure en Ã©toile caractÃ©risÃ©es par
des opÃ©rations de sÃ©lection dÃ©finies sur les tables de dimension et des jointures entre les tables
de dimension et la table des faits (Bellatreche et Boukhalfa, 2005). Appliquer la fragmentation
dÃ©rivÃ©e sur la table des faits peut gÃ©nÃ©rer un nombre important de fragments (notÃ© N) N =âˆg
i=1mi oÃ¹mi et g sont respectivement le nombre de fragments de la table de dimensionDi
et le nombre de tables de dimension qui ont participÃ© dans le processus de fragmentation.
Le problÃ¨me de sÃ©lection de schÃ©ma de fragmentation dâ€™un entrepÃ´t de donnÃ©es est for-
malisÃ© de la maniÃ¨re suivante : Ã©tant donnÃ©e une charge de requÃªtes Q = {Q1, ..., Qm} dÃ©-
finie sur un entrepÃ´t de donnÃ©es composÃ© dâ€™une table de faits F et d tables de dimension
{D1, D2, ..., Dd}, et une contrainteW reprÃ©sentant le nombre de fragments de faits que lâ€™ad-
ministrateur souhaite avoir. Le problÃ¨me de sÃ©lection de schÃ©ma de fragmentation horizontale
consiste Ã  fragmenter la table des faits en fonction des schÃ©mas de fragmentation des tables de
dimension en N fragments, tel que (âˆ‘QjâˆˆQ fj Ã— Cost(Qj) soit minimisÃ© et (N â‰¤ W ) (fj
reprÃ©sente la frÃ©quence dâ€™accÃ¨s de la requÃªteQj).
Pour rÃ©soudre ce problÃ¨me, plusieurs algorithmes de sÃ©lection ont Ã©tÃ© proposÃ©s (Bella-
treche et al., 2006; Boukhalfa et al., 2008) : un algorithme gÃ©nÃ©tique, un algorithme de recuit
simulÃ©, un algorithme glouton et un algorithme tabou. Chaque algorithme gÃ©nÃ¨re un schÃ©ma
de fragmentation de lâ€™entrepÃ´t de donnÃ©es. Ã‰tant donnÃ©s deux types de tables Ã  fragmenter : les
L. Bellatreche et al.
tables de dimension et la table des faits, le schÃ©ma de fragmentation de lâ€™entrepÃ´t contient les
schÃ©mas de fragmentation des tables de dimension et la table des faits. Pour rÃ©aliser cette frag-
mentation, lâ€™administrateur doit identifier les attributs de dimension participant Ã  ce processus,
appelÃ©s les attributs de fragmentation. Un algorithme de fragmentation permet de partitionner
le domaine de chaque attribut de fragmentation.
Exemple 1 Supposons que nous ayons un entrepÃ´t de donnÃ©es avec trois tables de dimension
(TEMPS, CLIENT et PRODUIT) et une table des faits VENTES (voir Figure 2). Les attributs
de fragmentation sont Ville de la table CLIENT, CatÃ©gorie de la table PRODUIT et Mois de la
table TEMPS. Les domaines de chaque attributs sont :
Dom(Ville) = {"Poitiers", "Paris", "Nantes"}, Dom(CatÃ©gorie) = {"BeautÃ©", "MultimÃ©dia",
"Jouet", "Jardinage", "Fitness"} et Dom(Mois) = {"Janvier", "FÃ©vrier", "Mars", "Avril","Mai",
"Juin"}. Le processus de fragmentation Ã©tabli un partitionnement de chaque domaine en sous
domaines. Par exemple, si nous dÃ©cidons de dÃ©composer le domaine de Ville en deux sous
domaines SD1 et SD2 tels que SD1 = {"Poitiers", "Nantes"} et SD2 = {"Paris"}, la table
CLIENT est alors dÃ©composÃ©e en deux fragments, oÃ¹ chacun correspond Ã  un sous domaine.
AprÃ¨s cette prÃ©sentation du problÃ¨me de sÃ©lection dâ€™un schÃ©ma de fragmentation, nous
pouvons lister plusieurs problÃ¨mes que lâ€™administrateur doit rÃ©gler : (1) le choix des tables de
dimension Ã  utiliser pour fragmenter la table des faits, (2) la dÃ©composition des domaines en
sous domaines que les algorithmes de fragmentation exploitent, (3) le nombre de fragments
finaux que lâ€™administrateur souhaite avoir, (3) lâ€™algorithme de fragmentation, et (4) les para-
mÃ¨tres utilisÃ©s par chaque algorithme. Le tableau suivant rÃ©capitule les diffÃ©rents paramÃ¨tres
utilisÃ©s par les quatre algorithmes.
Algorithme ParamÃ¨tres
Algorithme gÃ©nÃ©tique
Nombre dâ€™individus
Nombre de gÃ©nÃ©rations
Taux de croisement
Taux de mutation
Algorithme tabou La taille de la liste tabouNombre dâ€™itÃ©rations
Recuit SimulÃ©
TempÃ©rature initiale
Gel du systÃ¨me
Ã‰quilibre
3 Index de Jointure Binaires
Lâ€™index de jointure binaire est une variante de lâ€™index de jointure en Ã©toile. Ã‰tant donnÃ© que
les requÃªtes de jointure en Ã©toile possÃ¨dent des opÃ©rations de jointure suivies par des opÃ©rations
de sÃ©lection, un bitmap reprÃ©sentant les n-uplets de la table de faits est crÃ©Ã© pour chaque valeur
distincte de lâ€™attribut de la table dimension sur lequel lâ€™index est construit. Le ime bit du bitmap
est Ã©gal Ã  1 si le n-uplet correspondant Ã  la valeur de lâ€™attribut indexÃ© peut Ãªtre joint avec le
n-uplet de rang i de la table de faits. Dans le cas contraire, le ime bit est Ã  zÃ©ro. Les index de
jointure binaires sont efficaces pour les requÃªtes de type COUNT, AND, OR, NOT, dâ€™oÃ¹ leur
implÃ©mentation dans les SGBDs commerciaux, comme Oracle, SQL server, et DB2. Notons
ParAdmin: Outil dâ€™Assistance Ã  lâ€™Administration
que les index binaires sont recommandÃ©s pour des attributs de faible cardinalitÃ© comme sexe.
Notons que dans un contexte dÃ©cisionnel, les requÃªtes dâ€™analyse se font gÃ©nÃ©ralement sur des
indicateurs (attributs) dont le domaine est restreint. Une autre caractÃ©ristique offerte par les
index de jointure binaires est la compression (Johnson, 1999), ce qui permet une rÃ©duction de
leur espace de stockage et la possibilitÃ© de les stocker en mÃ©moire centrale.
Notons quâ€™un index de jointure binaire dans les entrepÃ´ts de donnÃ©es relationnels peut
Ãªtre dÃ©fini sur un ou plusieurs attributs non clÃ©s de faible cardinalitÃ© des tables de dimension.
Ces attributs sont appelÃ©s les attributs indexables. Sur un attribut indexable Aj dâ€™une table de
dimensionDi une condition de la forme suivanteDi.Aj Î¸ V aleur est dÃ©finie dans la clause
WHERE oÃ¹ Î¸ = {<,>,â‰¤,â‰¥,=} et Valeur âˆˆ domaine de lâ€™attribut Aj .
Soit A = {A1, A2, ..., AK} lâ€™ensemble des attributs indexables candidats pour les index
de jointure binaires. Le nombre dâ€™index de jointure possible ayant un seul attribut, est donnÃ©
par : (
K
1
)
+
(
K
2
)
+ ...+
(
K
K
)
= 2K âˆ’ 1 (1)
PourK = 4, ce nombre est Ã©gale Ã  15. Le nombre possible de tous les index est donnÃ© par :
(
2
K
âˆ’1
1
)
+
(
2
K
âˆ’1
2
)
+ ...+
(
2
K
âˆ’1
2Kâˆ’1
)
= 22
K
âˆ’1 (2)
Pour K = 4, ce nombre est (215). En consÃ©quence, sÃ©lectionner un ensemble dâ€™index de
jointure binaires minimisant le coÃ»t total dâ€™exÃ©cution de requÃªtes et satisfaisant une contrainte
de stockage est formalisÃ© de la maniÃ¨re suivante. Ã‰tant donnÃ© un entrepÃ´t de donnÃ©es ayant un
ensemble de tables de dimension D = {D1, D2, ..., Dd} et une table des faits F , une charge
de requÃªtes Q = {Q1, Q2, ..., Qm}, oÃ¹ chaque requÃªte Qj a une frÃ©quence dâ€™accÃ¨s fj , et une
capacitÃ© de stockage S, le problÃ¨me de sÃ©lection des index de jointure consiste Ã  trouver un
ensemble dâ€™index minimisant le coÃ»t dâ€™exÃ©cution de requÃªtes et satisfaisant la contrainte de
stockage S.
Deux types dâ€™algorithmes ont Ã©tÃ© utilisÃ©s pour sÃ©lectionner des index de jointure en Ã©toile :
algorithmes gloutons (Bellatreche et al., 2007) et algorithmes dirigÃ©s par les techniques de
fouille de donnÃ©es (Aouiche et al., 2005; Bellatreche et al., 2008).
4 Utilisation des Index de Jointure Binaires et la Fragmenta-
tion Horizontale pour le Tuning des EntrepÃ´ts de donnÃ©es
Dans cette section, nous montrons comment les index de jointure binaires et la fragmenta-
tion horizontale peuvent Ãªtre utilisÃ©s pour tuner un entrepÃ´t de donnÃ©es. Cela est possible grÃ¢ce
leur similaritÃ©. Pour illustrer cette similaritÃ©, nous considÃ©rons lâ€™exemple suivant : ConsidÃ©rons
lâ€™entrepÃ´t dÃ©crit dans lâ€™exemple 1. La population de ce schÃ©ma est dÃ©crite dans la Figure 2. Sur
ce schÃ©ma, considÃ©rons la requÃªte suivante :
SELECT Count(*)
FROM CLIENT C, PRODUIT P, TEMPS T, VENTES V
WHEERE C.Ville=â€™Poitiersâ€™
AND P.CatÃ©gorie=â€™BeautÃ©â€™
AND T.Mois=â€™Juinâ€™
AND P.PID = V.PID AND C.CID=C.CID AND T.TID=V.TID
L. Bellatreche et al.
Cette requÃªte contient trois prÃ©dicats de sÃ©lection dÃ©finis sur les attributs suivants : Ville, Ca-
tÃ©gorie et Mois et trois jointures. Ces attributs sont candidats pour la dÃ©finition de schÃ©ma de
fragmentation et la dÃ©finition des index de jointure binaires. Pour optimiser cette requÃªte, trois
modes dâ€™exÃ©cution sont possibles pour lâ€™administrateur : (i) lâ€™utilisation de la fragmentation
horizontale seule (FHSEULE), (ii) lâ€™utilisation des index de jointure seuls (IJBSEUL) et (iii)
lâ€™utilisation mixte (FH&IJB) qui combine les deux modes.
   

PoitiersPascal1111
PoitiersEric2122
NantesDidier3133
NantesPatrick4144
ParisYves5155
PoitiersGilles6166
VilleNomCIDRIDC
FitnessSlimForm1011
JardinageManure1022
JouetBarbie1033
MultimÃ©diaWebCam1044
BeautÃ©Clarins1055
BeautÃ©Sonof lore1066
CatÃ©gorieNomPIDRIDP
2003Juin661
2003Mai552
2003Avril443
2003Mars334
2003FÃ©vrier225
2003Janvier116
AnnÃ©eMoisTIDRIDT

 	





181110621224
196610531325
172210531326
151110631327
185510521223
104410521222
101110521221
205510461620
202210461619
202210451518
406610421217
446610511116
454410321215
175510351514
1006610251513
1035510241412
1021110241411
2001110231310
100111012129
27331011118
20441011117
14551062126
14661054145
10111045454
50331046163
28661066162
25111066161
MontantTIDPIDCIDRIDS




FIG. 2 â€“ Un exemple de Population de lâ€™EntrepÃ´t
FHSEULE : Lâ€™administrateur peut dÃ©composer la table des faits VENTES en se basant sur
les schÃ©mas de fragmentation des trois tables de dimension : CLIENT, TEMPS et PRODUIT
fragmentÃ©es en utilisant Ville, Mois, CatÃ©gorie, respectivement. En consÃ©quence, la table des
faits est partitionnÃ©e en 90 fragments 2, oÃ¹ chaque fragment des faits V entesi (1 â‰¤ i â‰¤ 90)
est dÃ©fini comme suit :
V entes_i = V ENTES â‹‰ CLIENTj â‹‰ TEMPSk â‹‰ PRODUITm ,
avec (1 â‰¤ j â‰¤ 3), (1 â‰¤ k â‰¤ 6), (1 â‰¤ m â‰¤ 5), et â‹‰ reprÃ©sente la semi-jointure.
La Figure 3 prÃ©sente le sous schÃ©ma en Ã©toile (VENTES_BJP) correspondant aux achats de
produits de beautÃ© rÃ©alisÃ©es par les clients vivant Ã  Poitiers durant le mois de Juin. En consÃ©-
quence, la requÃªte ci-dessus est rÃ©Ã©crite comme suit :
SELECT Count(*) FROM VENTES PARTITION(VENTES_BJP) 3
Pour exÃ©cuter cette requÃªte, lâ€™optimiseur ne charge en mÃ©moire que le fragment des faits
Ventes_BJP (Figure 3). Ce mode permet dâ€™Ã©viter les trois opÃ©rations de jointure ce qui re-
prÃ©sente un gain considÃ©rable.
IJBSEUL : Lâ€™administrateur peut sÃ©lectionner un index de jointure binaire entre la table des
faits et les trois tables de dimension sur les attributs Ville,Mois et CatÃ©gorie comme suit :
2Supposons que nous avons 3 villes, 6 mois et 5 catÃ©gories.
3Nous utilisons une syntaxe dâ€™Oracle.
ParAdmin: Outil dâ€™Assistance Ã  lâ€™Administration
  

 
PoitiersPascal1111
PoitiersEric2122
PoitiersGilles6166
VilleNomCIDRIDC
BeautÃ©Clarins1055
BeautÃ©Sonof lore1066
CatÃ©gorieNomPIDRIDP
2003Juin661
AnnÃ©eMoisTIDRIDT

 
ff



fi

fl ffi
 
446610511116
28661066162
AmountTIDPIDCIDRIDS
!





" #
$
FIG. 3 â€“ Sous SchÃ©ma en Ã‰toile VENTES_BJP
CREATE BITMAP INDEX vente_client_ville_prod_cat_time_mois_bjix
ON VENTES(CLIENT.Ville, PRODUIT.CatÃ©gorie, TEMPS.Mois)
FROM VENTES V, CLIENT C, TEMPS T, PRODUIT P
WHERE V.CID = C.CID AND V.PID = P.PID AND V.TID = T.TID
Pour exÃ©cuter la requÃªte, lâ€™optimiseur doit accÃ©der aux bitmaps (colorÃ©s en gris dans la Figure
4a) qui correspondent aux valeurs de trois attributs dâ€™indexation puis il rÃ©alise une opÃ©ration
logique "AND" entre ces bitmaps (Figure 4b). De ce fait, aucune opÃ©ration de jointure nâ€™est
effectuÃ©e pour exÃ©cuter la requÃªte.
27
26
25
24
23
22
21
20
19
18
17
16
15
14
13
12
11
10
9
8
7
6
5
4
3
2
1
RID
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
AND
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
1
0
0
0
0
0
0
F
CatÃ©gorieMoisVille
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
1
1
0
0
0
0
0
0
0
0
0
Ja
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
Jo
0
0
0
0
0
0
0
1
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
0
M
1
1
1
1
1
1
1
0
0
0
0
1
0
0
0
0
0
0
0
0
0
1
1
0
0
1
1
B
0
0
1
0
0
0
0
0
0
0
1
1
0
0
1
0
0
0
0
0
0
0
1
0
0
1
0
Ju
0
0
0
0
1
0
0
1
0
0
0
0
0
1
0
1
0
0
0
0
0
1
0
0
0
0
0
Mai
0
0
0
0
0
1
0
0
0
0
0
0
1
0
0
0
0
0
0
0
1
0
0
0
0
0
0
Av
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
1
0
0
Ma
0
1
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
Fe
1
0
0
1
0
0
1
0
0
0
0
0
0
0
0
0
1
1
1
0
0
0
0
1
0
0
1
Ja
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
1
1
1
0
0
0
0
1
0
0
0
0
N
0
0
0
0
0
0
0
0
0
1
0
0
0
1
1
0
0
0
0
0
0
0
0
1
0
0
0
Pr
0
0
0
1
1
1
1
1
1
0
1
1
1
0
0
0
0
0
1
1
1
1
0
0
1
1
1
P
%
& '
%(
'
FIG. 4 â€“ (a) Index de jointure gÃ©nÃ©rÃ© (b) OpÃ©ration AND
FH&IJB : Au lieu dâ€™utiliser chaque technique sÃ©parÃ©ment, nous proposons de les combiner
en prenant en compte leur similitude. Cette opÃ©ration se dÃ©roule en quatre Ã©tapes :
1. DÃ©terminer lâ€™ensemble des attributs de dimension utilisÃ©s dans les prÃ©dicats de sÃ©lection
des requÃªtes (cet ensemble est notÃ© AD).
2. Fragmenter lâ€™entrepÃ´t de donnÃ©es en utilisant AD et lâ€™ensemble de requÃªtes de dÃ©part :
Q = {Q1, Q2, Â· Â· Â· , Qm}. Cette fragmentation peut Ãªtre rÃ©alisÃ©e avec nâ€™importe quel
algorithme de partitionnement (glouton, recuit simulÃ©, gÃ©nÃ©tique, tabou, etc.). Le fait
que nous sommes contraints par le seuil de maintenance W , il est fort possible que
L. Bellatreche et al.
le schÃ©ma de fragmentation obtenu ne couvre pas tous les attributs de AD. On note
par AFSET (AFSET âŠ† AD) lâ€™ensemble des attributs de dimension participant Ã  la
dÃ©finition des fragments.
3. Identifier les requÃªtes bÃ©nÃ©ficiaires de la fragmentation horizontale : le schÃ©ma de frag-
mentation pourrait Ãªtre bÃ©nÃ©fique pour certaines requÃªtes et non bÃ©nÃ©fique pour dâ€™autres.
Pour dÃ©terminer les requÃªtes bÃ©nÃ©ficiaires, nous dÃ©finissons une mÃ©trique (appelÃ©e, mÃ©-
trique de tuning) pour chaque requÃªteQj :
taux(Qj) =
C[Qj , SF ]
C[Qj , Ï†]
(3)
oÃ¹ C[Qj , SF ] et C[Qj , Ï†] reprÃ©sentent le coÃ»t dâ€™exÃ©cution de la requÃªte Qj respecti-
vement sur un schÃ©ma partitionnÃ© SF et non partitionnÃ©. Lâ€™administrateur a le droit de
paramÃ©trer cette mÃ©trique en utilisant un seuil Î» dÃ©fini comme suit :
Si taux(Qj) â‰¤ Î» alors la requÃªteQj est bÃ©nÃ©ficiaire, sinon elle est non bÃ©nÃ©ficiaire.
4. Identifier les attributs indexables candidats : ce sont des attributs de faible cardinalitÃ©
utilisÃ©s par les requÃªtes non bÃ©nÃ©ficiaires Qnobenefit = {Qâ€²
1
, Qâ€²
2
, Â· Â· Â· , Qâ€²l} et nâ€™appar-
tiennent pas Ã  AFSET .
Exemple 2 Pour mieux comprendre HF&IJB, nous considÃ©rons le scÃ©nario suivant (basÃ© sur
lâ€™exemple 1), oÃ¹ la FHSEULE a gÃ©nÃ©rÃ© 90 fragments de la table des faits. Supposons que
lâ€™administrateur souhaite nâ€™avoir que 18 fragments au lieu de 90 gÃ©nÃ©rÃ©s (W = 18). Dans ce
cas, le schÃ©ma de fragmentation obtenu est dÃ©fini sur deux attributs de dimension, Ã  savoir Ville
et Mois (AFSET = {Mois, V ille}). Si la requÃªte initiale est bÃ©nÃ©ficiaire alors aucun index
de jointure nâ€™est dÃ©fini. Dans le cas contraire, un index de jointure sera dÃ©fini sur lâ€™attribut
CatÃ©gorie de la table de dimension PRODUIT, car il nâ€™est pas pris en compte dans le processus
de fragmentation. Cet index de jointure sera dÃ©fini sur chaque sous schÃ©ma en Ã©toile (Figure
5).
17
16
2
RID
0
0
0
F
CatÃ©gorie
0
0
0
Jr
0
0
0
J
1
0
0
M
0
1
1
B
406610421217
446610511116
28661066162
MontantTIDPIDCIDRIDS
)
*+
,
*-
.
/ 0
10 2
. 3
4 5
FIG. 5 â€“ Index de Jointure dÃ©fini sur un Sous SchÃ©ma en Ã©toile
5 Mise en Oeuvre de lâ€™Outil dâ€™Assistance
Dans cette section, nous proposons un outil dâ€™assistance Ã  lâ€™administration et de tuning, ap-
pelÃ© ParAdmin, qui permet Ã  lâ€™administrateur dâ€™Ã©tablir ses choix et de paramÃ©trer les diffÃ©rents
algorithmes. ParAdmin gÃ¨re principalement trois techniques dâ€™optimisation4 ; la fragmentation
4ParAdmin est actuellement en extension pour inclure les vues matÃ©rialisÃ©es
ParAdmin: Outil dâ€™Assistance Ã  lâ€™Administration
horizontale primaire ; la fragmentation horizontale dÃ©rivÃ©e et les index de jointure binaires. Les
objectifs principaux de ParAdmin sont :
â€“ Permettre la visualisation de lâ€™Ã©tat courant de lâ€™entrepÃ´t de donnÃ©es : la structure de
lâ€™entrepÃ´t (schÃ©ma, attributs, taille de chaque table, dÃ©finition de chaque attribut, etc.) et
la charge dÃ©finie sur lâ€™entrepÃ´t (le nombre de sÃ©lections, le nombre de jointures, attributs
de sÃ©lection, les facteurs de sÃ©lectivitÃ© de chaque prÃ©dicats, etc.)
â€“ Offrir deux modes de sÃ©lection de techniques dâ€™optimisation : personnalisÃ©e et non per-
sonnalisÃ©e. Dans la sÃ©lection non personnalisÃ©e, nous supposons que lâ€™administrateur
nâ€™a pas assez de connaissance sur la technique sÃ©lectionnÃ©e. Lâ€™outil fait alors le choix
(par dÃ©faut) de lâ€™algorithme de sÃ©lection et propose " un meilleur schÃ©ma ". Tandis que
la sÃ©lection personnalisÃ©e donne plus de libertÃ© Ã  lâ€™administrateur pour le choix de lâ€™al-
gorithme, des paramÃ¨tres, des attributs, et des tables sur lesquels il souhaite sÃ©lectionner
la technique dâ€™optimisation.
â€“ Offrir une sÃ©lection mono-structure de son choix.
â€“ Offrir une sÃ©lection multi-structure.
â€“ Permettre Ã  lâ€™administrateur de revoir ses choix sâ€™il nâ€™est pas satisfait.
â€“ Proposer la gÃ©nÃ©ration des scripts implÃ©mentant les techniques dâ€™optimisation.
â€“ Permettre la visualisation de la qualitÃ© de chaque technique dâ€™optimisation proposÃ©e et
de ses critÃ¨res de performance : le coÃ»t dâ€™entrÃ©es/sorties de requÃªtes, le taux dâ€™amÃ©liora-
tion apportÃ© par la technique, etc.
5.1 La Conception de ParAdmin
La principale difficultÃ© pour concevoir notre outil est lâ€™identification des diffÃ©rents besoins
et leurs reprÃ©sentations. Pour ce faire, nous avons utilisÃ© un formalisme de modÃ¨le de tÃ¢ches
(Balbo et al., 2004). Ceux-ci permettent dâ€™une part dâ€™analyser les systÃ¨mes interactifs en met-
tant leur utilisation au premier plan et dâ€™autre part dâ€™exprimer les diffÃ©rentes activitÃ©s quâ€™un
utilisateur souhaite pouvoir rÃ©aliser. Les outils dÃ©veloppÃ©s pour les supporter intÃ¨grent le plus
souvent un outil de simulation qui produit les scÃ©narii. Ces derniers sont utilisÃ©s pour permettre
la validation par lâ€™utilisateur de lâ€™ordonnancement des tÃ¢ches du logiciel en conception. Parmi
les diffÃ©rents formalismes de modÃ¨le de tÃ¢ches qui ont Ã©tÃ© dÃ©veloppÃ©s et qui disposent dâ€™un
outil logiciel support citons CTT (CTTE) (Paterno et al., 2001) et K-MAD (K-MADe) 5. Nous
avons utilisÃ© ce dernier principalement parce quâ€™il est dÃ©veloppÃ© en partenariat avec lâ€™Ã©quipe
IHM de notre laboratoire et lâ€™INRIA. De plus, il permet la dÃ©finition de conditions logiques
(prÃ©, post, itÃ©ration) formelles prises en compte lors de la simulation augmentant de ce fait le
niveau de vÃ©rification.
La modÃ©lisation des tÃ¢ches nous a permis dâ€™identifier les diffÃ©rents besoins dâ€™utilisation
de ParAdmin. Nous avons validÃ© lâ€™ordonnancement des tÃ¢ches Ã  lâ€™aide des scÃ©narii afin de
produire une interface permettant de les accomplir selon les besoins de lâ€™administrateur. Ces
modÃ¨les nous ont permis dâ€™obtenir lâ€™architecture globale de ParAdmin (voir la Figure 6).
5http ://kmade.sourceforge.net
L. Bellatreche et al.
Administrateur
BD â€¢ Tables
â€¢ Description des tables
â€¢ Attributs
â€¢ Domaines des attributs
Etat de lâ€™entrepÃ´t
â€¢ RequÃªtes
â€¢ Nature des requÃªtes 
â€¢ FrÃ©quence dâ€™accÃ¨s
â€¢ Facteurs de sÃ©lectivitÃ© des prÃ©dicats
Charge de requÃªtes
Visualiser Ã©tat actuel
Conception physique
PS, Tampon
HPSEULE IJBSEUL HP&IJB
Attributs candidats
DÃ©coupage en SD
PrÃ©paration GÃ©nÃ©ration 
des scripts
ExÃ©cution 
des scripts
Recommandations
Configurer W Type de 
Fragmentation
GÃ©nÃ©rer le schÃ©ma
Fragmentation 
personnalisÃ©e
Fragmentation 
non personnalisÃ©e
Choix de 
lâ€™algorithme
Configuration 
de lâ€™algorithme
Choisir tables Choisir attributs
Attributs de faibles 
cardinalitÃ©s
Attributs de faibles 
cardinalitÃ©s - attributs 
de fragmentation
GÃ©nÃ©ration 
des scripts
ExÃ©cution 
des scripts
RecommandationPrÃ©paration
FIG. 6 â€“ Architecture gÃ©nÃ©rale du fonctionnement de ParAdmin
FIG. 7 â€“ ModÃ¨le de tÃ¢che de la fragmentation de lâ€™entrepÃ´t
ParAdmin: Outil dâ€™Assistance Ã  lâ€™Administration
5.2 Analyse des TÃ¢ches de ParAdmin
Pour concevoir notre outil, nous avons identifiÃ© trois principales tÃ¢ches non Ã©lÃ©mentaires
que lâ€™administrateur doit pouvoir effectuer : (1) visualiser lâ€™Ã©tat courant de lâ€™entrepÃ´t de don-
nÃ©es, (2) partitionner lâ€™entrepÃ´t de donnÃ©es, et (3) lâ€™indexer.
5.2.1 La visualisation de lâ€™Ã©tat de lâ€™entrepÃ´t
Cette tÃ¢che permet Ã  lâ€™administrateur de visualiser deux sortes dâ€™informations relatives Ã 
lâ€™entrepÃ´t de donnÃ©es (les tables, leurs descriptions, la dÃ©finition de chaque attribut de dimen-
sion ou de faits, le domaine de chaque attribut) et Ã  la charge des requÃªtes (la nature de la re-
quÃªte : recherche ou mise Ã  jour, la frÃ©quence dâ€™accÃ¨s de chaque requÃªte, les diffÃ©rents facteurs
de sÃ©lectivitÃ© des prÃ©dicats de sÃ©lection, etc.). La Figure 8 montre lâ€™interface correspondante Ã 
la rÃ©alisation de cette tÃ¢che.
5.2.2 Le partitionnement de lâ€™entrepÃ´t
La fragmentation de lâ€™entrepÃ´t est une Ã©tape du processus de conception physique. La Fi-
gure 7 en prÃ©sente la modÃ©lisation sous forme dâ€™un arbre de tÃ¢ches K-MAD. Deux types de
fragmentation sont supportÃ©s dans les entrepÃ´ts de donnÃ©es, la fragmentation primaire (ap-
pliquÃ©e aux tables de dimension) et la fragmentation dÃ©rivÃ©e (appliquÃ©e Ã  la table des faits),
câ€™est pourquoi lâ€™administrateur doit prÃ©alablement identifier les attributs non clÃ©s des tables
de dimension candidats au processus de fragmentation. Une fois cette identification Ã©tablie, il
propose un dÃ©coupage de leurs domaines en sous domaines. Un paramÃ¨tre important que lâ€™ad-
ministrateur doit configurer est la contrainte de maintenance. Celle-ci reprÃ©sente le nombre
de fragments de la table des faits gÃ©nÃ©rÃ© (W ). Pour rendre cette fragmentation opÃ©rationnelle,
FIG. 8 â€“ Visualisation de lâ€™Ã©tat de lâ€™entrepÃ´t
deux types de partitionnement sont disponibles : (a) la fragmentation non personnalisÃ©e et (b)
la fragmentation personnalisÃ©e. Dans le premier type, ParAdmin partitionne lâ€™entrepÃ´t de don-
nÃ©es en utilisant tous les attributs candidats et un algorithme de fragmentation par dÃ©faut. Le
deuxiÃ¨me type offre plus de libertÃ© Ã  lâ€™administrateur dans le processus de sÃ©lection. Il peut
L. Bellatreche et al.
FIG. 9 â€“ Choix et configuration des algorithmes
FIG. 10 â€“ Personnalisation de la fragmentation
choisir les tables et les attributs de dimension participant au processus de fragmentation. Il doit
choisir lâ€™algorithme de partitionnement et Ã©tablir ses paramÃ¨tres. Cette obligation de choix de
lâ€™algorithme a Ã©tÃ© formalisÃ©e Ã  lâ€™aide des conditions formelles proposÃ©es dans K-MADe par
une prÃ©-condition logique. Trois types dâ€™algorithme sont disponibles : un algorithme glouton,
un algorithme gÃ©nÃ©tique et un algorithme de recuit simulÃ©e (Figure 9). Une fois le schÃ©ma de
lâ€™entrepÃ´t fragmentÃ©, lâ€™administrateur peut visualiser une recommandation proposÃ©e par Pa-
rAdmin. Elle contient le nombre de sous schÃ©mas en Ã©toile gÃ©nÃ©rÃ©s, le dÃ©coupage final du do-
maine de chaque attribut de sÃ©lection, une estimation du nombre dâ€™entrÃ©es et sorties nÃ©cessaires
pour exÃ©cuter la charge de requÃªtes, le nombre de fragments de chaque table de dimension, le
gain de performance obtenu par cette fragmentation (par rapport Ã  un schÃ©ma non fragmentÃ©),
les attributs de fragmentation, etc. Si lâ€™administrateur nâ€™est pas satisfait de cette recomman-
dation, il peut revenir Ã  lâ€™Ã©tape prÃ©cÃ©dente et changer les diffÃ©rents paramÃ¨tres (rechoisir les
attributs et les tables ou lâ€™algorithme, ses paramÃ¨tres, etc.). Ce retour en arriÃ¨re est primordial
dans la phase de conception physique. Une fois satisfait, lâ€™administrateur demande Ã  lâ€™outil de
gÃ©nÃ©rer les scripts de fragmentation. Ceux-ci pourront par la suite Ãªtre appliquÃ©s sur lâ€™entrepÃ´t
de donnÃ©es. La Figure 10 montre lâ€™interface dâ€™une fragmentation personnalisÃ©e.
ParAdmin: Outil dâ€™Assistance Ã  lâ€™Administration
FIG. 11 â€“ Recommandation dâ€™indexation
5.2.3 La tÃ¢che dâ€™indexation
Elle permet de sÃ©lectionner des index de jointure en Ã©toile. Cette tÃ¢che peut Ãªtre exÃ©cutÃ©e
dâ€™une maniÃ¨re isolÃ©e (IJBSEUL) ou combinÃ©e (FH&IJB). Dans le cas dâ€™une IJBSEUL, lâ€™admi-
nistrateur doit dâ€™abord choisir les attributs indexables candidats. Le paramÃ¨tre important pour
lâ€™indexation est la contrainte de stockage. Comme pour la fragmentation horizontale, deux
types dâ€™indexation sont possibles : lâ€™indexation non personnalisÃ©e et lâ€™indexation personnali-
sÃ©e. Cette tÃ¢che est quasi similaire Ã  la prÃ©cÃ©dente. Dans la recommandation, on trouve les in-
formations concernant le gain des index, les attributs indexÃ©s, le coÃ»t de stockage exigÃ© par les
index sÃ©lectionnÃ©s, etc. La Figure 11 prÃ©sente lâ€™interface dÃ©diÃ©e Ã  la tÃ¢che de recommandation
sur les index (lâ€™espace occupÃ©, lâ€™espace disponible, le nombre de requÃªtes non bÃ©nÃ©ficiaires,
etc.).
FH&IJB a le mÃªme principe que IJBSEUL sauf pour le choix des attributs candidats Ã 
lâ€™indexation (au lieu de considÃ©rer les attributs candidats Ã  partir de la configuration initiale de
lâ€™entrepÃ´t de donnÃ©es, lâ€™administrateur doit identifier ces attributs parmi les attributs dâ€™indexa-
tion non utilisÃ©s par HFSEULE) et le choix du paramÃ¨tre du tuning (Î»). Ce paramÃ¨tre peut
jouer un rÃ´le important dans le tuning, par exemple, si lâ€™Ã©volution de lâ€™entrepÃ´t de donnÃ©es
impose Ã  lâ€™administrateur de rÃ©duire le coÃ»t de stockage de structures dâ€™optimisation redon-
dantes. Il est donc nÃ©cessaire de pouvoir paramÃ©trer Î» pour que la plupart des requÃªtes soient
bÃ©nÃ©ficiaires.
6 Conclusion
Les entrepÃ´ts de donnÃ©es ont fait naÃ®tre un nouveau besoin dâ€™administration et de tuning.
Cela est dÃ» Ã  leurs caractÃ©ristiques : la volumÃ©trie, la complexitÃ© des requÃªtes, les exigences de
temps de rÃ©ponse raisonnable et la gestion de lâ€™Ã©volution de lâ€™entrepÃ´t. Dans cet environnent,
nous avons mis en Ã©vidence les difficultÃ©s quâ€™un administrateur pourrait rencontrer durant les
phases de conception physique et de tuning. Ces difficultÃ©s sont multiples car elles concernent
plusieurs niveaux de conception : le choix des techniques dâ€™optimisation pertinentes pour lâ€™en-
L. Bellatreche et al.
semble de requÃªtes Ã  optimiser, le choix de la nature de sÃ©lection des techniques dâ€™optimisation
et le choix des algorithmes et leur paramÃ¨tres. Vu ces difficultÃ©s, nous avons identifiÃ© le besoin
de dÃ©velopper un outil dâ€™assistance Ã  lâ€™administrateur qui permet de rÃ©pondre aux besoins en
terme de choix possibles. Nous avons proposÃ© un outil, appelÃ© ParAdmin offrant trois tech-
niques dâ€™optimisation : la fragmentation horizontale primaire, dÃ©rivÃ©e et les index de jointure
binaires. Il permet Ã  lâ€™administrateur de choisir les diffÃ©rents algorithmes et leurs paramÃ¨tres.
Il peut alors utiliser ces techniques dâ€™une maniÃ¨re isolÃ©e ou combinÃ©e. Une autre particularitÃ©
de ParAdmin est le fait de proposer des sÃ©lections personnalisÃ©es et non personnalisÃ©es des
structures dâ€™optimisation. AprÃ¨s chaque sÃ©lection, ParAdmin propose des recommandations Ã 
lâ€™administrateur permettant de visualiser la qualitÃ© de la ou les techniques quâ€™il a choisie(s). Il
peut alors soit valider ses choix en gÃ©nÃ©rant et exÃ©cutant les scripts ou les revoir.
De plus, notre outil peut Ãªtre pluggÃ© sur nâ€™importe quelle base de donnÃ©es ou entrepÃ´t de
donnÃ©es et peut facilement Ã©voluer. Cette Ã©volution peut concerner : lâ€™ajout ou la suppression
dâ€™un algorithme de sÃ©lection, lâ€™ajout ou la suppression dâ€™une technique dâ€™optimisation comme
les vues matÃ©rialisÃ©es.
RÃ©fÃ©rences
Aouiche, K., O. Boussaid, et F. Bentayeb (2005). Automatic Selection of Bitmap Join Indexes
in Data Warehouses. 7th International Conference on Data Warehousing and Knowledge
Discovery (DAWAK 05).
Balbo, S. O., N., et C. Paris (2004). Choosing the right task-modeling notation : A taxonomy.
In The Handbook of Task Analysis for Human-Computer Interaction, D. Diaper and N.
Stanton (Eds.), Lawrence Erlbaum Associates (LEA).
Bellatreche, L. et K. Boukhalfa (2005). An evolutionary approach to schema partitioning
selection in a data warehouse environment. Proceeding of the International Conference on
Data Warehousing and Knowledge Discovery (DAWAKâ€™2005), 115â€“125.
Bellatreche, L., K. Boukhalfa, et H. I. Abdalla (2006). Saga : A combination of genetic and
simulated annealing algorithms for physical data warehouse design. in 23rd British National
Conference on Databases (212-219).
Bellatreche, L., K. Boukhalfa, et M. K. Mohania (2007). Pruning search space of physical
database design.
Bellatreche, L., R. Missaoui, H. Necir, et H. Drias (2008). A data mining approach for selecting
bitmap join indices. Journal of Computing Science and Engineering 2(1), 206â€“223.
Boukhalfa, K., L. Bellatreche, et P. Richard (2008). ragmentation primaire et dÃ©rivÃ©e :
Ã‰tude de complexitÃ©, algorithmes de sÃ©lection et validation sous oracle10g. Techreport
http ://www.lisi.ensma.fr/members/bellatreche, LISI/ENSMA.
Chaudhuri, S. (2004). Index selection for databases : A hardness study and a principled heuris-
tic solution. IEEE Transactions on Knowledge and Data Engineering 16(11), 1313â€“1323.
Chaudhuri, S. et V. Narasayya. Self-tuning database systems : A decade of progress. Procee-
dings of the International Conference on Very Large Databases.
Chee-Yong, C. (1999). Indexing techniques in decision support systems. Phd. thesis, Univer-
sity of Wisconsin - Madison.
ParAdmin: Outil dâ€™Assistance Ã  lâ€™Administration
Gill, P. J. (2000). Breaking the warehouse barrier. Oracle Magazine 1(IX), 38â€“44.
Golfarelli, M., , et E. Rizzi, S. Saltarelli (2002). Index selection for data warehousing. Pro-
ceedings 4th International Workshop on Design and Management of Data Warehouses
(DMDWâ€™2002), Toronto, Canada, 33â€“42.
Johnson, T. (1999). Performance measurements of compressed bitmap indices. Proceedings
of the International Conference on Very Large Databases, 278â€“289.
Kraft, T., H. Schwarz, et B. Mitschang (2007). A statistics propagation approach to enable
cost-based optimization of statement sequences. pp. 267â€“282.
Labio, W., D. Quass, et B. Adelberg (1997). Physical database design for data warehouses.
Proceedings of the International Conference on Data Engineering (ICDE).
Oâ€™Neil, P. et D. Quass (1997). Improved query performance with variant indexes. Proceedings
of the ACM SIGMOD International Conference on Management of Data, 38â€“49.
Paterno, F., G. Mori, et R. Galimberti (2001). CTTE : An Environment for Analysis and Deve-
lopment of Task Models of Cooperative Applications. ACM Press.
Sanjay, A., C. Surajit, et V. R. Narasayya (2000). Automated selection of materialized views
and indexes in microsoft sql server. Proceedings of the International Conference on Very
Large Databases, 496â€“505.
Sheet, O. D. (2007). Oracle partitioning. White Paper :
http ://www.oracle.com/technology/products/bi/db/11g/ .
Talebi, Z. A., R. Chirkova, Y. Fathi, et M. Stallmann (2008). Exact and inexact methods
for selecting views and indexes for olap performance improvement. To appear in 11th
International Conference on Extending Database Technology (EDBTâ€™08).
Valentin, G., M. Zuliani, D. C. Zilio, G. M. Lohman, et A. Skelley (2000). Db2 advisor : An
optimizer smart enough to recommend its own indexes. ICDEÅ 00, 101â€“110.
Summary
The task of administrating data warehouses becomes a crucial issue compare to traditional
databases. This is due to the characteristics of data warehouses: large amount of data, complex
queries, satisfaction of decision maker requirement and management of data evolution. In the
context of data warehouse, a large spectrum of optimisation techniques was proposed during
the physical database design. Each technique has a number of selection algorithms, where
each one has its own parameters. Another interesting point is the strong similarity between
optimisation techniques like for materialized views and indexes. During the physical design,
the data warehouse administrator shall establish several choices. In this paper, we firstly, show
difficulties that an administrator has during its task of administrating and tuning a warehouse.
Secondly, we propose a tuning method based on horizontal partitioning and bitmap join in-
dexes. Finally, we propose a tool advising the administrator in an interactive way to realise its
tasks. They concern the choice of optimisation techniques, selection algorithms, their parame-
ters and visualisation of performance recommendation.
