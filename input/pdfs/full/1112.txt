Un framework de tra√ßabilit√© pour des transformations √†
caract√®re imp√©ratif
Bastien Amar‚àó, Jean-R√©my Falleri‚àó‚àó
Marianne Huchard‚àó‚àó, Cl√©mentine Nebut‚àó‚àó, Herv√© Leblanc‚àó
‚àóIRIT, Universit√© Paul Sabatier, 118 Route de Narbonne, F-31062 Toulouse Cedex 9
{amar, leblanc}@irit.fr,
‚àó‚àóLIRMM, CNRS et Univ. Montpellier II, 161 rue Ada 34392 Montpellier Cedex 5 - France
{falleri, huchard, nebut}@lirmm.fr
R√©sum√©. Cet article s‚Äôinscrit dans le cadre de l‚Äôing√©nierie dirig√©e par les mo-
d√®les et apporte une contribution au probl√®me de la tra√ßabilit√© des artefacts de
mod√©lisation durant une cha√Æne de transformations √©crites dans un langage imp√©-
ratif. L‚Äôapproche que nous proposons n√©cessite peu d‚Äôinterventions de l‚Äôutilisa-
teur. Nous introduisons un m√©tamod√®le g√©n√©rique des traces qui permet entre
autres d‚Äôapporter une dimension multi-√©chelles aux traces gr√¢ce √† l‚Äôapplica-
tion du patron de conception composite. Le principe de notre approche est de
surveiller certaines cat√©gories d‚Äôop√©rations int√©ressantes pour la g√©n√©ration de
traces pertinentes. Ces cat√©gories sont d√©finies √† l‚Äôaide du type des objets mani-
pul√©s par les op√©rations. Une fois les cat√©gories d√©finies, la trace est g√©n√©r√©e par
du code d√©di√© qui est inject√© automatiquement dans la transformation, autour
des op√©rations caract√©ris√©es par les cat√©gories d√©finies. Un prototype a √©t√© r√©a-
lis√© pour les transformations de mod√®les √©crites en Java, sur le framework EMF.
L‚Äôinjection du code d√©di√© √† la tra√ßabilit√© est r√©alis√©e √† l‚Äôaide de la programmation
par aspects.
1 Introduction
Cet article s‚Äôinscrit dans le cadre de l‚Äôing√©nierie dirig√©e par les mod√®les (IDM) (B√©zivin
et al., 2004), paradigme dans lequel la notion de m√©tamod√®le est plac√©e au centre du cycle
de d√©veloppement. Elle permet de consid√©rer des mod√®les comme des donn√©es et donc de
les utiliser comme entit√©s de premi√®re classe dans les langages d√©di√©s √† la transformation de
mod√®les. La tra√ßabilit√© des artefacts de mod√©lisation durant une cha√Æne de transformations de
mod√®les constitue la probl√©matique abord√©e dans cet article.
Avec l‚Äôapparition des langages et outils d√©di√©s √† la transformation de mod√®les (e.g. ATL1,
Kermeta2, EMF3), ainsi que des m√©ta-m√©tamod√®les de r√©f√©rence (MOF, Ecore) les processus
1Atlas Transformation Language, http ://www.eclipse.org/m2m/atl/.
2http ://www.kermeta.org.
3http ://www.eclipse.org/modeling/emf/.
Tra√ßabilit√© des transformations imp√©ratives
de d√©veloppement dirig√©s par les mod√®les prennent corps. De ce fait, les probl√©matiques r√©cur-
rentes li√©es √† la production logicielle apparaissent dans ce nouveau contexte de d√©veloppement.
Une de ces probl√©matiques concerne la tra√ßabilit√©, qui entre en jeu notamment dans le cadre de
l‚Äôing√©nierie des exigences : il faut en effet s‚Äôassurer que les exigences d‚Äôun projet se retrouvent
dans les mod√®les, le logiciel et les cas de tests. Un groupe de travail de la communaut√© inter-
nationale IDM (ECMDA : European Conference on Model Driven Architecture) se consacre
depuis plusieurs ann√©es √† l‚Äô√©tude de la tra√ßabilit√©. Celle-ci peut-√™tre trait√©e principalement
selon deux points de vue :
‚Äì la gestion des liens de tra√ßabilit√© par interception d‚Äô√©v√©nements dans un outil de d√©ve-
loppement dirig√© par les mod√®les, voire un modeleur UML ;
‚Äì la cr√©ation des liens de tra√ßabilit√© lors d‚Äôune transformation automatis√©e de mod√®les pour
laquelle le langage est soit imp√©ratif, soit d√©claratif, soit mixte.
C‚Äôest cette derni√®re approche que nous avons choisi d‚Äô√©tudier et nous proposons dans cet article
un framework d√©di√© √† la tra√ßabilit√© pour les langages imp√©ratifs de transformation de mod√®le.
Un framework de tra√ßabilit√© doit identifier les mod√®les sources et cibles lors d‚Äôune trans-
formation de mod√®les, ainsi que le contexte de leurs transformations. Ainsi, elle permettra
de (Lim√≤n et Garbajosa, 2005) :
‚Äì maintenir et justifier une op√©ration de transformation ;
‚Äì obtenir l‚Äô√©volution des mod√®les au cours du processus de d√©veloppement ;
‚Äì faciliter la maintenance et le contr√¥le d‚Äôun projet ;
‚Äì pr√©senter les d√©cisions prises lors du d√©veloppement d‚Äôun projet.
La contribution de cet article est un m√©canisme de gestion de traces embo√Æt√©es et g√©n√©r√©es
de mani√®re semi-automatique pour des langages de transformation imp√©ratifs. Pour illustrer
notre contribution, nous allons consid√©rer tout au long de cet article une transformation volon-
tairement simple4 illustr√©e figure 1. Elle r√©alise deux op√©rations de restructuration :
‚Äì la premi√®re est illustr√©e par les classes A et B de l‚Äôexemple. Deux attributs de m√™me
nom se retrouvent, apr√®s la transformation, factoris√©s dans une superclasse5 commune
qui sera cr√©√©e si besoin est. Cette op√©ration correspond au refactoring nomm√© Extract
Super Class dans Fowler et al. (1999).
‚Äì la seconde est illustr√©e par les classes C de notre transformation exemple. Lorsque deux
classes ont le m√™me nom, elles sont fusionn√©es et leurs attributs respectifs se retrouvent
dans le r√©sultat de la fusion. On peut aussi voir cette op√©ration comme la composition
du refactoring nomm√© movefield (Fowler et al., 1999) (attrC1 d√©plac√© dans la classe
poss√©dant attrC2 ou vice-versa) avec une op√©ration de renommage de classe suivie
d‚Äôune op√©ration de nettoyage de classe vide.
Le r√©sultat de notre approche sur cet exemple est un mod√®le repr√©sentant la trace dont une
vue est pr√©sent√©e figure 2. Nous allons voir dans cet article la conception du framework permet-
tant de l‚Äôobtenir. En premier lieu, nous proposons un m√©tamod√®le de traces embo√Æt√©es utilisant
le patron de conception composite. Il permet d‚Äôapporter un comportement multi-√©chelles aux
traces. Nous nous focaliserons ensuite sur la mani√®re d‚Äôinstancier ce m√©tamod√®le lors de l‚Äôex√©-
cution d‚Äôune transformation impl√©ment√©e dans un langage imp√©ratif. Nous d√©crirons la mise
4L‚Äôint√©gralit√© du code de cette transformation est disponible sur
http ://www.lirmm.fr/‚àºnebut/Publications/ArticleSupplements/LMO2008/Traceability/ .
5Le nom de cette superclasse, dans l‚Äôexemple consid√©r√© (figure 1), provient d‚Äôune interpr√©tation intensionnelle de
l‚Äôh√©ritage.
B. Amar et al.
en ≈ìuvre de ce framework et notamment l‚Äôutilisation d‚ÄôAspectJ. Enfin, une √©tude des travaux
existants et une conclusion viendront terminer cet article.
FIG. 1 ‚Äì Mod√®le source (√† gauche) et cible (√† droite) de la transformation exemple.
FIG. 2 ‚Äì Vue de la trace obtenue par notre framework de tra√ßabilit√©. Les artefacts du mod√®le
sont repr√©sent√©s par les n≈ìuds. Les arcs annot√©s repr√©sentent certaines des op√©rations utilis√©es
au cours de la transformation.
2 Un m√©tamod√®le de traces embo√Æt√©es
Un framework de tra√ßabilit√© permet de garder des informations sur le devenir des √©l√©ments
des mod√®les au cours des diff√©rentes transformations qu‚Äôils subissent. Dans un contexte d‚Äôin-
g√©nierie dirig√©e par les mod√®les, il est normal que l‚Äôinformation relative √† la tra√ßabilit√© soit
Tra√ßabilit√© des transformations imp√©ratives
consid√©r√©e comme un mod√®le. Un mod√®le est donc associ√© √† chaque ex√©cution d‚Äôune transfor-
mation trac√©e. La d√©finition d‚Äôun m√©tamod√®le des traces nous permet de structurer les traces
qui seront g√©n√©r√©es par le framework de tra√ßabilit√©, et ainsi de mieux les manipuler.
Plusieurs m√©tamod√®les g√©n√©ralistes de traces ont d√©j√† √©t√© propos√©s (Jouault, 2005; Falleri
et al., 2006; Kolovos et al., 2006). Ils permettent de supporter la plupart des transformations
envisageables en IDM (Mens et Gorp, 2006). Nous √©tudierons plus pr√©cis√©ment ces diff√©-
rentes approches dans la section 5. Le m√©tamod√®le propos√© ici (Figure 3) se base sur celui de
Falleri et al. (2006) (qui g√®re les transformations en cha√Æne ‚Äì plusieurs transformations ex√©-
cut√©es successivement sur un m√™me mod√®le ‚Äì qui se produisent fr√©quemment en IDM), que
nous avons √©tendu en y ajoutant les notions de types de liens (LINKTYPE) et de liens compo-
sites (COMPOSITELINK). Une trace (ETRACE) est une sorte de COMPOSITELINK, c‚Äôest-√†-dire
compos√©e de plusieurs liens (ABSTRACTLINK) r√©f√©ren√ßant deux objets appartenant aux mo-
d√®les manipul√©s (SOURCE et DESTINATION).
La notion de types de liens de tra√ßabilit√© a √©t√© introduite par Lim√≤n et Garbajosa (2005).
L‚Äôajout des ¬´ types de liens ¬ª √† ce m√©tamod√®le permet de garder l‚Äôintention d‚Äôune transforma-
tion dans le lien, et permet √† l‚Äôutilisateur de raisonner sur les traces cr√©√©es.
Il est utile, pour les transformations imp√©ratives aussi bien que d√©claratives, d‚Äôavoir une
repr√©sentation multi-√©chelle des traces. En effet, le fait qu‚Äôune op√©ration puisse en appeler une
autre (ou que des r√®gles puissent en d√©clencher d‚Äôautres) cr√©e des niveaux d‚Äôimbrication qu‚Äôil
est utile de pouvoir repr√©senter. C‚Äôest la raison pour laquelle le patron de conception composite
(Gamma et al., 1995) est appliqu√© sur les liens. De cette mani√®re, il est possible de manipuler
des ¬´ paquets ¬ª de liens et l‚Äôutilisateur choisit le niveau de d√©tail des traces qu‚Äôil visualise. De
plus, l‚Äôapplication de ce patron permet d‚Äôencapsuler la complexit√© des transformations mises
en jeu. La figure 4 nous montre une instanciation du m√©tamod√®le pour l‚Äôexemple de transfor-
mation que nous consid√©rons. Pour plus de clart√©, seule la partie concernant les classes A et
B de notre transformation montr√©e sur la figure 1 a √©t√© gard√©e. Ce m√©tamod√®le est ind√©pen-
dant du type de langage de transformation utilis√© et nous allons voir comment il est possible
de l‚Äôinstancier pour g√©n√©rer des traces dans le cas de transformations programm√©es dans un
langage imp√©ratif.
3 Tra√ßabilit√© des langages de transformation imp√©ratifs
Dans cet article, nous nous int√©ressons au probl√®me de la gestion de la tra√ßabilit√© pour
les langages imp√©ratifs de transformation de mod√®les. Dans cette section, nous √©tudions les
moyens d‚Äôobtenir un mod√®le de trace d√©fini par le m√©tamod√®le propos√© √† la section pr√©c√©-
dente, au cours de l‚Äôex√©cution de transformations de mod√®les. Pour obtenir un mod√®le de trace,
on peut envisager deux types de solution : une solution manuelle o√π l‚Äôutilisateur ajoute dans
son code de transformation des instructions pour remplir le mod√®le de trace (c‚Äôest la solution
adopt√©e dans Falleri et al. (2006)) ou une solution automatique o√π l‚Äôon g√©n√®re la trace au-
tomatiquement par analyse du code de la transformation. La solution purement manuelle ne
nous para√Æt pas adapt√©e : elle n√©cessite d‚Äôune part une trop grande intervention du program-
meur et d‚Äôautre part une trop grande intrusion dans le code de la transformation. Nous pensons
√©galement qu‚Äôil est illusoire de g√©n√©rer de mani√®re compl√®tement automatique l‚Äôint√©gralit√© du
mod√®le de trace. C‚Äôest pourquoi nous proposons une approche semi-automatique. Nous pro-
posons de cat√©goriser les op√©rations d‚Äôune transformation et d‚Äôassocier √† chaque cat√©gorie une
B. Amar et al.
FIG. 3 ‚Äì Le m√©tamod√®le des traces.
FIG. 4 ‚Äì Une partie de l‚Äôinstanciation du m√©tamod√®le correspondant √† la trace de la trans-
formation d√©crite Fig. 1.
Tra√ßabilit√© des transformations imp√©ratives
mani√®re de les tracer. Persuad√©s que cette approche ne permettra pas de capturer toutes les
informations de tra√ßabilit√©, nous laissons √©galement la possibilit√© au programmeur de d√©crire
ses propres types d‚Äôop√©rations tra√ßables.
3.1 Cat√©gories d‚Äôop√©rations tra√ßables
Dans le reste de l‚Äôarticle, nous nous pla√ßons dans le cadre d‚ÄôEMF (Budinsky et al., 2003)
et des transformations de mod√®les r√©alis√©es en Java, mais ces travaux peuvent √™tre appliqu√©s
pour n‚Äôimporte quel langage imp√©ratif tel que, par exemple, Kermeta (Fleurey et al., 2006).
EMF est un framework de mod√©lisation facilitant la g√©n√©ration de code pour le d√©veloppe-
ment d‚Äôoutils bas√©s sur un mod√®le structur√©. Il permet le chargement de mod√®les s√©rialis√©s en
Ecore et leur transformation via l‚ÄôAPI fournie par EMF, en Java. EMF est donc, entre autres,
une plate-forme de transformation de mod√®les.
Dans un cadre IDM, les mod√®les manipul√©s par les transformations sont tous d√©finis par un
m√©tamod√®le. La racine des classes dans Ecore est EOBJECT6, comme l‚Äôest OBJECT pour Java.
Ainsi, tous les objets d‚Äôun mod√®le conforme √† Ecore sont de type EOBJECT. On en d√©duit
que les op√©rations int√©ressantes √† tracer lors d‚Äôune transformation de mod√®les manipulent des
EOBJECT. En effet, les transformations √©tant programm√©es en Java, il faut pouvoir distinguer
les op√©rations du programme effectuant une transformation des autres op√©rations √©ventuelle-
ment pr√©sentes dans un programme Java classique.
Pour impl√©menter la transformation exemple pr√©sent√©e en introduction, nous d√©finissons
en Java, entre autres, l‚Äôop√©ration de transformation :
EClass makeSuperClass(EClass c1, EClass c2)
Elle prend en param√®tre deux ECLASS, les fusionne et retourne une superclasse factorisant
les attributs communs √† c1 et c2. Tracer cette op√©ration consiste √† √©tablir un lien entre l‚Äôob-
jet retourn√© (la destination) et les objets c1 et c2 (les sources). Nous proposons l‚Äôheuristique
suivante : chaque fois qu‚Äôune op√©ration a pour param√®tre au moins un EOBJECT et retourne
un EOBJECT, les param√®tres constituent les sources d‚Äôun lien de tra√ßabilit√©, et l‚Äôobjet retourn√©
(une ECLASS dans notre exemple7) la destination du lien de tra√ßabilit√©. Cela constitue une pre-
mi√®re cat√©gorie d‚Äôop√©rations, et nous avons donc d√©fini une mani√®re de tracer ce type d‚Äôop√©ra-
tion, en indiquant ce qui est source et ce qui est destination. Dans la suite de cet article, on note
A : B si B est sp√©cialis√© par A (i.e. A h√©rite de B) ou si A = B. Si A ne sp√©cialise pas B et
A 6= B, on note : A : B. Notre premi√®re cat√©gorie d‚Äôop√©rations peut √™tre exprim√©e comme
suit :
meth(T1, T2, ..., Tn) : Tretour | Tretour : EObject ‚àß (‚àÉTi, Ti : EObject) (1)
Cat√©goriser le plus d‚Äôop√©rations possibles permet d‚Äôautomatiser au maximum la cr√©ation
de la trace, et donc de minimiser l‚Äôintervention de l‚Äôutilisateur. Ci-dessous, nous pr√©sentons
deux autres cat√©gories d‚Äôop√©rations, associ√©es √† la mani√®re de les tracer :
‚Äì deuxi√®me cat√©gorie : dans EMF, les cr√©ations d‚Äôobjets se font via le patron de conception
factory (Gamma et al., 1995). Tout objet est cr√©√© par l‚Äôappel de m√©thodes particuli√®res
6Toutes les classes EMF ont un nom pr√©fix√© par E : EClass, EPackage, etc.
7Une ECLASS est de type EOBJECT car elle est l‚Äôune de ses sous-classes.
B. Amar et al.
sur la classe singleton EFACTORY. L‚Äôobjet nouvellement cr√©√© doit √™tre li√© dans une trace
au singleton EFACTORY. Cela constitue une autre cat√©gorie d‚Äôop√©rations. Elle nous per-
met d‚Äôidentifier les objets nouvellement cr√©√©s lors de la transformation. Dans la notation
C.meth(..), C repr√©sente la classe de l‚Äôobjet sur lequel est appel√©e l‚Äôop√©ration :
C.meth() : Tretour | Tretour : EObject ‚àß C : EFactory (2)
‚Äì troisi√®me cat√©gorie : les classiques accesseurs en √©criture. Ceux-ci sont facilement d√©-
tectables car ils n‚Äôont pas de type de retour (void) ou leur type de retour n‚Äôest pas une
sous-classe de EObject. Le receveur de l‚Äôenvoi de message est un EOBJECT et ils n‚Äôont
qu‚Äôun seul param√®tre, de type EOBJECT. Pour cette cat√©gorie d‚Äôop√©ration, l‚Äôobjet pass√©
en param√®tre constitue la source de la trace, et l‚Äôobjet receveur la destination.
C.meth(T ) : Tretour | Tretour : EObject ‚àß C : EObject ‚àß T : EObject (3)
On remarque que le type de l‚Äô√©lement retourn√© ne doit pas √™tre EOBJECT pour ne pas
que cette cat√©gorie interf√®re avec la premi√®re cat√©gorie que nous avons d√©finie.
Ces cat√©gories sont des heuristiques permettant de faciliter la g√©n√©ration automatique de
la trace. Comme il a d√©j√† √©t√© dit, il est illusoire, dans le cadre d‚Äôun langage imp√©ratif, de vou-
loir tout tracer automatiquement et la liste de cat√©gories n‚Äôest pas exhaustive. Elle est li√©e au
langage de transformation de mod√®le utilis√© : par exemple, le patron de conception factory
n‚Äôest pas commun √† tous les langages et notre deuxi√®me cat√©gorie est donc une cat√©gorie non
transposable √† tous les langages. C‚Äôest la raison pour laquelle il faut pr√©voir l‚Äôintervention de
l‚Äôutilisateur, et lui donner les moyens de d√©finir ses propres cat√©gories pour adapter la g√©n√©ra-
tion de traces √† ses besoins.
3.2 Op√©rations d√©finies par l‚Äôutilisateur
Pour des langages imp√©ratifs, on ne peut pas proposer de m√©canisme g√©n√©rique et enti√®-
rement automatique pour g√©n√©rer la trace. Nous avons donc laiss√© √† l‚Äôutilisateur la possibilit√©
d‚Äôajouter ses propres cat√©gories d‚Äôop√©rations √† tracer, afin qu‚Äôil puisse tracer des op√©rations non
prises en compte dans les cat√©gories que nous avons d√©finies ou pour qu‚Äôil puisse restreindre
les cat√©gories.
Pour les trois cat√©gories d‚Äôop√©rations d√©finies dans la section pr√©c√©dente, trois crit√®res
rentrent en jeu :
‚Äì la classe de l‚Äôobjet receveur du message ;
‚Äì le type de retour de l‚Äôop√©ration ;
‚Äì le type des param√®tres de la m√©thode.
N√©anmoins, pour que l‚Äôutilisateur puisse d√©finir correctement une cat√©gorie, d‚Äôautres crit√®res
sont √† prendre en consid√©ration :
‚Äì le nom de la m√©thode ;
‚Äì l‚Äôartefact qui sera source dans la trace ;
‚Äì l‚Äôartefact qui sera cible.
Pour d√©finir une cat√©gorie personnalis√©e d‚Äôop√©ration, l‚Äôutilisateur en sp√©cifie la structure en
instanciant un extrait du m√©tamod√®le Ecore, donn√© figure 5. Consid√©rons l‚Äôop√©ration suivante :
void C.addAttribute(EClass,EAttribute)
Tra√ßabilit√© des transformations imp√©ratives
Elle n‚Äôest pas prise en compte par les cat√©gories que nous avons d√©j√† d√©finies. L‚Äôinstanciation
du m√©tamod√®le propos√© permettra de cr√©er une nouvelle cat√©gorie restreinte √† une op√©ration
dont le nom est AddAttribute, qui poss√®de deux param√®tres : l‚Äôun typ√© ECLASS, l‚Äôautre EAT-
TRIBUTE. Ce type d‚Äôop√©rations est tr√®s difficile √† tracer automatiquement, sans intervention de
l‚Äôutilisateur.
FIG. 5 ‚Äì Extrait de la partie ¬´ EOperation ¬ª d‚ÄôEcore.
Ces instances du m√©tamod√®le de Ecore nous permettent donc de d√©finir syntaxiquement de
nouvelles cat√©gories d‚Äôop√©rations. On peut consid√©rer les cat√©gories d√©j√† d√©finies comme des
instances de ce m√©tamod√®le pr√©-enregistr√©es pour faciliter la d√©marche de l‚Äôutilisateur.
4 G√©n√©ration des traces au cours d‚Äôune transformation de
mod√®les
Nous avons vu dans les sections pr√©c√©dentes comment d√©finir des cat√©gories d‚Äôop√©rations
int√©ressantes √† tracer lors d‚Äôune transformation de mod√®les √©crite dans un langage imp√©ratif.
Cette partie explique comment ces cat√©gories ont √©t√© utilis√©es afin d‚Äôinstancier une trace durant
l‚Äôex√©cution de la transformation.
4.1 Un point d‚Äôentr√©e : l‚Äôop√©ration transform
Nous obligeons l‚Äôutilisateur √† avoir un point d‚Äôentr√©e pour le d√©but de la g√©n√©ration de la
trace : une op√©ration nomm√©e transform. Consid√©rons maintenant la transformation comme
un arbre, repr√©sentant la d√©composition fonctionnelle d‚Äôune transformation avec une racine
impos√©e qui est cette op√©ration transform. Une repr√©sentation d‚Äôun tel arbre est donn√©e par
la figure 6. Elle repr√©sente la transformation que nous avons prise comme exemple. Chaque
op√©ration tra√ßable appel√©e par transform est ensuite consid√©r√©e comme un sommet fils direct
B. Amar et al.
FIG. 6 ‚Äì D√©composition fonctionnelle d‚Äôune partie de la transformation exemple.
de la racine de l‚Äôarbre. Si elle appelle des op√©rations tra√ßables, le sommet la repr√©sentant aura
lui-m√™me des fils, et ainsi de suite. Les feuilles de l‚Äôarbre repr√©sentent donc le dernier niveau
de granularit√© fonctionnelle voulu.
4.2 Organisation des traces
Nous avons vu que le patron de conception Composite a √©t√© appliqu√© sur le m√©tamod√®le
des traces que nous avons d√©fini. Nous allons voir dans cette section comment les traces sont
g√©n√©r√©es, en consid√©rant l‚Äôarbre de d√©composition pr√©sent√© sur la figure 6.
La s√©mantique que nous attribuons au patron Composite dans notre cas est d‚Äôavoir des
traces embo√Æt√©es refl√©tant l‚Äôappel des fonctions au cours de la transformation. Le choix effec-
tu√© pour obtenir une trace exploitable par l‚Äôutilisateur est le suivant : l‚Äôappel de l‚Äôop√©ration
transform provoque la cr√©ation d‚Äôun CompositeLink. Les feuilles de l‚Äôarbre de d√©composition
fonctionnelle sont des feuilles du ¬´ Composite ¬ª. Les n≈ìuds internes sont des composants com-
posites du ¬´ Composite ¬ª. On obtient ainsi une instance du m√©tamod√®le isomorphe √† l‚Äôarbre
de d√©composition fonctionnelle. L‚Äôutilisateur pourra ainsi choisir, lors de la visualisation de la
trace, le degr√© voulu de granularit√©.
4.3 Intercepter les op√©rations tra√ßables
Nous √©tudions maintenant le moyen d‚Äôintercepter les op√©rations correspondant √† une ca-
t√©gorie afin de g√©n√©rer la trace. Nous avons choisi d‚Äôutiliser pour cela la programmation par
aspects (Kiczales et al., 1997), et plus particuli√®rement AspectJ8. Cette approche permet de
construire la trace sans modification du code de la transformation. La programmation par as-
pects permet de regrouper dans un module (un aspect) les pr√©occupations transverses √† une
application dont le code est habituellement diss√©min√© dans plusieurs classes, comme, par
exemple, la persistance. Un aspect est principalement d√©fini de :
‚Äì pointcut : ils servent √† d√©finir les endroits o√π du code source va √™tre greff√© dans le code
de l‚Äôapplication originale. Ils permettent √©ventuellement de d√©finir quand ces greffes
doivent √™tre appliqu√©es.
‚Äì advice : ce sont des fragments de code source destin√©s √† √™tre greff√©s sur l‚Äôapplication. Ils
sont de trois types :
8http ://www.eclipse.org/aspectj .
Tra√ßabilit√© des transformations imp√©ratives
‚Äì les before sont greff√©s avant le code source indiqu√© par le pointcut auquel ils sont
associ√©s ;
‚Äì les after sont greff√©s apr√®s ;
‚Äì les around sont greff√©s autour de l‚Äôop√©ration originale. Le mot-cl√© proceed indique
l‚Äôex√©cution de la m√©thode lors de la d√©finition du around.
Dans notre cas, pour chaque cat√©gorie d‚Äôop√©rations, un pointcut est cr√©√©. Une m√©thode
de type around est ex√©cut√©e avant et apr√®s l‚Äôappel de l‚Äôop√©ration cat√©goris√©e et instancie le
m√©tamod√®les des traces de fa√ßon ad√©quate. La table 1 pr√©sente les cat√©gories que nous avons
d√©finies, associ√©es √† leur pointcut.
meth(T1, T2, ..., Tn) : Tretour | po in t cu t c a t e g o r i e 1 ( ) :
Tretour : EObject ‚àß (‚àÉTi, Ti : EObject) c a l l ( EObjec t+ ‚àó ( . . , EObjec t + , . . ) )
p o i n t c u t c a t e g o r i e 2 ( ) :
C.meth() : Tretour | c a l l ( EObjec t+ ‚àó ( . . ) ) &&
Tretour : EObject ‚àß C : EFactory t a r g e t ( r e c e v e u r ) &&
i f ( r e c e v e u r i n s t a n c e o f EFac to ry )
C.meth(T ) : Tretour | po in t cu t c a t e g o r i e 3 ( ) :
Tretour : EObject ‚àß C : EObject ‚àß T : EObject c a l l ( ! EObjec t+ ‚àó ( . . , EObjec t + , . . ) )
TAB. 1 ‚Äì Les cat√©gories et leur pointcut associ√©.
Par exemple, pour la premi√®re cat√©gorie, il faut cr√©er un pointcut qui intercepte les op√©-
rations dont le type de retour est un EOBJECT et dont au moins l‚Äôun des param√®tres est un
EOBJECT.
Le mot cl√© call indique que le pointcut fait r√©f√©rence √† un appel de m√©thode. En param√®tre
du call, les informations sont organis√©es comme il suit :
‚Äì le type de retour, EOBJECT+, signifie que le type de retour doit √™tre un EOBJECT ou
l‚Äôune de ses sous-classes (+) ;
‚Äì le nom de l‚Äôop√©ration est remplac√© par * ce qui permet d‚Äôintercepter toutes les m√©thodes,
sans tenir compte de leur nom ni de la classe des objets receveurs ;
‚Äì les param√®tres de la m√©thode sont repr√©sent√©s par la liste (..,EOBJECT+,..) : peu importe
le nombre ou le type des param√®tres (¬´ ..¬ª), il doit juste y avoir un EOBJECT ou l‚Äôune
de ses sous-classes (+).
D‚Äôautres m√©canismes servant √† d√©finir des pointcuts sont utilis√©s, notamment, pour la deuxi√®me
cat√©gorie :
‚Äì l‚Äôobjet pass√© en param√®tre de target est celui sur lequel sera appel√©e la m√©thode ;
‚Äì if (receveur instanceof EFactory) signifie que l‚Äôobjet receveur doit √™tre de type EFactory
Un advice around est associ√© √† ces pointcuts. Le code ex√©cut√© autour de l‚Äôop√©ration cat√©goris√©e
g√©n√®re la trace. Une partie de l‚Äôalgorithme de g√©n√©ration impl√©ment√© dans l‚Äôadvice est donn√©e
par la figure 7.
Les cat√©gories d‚Äôop√©ration que nous avons d√©finies ont chacune un pointcut qui leur est
associ√© dans l‚Äôaspect. Nous avons vu que notre approche est semi-automatique. Les cat√©gories
B. Amar et al.
Donn√©es : lcc, le CompositeLink Courant
CompositeLink sauv = lcc;
lcc = new CompositeLink();
Object retour = proceed();
si le lien composite courant a √©t√© rempli alors
Ajouter lcc au CompositeLink sauv;
pour Tout argument a de la m√©thode faire
CompositeLink e;
e.source = a;
e.destination = retour;
Ajouter e au CompositeLink sauv
FIG. 7 ‚Äì Algorithme de g√©n√©ration de traces
d√©finies par l‚Äôutilisateur doivent aussi avoir leur propre pointcut associ√©. En l‚Äô√©tat actuel, l‚Äôuti-
lisateur doit lui-m√™me √©tendre l‚Äôaspect pour prendre en charge les op√©rations qu‚Äôil veut tracer.
N√©anmoins, gr√¢ce √† l‚Äôinstanciation du m√©tamod√®le Ecore nous poss√©dons la syntaxe de ces ca-
t√©gories et nous pourrons donc g√©n√©rer les pointcuts ad√©quats pour les cat√©gories nouvellement
cr√©√©es.
La vue du mod√®le sous forme de graphe annot√© propos√©e en introduction est obtenue √†
l‚Äôaide d‚Äôune transformation model-to-text. En effet, la trace est projet√©e vers un format de
repr√©sentation graphique de graphe nomm√© dot. Il permet une premi√®re visualisation rapide
des traces de la transformation.
5 Travaux connexes
Jouault (2005) pr√©sente un m√©tamod√®le contenant l‚Äôessence de la notion de trace : une
trace (TRACELINK) a comme source et destination un ou plusieurs ANYMODELELEMENT,
que nous avons appel√©s MODELELEMENT dans le m√©tamod√®le que nous proposons. Il est
adapt√© aux langages de transformations de mod√®les d√©claratifs, tels que ATL, pour lequel il
a √©t√© con√ßu. La g√©n√©ration de traces se fait gr√¢ce √† l‚Äôapplication de r√®gles concernant la tra-
√ßabilit√© sur les r√®gles de la transformation de mod√®le. Cette transformation du langage peut
√™tre vue comme une pr√©compilation, et le code original de la transformation ne s‚Äôen trouve pas
modifi√©. N√©anmoins, cette approche n‚Äôest que peu applicable aux langages de transformations
imp√©ratifs.
Dans Falleri et al. (2006), une trace est d√©finie comme un ensemble ordonn√© de graphes
bipartis avec une intersection commune. Le m√©tamod√®le propos√© inclut √† quelques diff√©rences
pr√®s celui propos√© par Jouault (2005). En effet, dans Falleri et al. (2006), une trace a une unique
source, et une unique destination. En ce qui concerne la g√©n√©ration des traces, le programmeur
doit lui-m√™me entrer le code concernant la tra√ßabilit√© et aucune automatisation n‚Äôest propos√©e.
L‚Äôapproche a √©t√© impl√©ment√©e en Kermeta, et les perspectives indiquent une future gestion de
marqueurs dans le code pour pouvoir automatiser la g√©n√©ration de traces. Notre approche est
diff√©rente : nous essayons d‚Äô√©viter la pr√©sence des informations concernant la tra√ßabilit√© dans
Tra√ßabilit√© des transformations imp√©ratives
la transformation originale. De plus, notre m√©tamod√®le est plus abouti et permet de cr√©er des
liens composites.
Pons et Kutsche (2004) proposent d‚Äôutiliser l‚Äôartefact Abstraction et son m√©ta-attributmap-
ping d‚ÄôUML pour maintenir la tra√ßabilit√©. Cette approche permet de g√©rer les transformations
endog√®nes concernant les mod√®les UML. N√©anmoins, la norme UML est utilis√©e, et ces ar-
tefacts peuvent √™tre utilis√©s pour d‚Äôautres usages, ce qui constitue un risque de m√©lange des
informations.
D‚Äôautres m√©tamod√®les des traces ont √©t√© propos√©s dans la litt√©rature (Kolovos et al., 2006;
Oldevik et Neple, 2006; Bond√© et al., 2005) mais sont destin√©s √† des transformations plus
sp√©cifiques. Nous avons essay√©, dans notre cas, d‚Äô√©tablir un m√©tamod√®le assez g√©n√©rique per-
mettant de g√©rer au mieux la plupart des transformations envisageables (Mens et Gorp, 2006)
en IDM.
D‚Äôune fa√ßon plus macroscopique, dans Diaz et al. (2007), les auteurs proposent un m√©ta-
mod√®le g√©n√©ral de tra√ßabilit√© s‚Äôinstanciant en mod√®les permettant d‚Äôassurer la tra√ßabilit√© des
fonctionnalit√©s ou des pr√©occupations transversales ainsi que la tra√ßabilit√© des transformations.
L‚Äôinstanciation de ces mod√®les r√©sulte en graphes de trace. Le graphe de trace d‚Äôune fonction-
nalit√© (ou d‚Äôune pr√©occupation transversale) montre quelles entit√©s logicielles sont impliqu√©es
dans sa mise en ≈ìuvre et de quelle mani√®re (d√©pendance, composition, documentation, etc.).
Les graphes de trace des transformations exposent √† une granularit√© √©lev√©e les unit√©s logi-
cielles et les artefacts (par exemple les classes) et les relations de d√©pendance, d‚Äô√©volution ou
de documentation.
6 Conclusions et perspectives
Au cours d‚Äôun d√©veloppement guid√© par les mod√®les, les artefacts de base sont les mod√®les
et les transformations de mod√®les permettant par exemple de refactoriser, sp√©cialiser pour une
plate-forme donn√©e, ou encore fusionner des mod√®les. Le processus de d√©veloppement est
alors largement bas√© sur l‚Äôapplication des transformations aux mod√®les. Il est donc n√©cessaire
de garder une trace des diff√©rentes transformations op√©rant sur les mod√®les d‚Äôun projet.
Dans cette optique, nous proposons dans cet article un framework de tra√ßabilit√© d√©di√© aux
langages de transformation imp√©ratifs et permettant de g√©n√©rer un mod√®le de trace des dif-
f√©rentes modifications des √©l√©ments de mod√®le au cours de l‚Äôex√©cution d‚Äôune s√©rie de trans-
formations de mod√®les. Notre framework se base sur un m√©tamod√®le de trace permettant de
d√©finir des traces imbriqu√©es : la modification d‚Äôun √©l√©ment peut ainsi se d√©composer en plu-
sieurs sous-modifications plus √©l√©mentaires et l‚Äôanalyse de la trace se trouve ainsi simplifi√©e,
puisqu‚Äôon peut la regarder √† la granularit√© choisie. Nous avons de plus propos√© la d√©finition de
cat√©gories syntaxiques d‚Äôop√©rations √† tracer et fourni le moyen de g√©n√©rer la trace √† partir de
ces cat√©gories et d‚Äôune ex√©cution donn√©e, gr√¢ce √† l‚Äôutilisation de la programmation par aspects.
Nous avons propos√© de telles cat√©gories pour des transformations √©crites en Java/EMF, ainsi
que le m√©canisme permettant √† un utilisateur de d√©finir ses propres cat√©gories. Notre frame-
work permet d‚Äôobtenir une visualisation des liens de tra√ßabilit√© √† diff√©rentes granularit√©s lors
de l‚Äôex√©cution de transformations de mod√®les.
Une am√©lioration √† apporter au framework de tra√ßabilit√© est de lui permettre de g√©rer la
suppression d‚Äô√©l√©ments au cours d‚Äôune transformation de mod√®le, en utilisant le fait que nos
traces n‚Äôont pas forc√©ment de destination. Du c√¥t√© de la manipulation des liens, il faudrait pou-
B. Amar et al.
voir acc√©der aux √©l√©ments des mod√®les directement √† partir de la trace. De plus, nous projetons
de sauvegarder une partie de la s√©mantique et les conditions des op√©rations de transformation
en g√©rant les types de liens d√©finis dans notre m√©tamod√®le de traces. Une piste de poursuite
de ces travaux concerne la d√©finition de cat√©gorie √† tracer par l‚Äôutilisateur. Il faudrait g√©n√©-
rer automatiquement les pointcut correspondant aux cat√©gories d√©finies via le m√©tamod√®le des
op√©rations. Enfin, il est pr√©vu de g√©rer plus finement la d√©finition de cat√©gorie avec la possibi-
lit√© d‚Äôajouter de la s√©mantique dans la cr√©ation de r√®gles, par exemple avec l‚Äôutilisation d‚Äôun
interpr√©teur OCL.
R√©f√©rences
B√©zivin, P., M. Blay, M. Bouzhegoub, J. Estublier, J. Favre, S. G√©rard, et J.-M. J√©z√©quel (2004).
Rapport de Synth√®se de l‚ÄôAS CNRS sur le MDA (Model Driven Architecture).
Bond√©, L., P. Boulet, et J.-L. Dekeyser (2005). Traceability and interoperability at different
levels of abstraction in model transformations. In Forum on Specification and Design Lan-
guages,FDL‚Äô05, Lausanne, Switerland.
Budinsky, F., T. Grose, D. Steinberg, R. Ellersick, E. Merks, et S. Brodsky (2003). Eclipse
Modeling Framework : a developer‚Äôs guide. Addison-Wesley Professional.
Diaz, D., L. Seinturier, L. Duchien, et P. Flament (2007). Une aide √† la r√©alisation des √©volu-
tions logicielles gr√¢ce aux mod√®les de tra√ßabilit√© des fonctionnalit√©s. RSTI-L‚ÄôObjet 13(1),
pp. 117‚Äì145.
Falleri, J.-R., M. Huchard, et C. Nebut (2006). Towards a traceability framework in Kermeta.
In ECMDA-TW 2006 Proceedings, Bilbao, July 11th 2006, pp. 31 ‚Äì 40.
Fleurey, F., Z. Drey, D. Vojtisek, et C. Faucher (2006). Kermeta language Reference manual,
Internet : http ://www.kermeta.org/docs/KerMeta-Manual.pdf. IRISA.
Fowler, M., K. Beck, J. Brant, W. Opdyke, et D. Roberts (1999). Refactoring : Improving the
Design of Existing Code. Addison-Wesley Professional.
Gamma, E., R. Helm, R. Johnson, et J. Vlissides (1995). Design Patterns - Elements of Reu-
sable Object-Oriented Software. Addison-Wesley Professional.
Jouault, F. (2005). Loosely coupled traceability for ATL. In ECMDAWorkshop on traceability.
November 8th 2005, Nuremberg Germany, pp. 29‚Äì37.
Kiczales, G., J. Lamping, A. Menhdhekar, C. Maeda, C. Lopes, J.-M. Loingtier, et J. Irwin
(1997). Aspect-oriented programming. In M. Aks¬∏it et S. Matsuoka (Eds.), Proceedings Eu-
ropean Conference on Object-Oriented Programming, Volume 1241, pp. 220‚Äì242. Berlin,
Heidelberg, and New York : Springer-Verlag.
Kolovos, D. S., R. F. Paige, et F. A. Polack (2006). On-demand merging of traceability links
with models. In ECMDA-TW 2006 Proceedings, Bilbao, July 11th 2006, pp. 7 ‚Äì 15.
Lim√≤n, A. E. et J. Garbajosa (2005). The need for a unifying traceability scheme. In ECMDA
Workshop on traceability. November 8th 2005, Nuremberg Germany, pp. 47 ‚Äì 56.
Mens, T. et P. V. Gorp (2006). A taxonomy of model transformation. Electr. Notes Theor.
Comput. Sci. 152, pp. 125‚Äì142.
Tra√ßabilit√© des transformations imp√©ratives
Oldevik, J. et T. Neple (2006). Traceability in model to text transformation. In ECMDA-TW
2006 Proceedings, Bilbao, July 11th 2006, pp. 67 ‚Äì 72.
Pons, C. et R.-D. Kutsche (2004). Traceability across refinement steps in UML modeling. In
3rd Workshop in Software Model Engineering WiSME, 7th International Conference on the
UML.
Summary
This paper deals with Model-Driven Engineering and contributes to the issue of model
artefact traceability for imperative model transformations. The approach we propose requires
few interventions from the user. We introduce a generic trace metamodel that enables someone
to define multi-scaled traces thanks to the use of the Composite design pattern. The principle
of our approach is to monitor categories of interesting operations in order to generate relevant
traces. Those categories are defined based on the type of the objects handled by the operations.
Once the categories are defined, the trace is generated by dedicated code that is automatically
injected in the transformation, around the operations characterized by the defined categories.
A prototype has been implemented for model transformations written in Java, on the EMF
framework. The injection of the code dedicated to traceability is implemented using aspect-
oriented programming.
