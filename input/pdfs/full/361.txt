DÃ©couverte des dÃ©pendances fonctionnelles conditionnelles
frÃ©quentes
Thierno Dialloâˆ— et NoÃ«l Novelliâˆ—âˆ—
âˆ—UniversitÃ© de Lyon, LIRIS, CNRS-UMR5205
7 av. Jean Capelle, 69621 Villeurbanne Cedex, France
thierno.diallo@insa-lyon.fr
âˆ—âˆ—UniversitÃ© de la MÃ©diterranÃ©e, LIF, CNRS-UMR6166
Fac. des Sc. de Luminy, 163 av. de Luminy, 13288 Marseille Cedex 9, France
noel.novelli@lif.univ-mrs.fr
RÃ©sumÃ©. Les DÃ©pendances Fonctionnelles Conditionnelles (DFC) ont Ã©tÃ© in-
troduites en 2007 pour le nettoyage des donnÃ©es. Elles peuvent Ãªtre considÃ©rÃ©es
comme une unification de DÃ©pendances Fonctionnelles (DF) classiques et de
RÃ¨gles dâ€™Association (RA) puisquâ€™elles permettent de spÃ©cifier des dÃ©pendances
mixant des attributs et des couples de la forme attribut/valeur.
Dans cet article, nous traitons le problÃ¨me de la dÃ©couverte des DFC, i.e. dÃ©ter-
miner une couverture de lâ€™ensemble des DFC satisfaites par une relation r. Nous
montrons comment une technique connue pour la dÃ©couverte des DF (exactes
et approximatives) peut Ãªtre Ã©tendue aux DFC. Cette technique a Ã©tÃ© implÃ©men-
tÃ©e et des expÃ©riences ont Ã©tÃ© menÃ©es pour montrer la faisabilitÃ© et le passage Ã 
lâ€™Ã©chelle de notre proposition.
Mots clÃ©s: DÃ©pendances entre donnÃ©es, Fouille de donnÃ©es, ThÃ©orie des bases
de donnÃ©es.
1 Introduction
Les prÃ©cÃ©dents travaux sur lâ€™amÃ©lioration de la qualitÃ© des donnÃ©es sâ€™appuient principa-
lement sur les classes de contraintes traditionnelles telles que les DF ou encore les DF Ap-
proximatives (Kivinen et Mannila (1995)). MÃªme si les mesures g1, g2, et g3 pour les DF Ap-
proximatives capturent certaines erreurs, leur expression nâ€™est pas assez forte ou pas assez fine
pour capturer les donnÃ©es incohÃ©rentes de maniÃ¨re prÃ©cise. En effet, ces mesures permettent de
dÃ©tecter des erreurs sur les DF et non au niveau des classes de valeurs. RÃ©cemment, Bohannon
et al. (2007) ont Ã©tendu les DF aux DFC pour pallier ce problÃ¨me.
Dans cet article nous traitons le problÃ¨me de lâ€™infÃ©rence des DFC i.e. trouver une cou-
verture de lâ€™ensemble des DFC satisfaites dans une relation. Disposer de ces techniques de
dÃ©couverte permet entre autres dâ€™amÃ©liorer la performance des outils de nettoyage de donnÃ©es
basÃ©es sur les DFC. A notre connaissance deux contributions ont Ã©tÃ© faites sur la fouille de
DFC (Chiang et Miller (2008); Fan et al. (2009)). Chiang et Miller (2008) prÃ©sentent un outil
RNTI-E-19- 315 -
DÃ©couverte des DFC frÃ©quentes
de gestion de la qualitÃ© des donnÃ©es en proposant des rÃ¨gles et en identifiant des tuples incohÃ©-
rents. Ils prÃ©sentent aussi des mÃ©thodes pour la dÃ©couverte de DFC satisfaites, cependant des
DFC redondantes sont aussi gÃ©nÃ©rÃ©es. Fan et al. (2009) adaptent les mÃ©thodes bien connues
pour la dÃ©couverte des DF (TANE Huhtala et al. (1999b), FastFD Wyss et al. (2001)) pour
infÃ©rer sur les DFC.
Contribution Dans cet article, nous introduisons nos travaux sur le problÃ¨me de la dÃ©cou-
verte de DFC en utilisant la notion de partitions. Nous montrons que les techniques de fouilles
de donnÃ©es proposÃ©es pour la dÃ©couverte de dÃ©pendances fonctionnelles et de rÃ¨gles dâ€™asso-
ciations peuvent Ãªtre rÃ©utilisÃ©es pour la dÃ©couverte de DFC constantes et frÃ©quentes. Nous
montrons comment Ã©tendre une approche basÃ©e sur les notions dâ€™ensembles libres, fermeture
et quasi-fermeture pour lâ€™infÃ©rence de DF Ã  lâ€™infÃ©rence de DFC. Nous avons implÃ©mentÃ© cette
approche et rÃ©alisÃ© plusieurs expÃ©rimentations afin de prouver son efficacitÃ© lors du passage Ã 
lâ€™Ã©chelle.
Organisation de lâ€™article Dans la section 2, les notions de base concernant les DFC sont
donnÃ©es et nous introduisons une nouvelle notation pour les DFC. La section 3 est consacrÃ©e
Ã  la dÃ©couverte de DFC en offrant un cadre thÃ©orique et applicatif. Les expÃ©rimentations de
dÃ©couverte de DFC frÃ©quentes se trouvent Ã  la section 4. La derniÃ¨re section est consacrÃ©e Ã  la
conclusion de ce travail ainsi quâ€™Ã  ses perspectives.
2 PrÃ©liminaires
Les notations utilisÃ©es sont celles empruntÃ©es Ã  Bohannon et al. (2007). Chaque attribut A
a un domaine notÃ© DOM(A). Soit une relation r sur un schÃ©ma R avec A âˆˆ R, le domaine
actif de A dans r est notÃ© ADOM(A, r).
Exemple 1 Nous empruntons lâ€™exemple fourni dans Bohannon et al. (2007) pour illustrer le
concept de DFC. Soit cust un schÃ©ma de relation dÃ©crivant un client avec : country code
r0 CC AC PN NM STR CT ZIP
t1 : 01 908 1111111 Mike Tree Ave. NYC 07974
t2 : 01 908 1111111 Rick Tree Ave. NYC 07974
t3 : 01 212 2222222 Joe Elm Str. NYC 01202
t4 : 01 212 2222222 Jim Elm Str. NYC 01202
t5 : 01 215 3333333 Ben Oak Av. PHI 01202
t6 : 44 131 4444444 Ian High St. EDI 03560
t7 : 44 140 5555555 Kim High St. PHI 03560
FIG. 1 â€“ Relation r0 sur le schÃ©ma cust(CC), area code (AC), phone number (PN), name (NM), street (STR), city (CT) and zip code
(ZIP). La figure 1 illustre une relation, r0, sur ce schÃ©ma. Soient f1 = CC,AC,PN â†’
STR,CT,ZIP , f2 = CC,AC â†’ CT,ZIP et f3 = CC,ZIP â†’ STR trois DF. r0 satisfait
f1 et f2 mais viole f3 (e.g. tuples t4 et t5). Lâ€™intuition derriÃ¨re les DFC est dâ€™extraire Ã  travers
une formule de sÃ©lection (Ã©galitÃ©) un sous ensemble de la relation sur lequel on peut dÃ©finir
des DF. Par exemple la DF f3 : CC,ZIP â†’ STR pour ÏƒCC=44(r0) peut Ãªtre exprimÃ©e Ã 
lâ€™aide de la DFC Ï†0 = (CC,ZIP â†’ STR, (44, _ â€– _)) oÃ¹ â€˜â€–â€™ sÃ©pare la partie gauche de la
partie droite et â€˜_â€™ reprÃ©sente nâ€™importe quelle valeur du domaine de lâ€™attribut correspondant.
RNTI-E-19 - 316 -
T. Diallo et N. Novelli
Dâ€™autres DFC comme Ï†1 = (CC,AC,PN â†’ STR,CT,ZIP (01, 908, _ â€– _, NY C, _)),
Ï†2 = (CC,AC,PN â†’ STR,CT,ZIP (01, 212, _ â€– _, PHI, _)) ou Ï†3 = (CC,AC â†’
CT (01, 215 â€– PHI)) peuvent Ãªtre dÃ©finies sur r0.
Soit R un schÃ©ma de relation. Une DFC Ï sur R est une paire (X â†’ Y, Tp) oÃ¹ XY âŠ† R,
X â†’ Y une DF et Tp un pattern tableau dâ€™attributs de R.
Pour chaque A âˆˆ R et pour chaque pattern tuple tp âˆˆ Tp, tp[A] est soit une constante
âˆˆ DOM(A), soit la â€œvariable sans nomâ€ notÃ©e â€™_â€™ si A âˆˆ XY , soit la â€œvariable videâ€ notÃ©e
â€™âˆ—â€™ qui indique que lâ€™attribut correspondant ne contribue pas au pattern (i.e. A âˆˆ Râˆ’XY ).
Soit r une relation sur R, X âŠ† R et Tp un pattern tableau sur R. Un tuple t âˆˆ r matche
un tuple tp âˆˆ Tp sur X , notÃ© t[X]  tp[X], ssi âˆ€A âˆˆ X , t[A] = tp[A], ou tp[A] =â€™_â€™, ou
tp[A] =â€™âˆ—â€™.
Soit r une relation sur R et Ï = (X â†’ Y, T ) une DFC avec XY âŠ† R :
â€“ r satisfait Ï, notÃ© r |= Ï, ssi âˆ€ti, tj âˆˆ r et âˆ€tp âˆˆ T , si ti[X] = tj [X]  tp[X] alors
ti[Y ] = tj [Y ]  tp[Y ].
â€“ r viole la DFC Ï = (X â†’ Y, T ), notÃ©e r |= Ï, ssi
â€“ il existe un tuple t âˆˆ r et un pattern tuple tp âˆˆ T tel que t[X]  tp[X] et t[Y ]  tp[Y ]
ou
â€“ il existe ti, tj âˆˆ r et un pattern tuple tp âˆˆ T tel que ti[X] = tj [X]  tp[X] et
ti[Y ] = tj [Y ].
Exemple 2 La relation r0 (cf. figure 1) satisfait les DFC Ï†0, Ï†1 et Ï†3 alors quâ€™elle ne satisfait
pas les deux DFC Ï†2 et Ï†4 suivantes :
â€“ Ï†2 = (CC,AC,PN â†’ STR,CT,ZIP (01, 212, _ â€– _, PHI, _)) car le tuple t3 viole
Ï†2 : t3 [CC,AC,PN ]  (01, 212, _) mais t3 [STR,CT,ZIP ]  (_, PHI, _).
â€“ Ï†4 = ([CC,CT ] â†’ ZIP, (01, _ â€– _)) car t2 et t3 violent Ï†4 puisque t2 [CC,CT ] =
t3 [CC,CT ]  (01, _), mais t2 [ZIP ] = t3 [ZIP ].
Une DFC (X â†’ Y, Tp) est dite Ã  la forme normale (Fan et al. (2008)), lorsque |Y | = 1 et
|Tp| = 1. Par la suite nous nâ€™Ã©tudions que les DFC Ã  la forme normale.
Une DFC (X â†’ A, tp) est dite :
â€“ constante si tp [XA] nâ€™est constituÃ© que de constantes.
â€“ variable si la partie droite de son pattern tuple est une variable sans nom.
3 DÃ©couverte des DFC constantes et frÃ©quentes
Nous souhaitons dÃ©couvrir les DFC constantes et frÃ©quentes prÃ©sentes dans une relation,
i.e. les DFC pour lesquelles le nombre de tuples de la relation les satisfaisant est supÃ©rieur Ã 
un seuil de frÃ©quence donnÃ©.
Pour cela, nous Ã©tablissons un cadre thÃ©orique offrant une caractÃ©risation simple et solide
sur laquelle sâ€™appuie une implÃ©mentation efficace utilisant la notion de partition.
3.1 Cadre thÃ©orique
Nous commenÃ§ons par dÃ©finir les notations nÃ©cessaires pour caractÃ©riser lâ€™espace de re-
cherche et lâ€™expression de DFC puis nous poursuivons par une caractÃ©risation permettant la
dÃ©couverte de DFC dans une relation existante.
RNTI-E-19- 317 -
DÃ©couverte des DFC frÃ©quentes
DÃ©finition 1 Soit R un schÃ©ma de relation. Lâ€™espace de recherche des DFC constantes sur R,
notÃ© SPCFD(R), est dÃ©fini comme suit :
SPCFD(R) = {(A, a) | A âˆˆ R, a âˆˆ DOM(A)}
Ainsi toute DFC constante peut Ãªtre reprÃ©sentÃ©e Ã  lâ€™aide des Ã©lÃ©ments de cet espace. Soit Ï =
(A1 . . . An â†’ A, tp[A1 . . . AnA]) une DFC constante sur R. Ï est Ã©quivalent Ã  X â†’ A, avec
X = {(A1, tp[A1]), . . . , (An, tp[An])} âŠ† SPCFD(R) et A = (A, tp[A]) âˆˆ SPCFD(R).
Soit X âŠ† SPCFD(R), X.att reprÃ©sente lâ€™union de tous les attributs appartenant Ã  X .
DÃ©finition 2 Soit R un schÃ©ma de relation et r une relation sur R. Lâ€™espace de recherche des
DFC constantes pour r, notÃ© ASPCFD(R, r), est dÃ©fini comme suit :
ASPCFD(R, r) = {(A, a) | A âˆˆ R, a âˆˆ ADOM(A, r)}
Les Ã©lÃ©ments de ASPCFD(R, r) sont appelÃ©s des ensembles dâ€™attributs conditionnels.
Exemple 3 Soit r la relation de la figure 2. Nous notons le couple (Ai, v) par Aiv.
ASPCFD(ABCD, r) = {A0, A2, B0, B1, B2, C0, C3, D1, D2}
r A B C D
t1 : 0 1 0 2
t2 : 0 1 3 2
t3 : 0 0 0 1
t4 : 2 2 0 1
t5 : 2 1 0 1
FIG. 2 â€“ Une relation r sur R = ABCD
Une DFC X â†’ A sur R est dite triviale si A.att âˆˆ X.att. Dans notre Ã©tude nous ne
considÃ©rons que les DFC non triviales. Une DFC constante X â†’ A est rÃ©duite Ã  gauche sur
r si âˆ€ X â€².att âŠ‚ X.att, r |= X â€² â†’ A. Une DFC minimale (Fan et al. (2008)) Ï sur r est non
triviale, rÃ©duite Ã  gauche et telle que r |= Ï. Une couverture canonique dâ€™un ensemble Î£r de
DFC est un ensemble Î£cc de DFC minimales tel que Î£r est Ã©quivalent Ã  Î£cc.
Etant donnÃ© une relation r notre problÃ¨me est dâ€™Ã©numÃ©rer la couverture canonique des DFC
satisfaites par r.
La propriÃ©tÃ© suivante montre la monotonie des DFC ce qui correspond Ã  un ordre partiel.
PropriÃ©tÃ© 1 Soit r une relation sur R,X, Y âŠ† ASPCFD(R, r) tel que X âŠ† Y et A âˆˆ
ASPCFD(R, r). Nous avons : r |= X â†’ Aâ‡’ r |= Y â†’ A.
A lâ€™aide de ces nouvelles notations, la fermeture dâ€™un ensemble dâ€™attributs conditionnels
dÃ©finie dans Fan et al. (2008) peut Ãªtre facilement rÃ©-Ã©crite.
DÃ©finition 3 Soit Î£ une DFC constante et X âŠ† SPCFD(R). La fermeture de X sur Î£, notÃ©e
X
âˆ—
Î£, est dÃ©finie comme suit : X
âˆ—
Î£ = {A âˆˆ SPCFD(R) | Î£ |= X â†’ A}.
RNTI-E-19 - 318 -
T. Diallo et N. Novelli
Lâ€™opÃ©rateur .âˆ—Î£ dÃ©fini sur lâ€™ensemble des parties de SPCFD(R) est un opÃ©rateur de fermeture,
i.e. extensible, monotone et idempotent.
Intuitivement, la frÃ©quence dâ€™une DFC dans une relation est le nombre de tuples qui satis-
font le pattern tuple, i.e. la taille de la requÃªte de sÃ©lection correspondante.
DÃ©finition 4 Soit Î¸ = (X â†’ Y ) une DFC constante sur R et r une relation sur R. La frÃ©quence
de Î¸ dans r, notÃ©e freq(Î¸, r), est dÃ©finie comme suit :
freq(Î¸, r) = |Ïƒâˆ§(A,v)âˆˆXâˆªY (A=v)(r)|
Soit  un entier reprÃ©sentant la valeur dâ€™un seuil. Une DFC Î¸ est dite frÃ©quente dans r, si
freq(Î¸, r) â‰¥ .
Cette dÃ©finition est importante pour Ã©liminer ou rÃ©duire lâ€™impact des donnÃ©es impropres
contenues dans une relation. En effet, seules les donnÃ©es suffisamment prÃ©sentes sont prises en
compte ce qui gomme par exemple les erreurs de saisie ce qui correspond Ã  la mÃªme philoso-
phie que la mesure g3 introduite dans Kivinen et Mannila (1995).
Bien Ã©videmment, ce prÃ©dicat est monotone ce qui entraine la propriÃ©tÃ© suivante.
PropriÃ©tÃ© 2 Soit r une relation sur R,X, Y âŠ† ASPCFD(R, r) tels que X âŠ† Y et  un seuil.
Nous avons : freq(Y , r) â‰¥ â‡’ freq(X, r) â‰¥  (ou freq(X, r) < â‡’ freq(Y , r) < )
Nous avons besoin de dÃ©finir un test afin de dÃ©cider si une DFC est valide ou non dans une
relation. Depuis longtemps, nous savons quâ€™une telle propriÃ©tÃ© existe pour tester la satisfaction
dâ€™une DF dans une relation. La propriÃ©tÃ© suivante est souvent utilisÃ©e : r |= X â†’ Y ssi
|X|r = |XY |r.
Pour les DFC, une propriÃ©tÃ© similaire peut Ãªtre obtenue. Câ€™est ce que nous montrons ci-
aprÃ¨s en utilisant lâ€™opÃ©rateur de sÃ©lection de lâ€™algÃ¨bre relationnelle.
PropriÃ©tÃ© 3 Soit R un symbole de relation, r une relation sur R, X,Y âŠ† ASPCFD(R, r) et
CX , CY deux formules de sÃ©lection sur X et Y respectivement.
r |= X â†’ Y ssi |ÏƒC
X
(r)| = |ÏƒC
X
âˆ§C
Y
(r)| oÃ¹ CX = âˆ§(A,v)âˆˆX(A = v) et CY =
âˆ§(A,v)âˆˆY (A = v)
Nous pouvons maintenant introduire les dÃ©finitions qui nous permettront dâ€™Ã©tablir une ca-
ractÃ©risation solide permettant la dÃ©couverte de DFC.
DÃ©finition 5 Ensembles conditionnels libres
Soit X âŠ† ASPCFD(R, r) un ensemble dâ€™attributs conditionnels.
X est un ensemble conditionnel libre dans r ssi  âˆƒX â€² âŠ‚ X tel que |ÏƒC
Xâ€²
(r)| = |ÏƒC
X
(r)|.
Lâ€™ensemble des ensembles conditionnels libres dans r est notÃ© CFSr. Tout ensemble dâ€™at-
tributs conditionnels qui nâ€™est pas inclus dans CFSr est appelÃ© un ensemble conditionnel non
libre.
PropriÃ©tÃ© 4 Soit r une relation sur R,X, Y âŠ† ASPCFD(R, r) tel que X âŠ† Y . Nous avons :
Y âˆˆ CFSr â‡’ X âˆˆ CFSr (ou de faÃ§on Ã©quivalente X âˆˆ CFSr â‡’ Y âˆˆ CFSr)
RNTI-E-19- 319 -
DÃ©couverte des DFC frÃ©quentes
A partir des propriÃ©tÃ©s et des dÃ©finitions introduites dans cette section, il est Ã©vident que
les algorithmes par niveau (comme Apriori) peuvent Ãªtre utilisÃ©s pour dÃ©couvrir les ensembles
conditionnels libres (conjonction de deux prÃ©dicats monotones). A partir des ensembles condi-
tionnels libres, nous Ã©tendons les rÃ©sultats donnÃ©s dans Novelli et Cicchetti (2001a,b) (pour
lâ€™infÃ©rence de DF) pour proposer une nouvelle caractÃ©risation de la couverture canonique des
DFC qui tient compte dâ€™un seuil de frÃ©quence. Elle est basÃ©e sur les ensembles conditionnels
libres, leur fermeture et leur quasi-fermeture.
DÃ©finition 6 Fermeture dâ€™un ensemble dâ€™attributs conditionnels dans une relation
Soit X un ensemble dâ€™attributs conditionnels, X âŠ† ASPCFD(R, r). Sa fermeture dans r est
dÃ©finie comme suit : X
âˆ—
Î£r = X âˆª {A | A.att âˆˆ Râˆ’X.att âˆ§ |ÏƒCX (r)| = |ÏƒCXâˆ§CA(r)|}.
DÃ©finition 7 Quasi-fermeture dâ€™un ensemble dâ€™attributs conditionnels dans une relation
La quasi-fermeture dâ€™un ensemble dâ€™attributs conditionnels X âŠ† ASPCFD(R, r), notÃ© XÎ£r ,
est dÃ©finie par :
X

Î£r = X âˆª
â‹ƒ
AâˆˆX
(X âˆ’A)âˆ—Î£r
GrÃ¢ce Ã  la propriÃ©tÃ© de monotonie de lâ€™opÃ©rateur de fermeture, nous avons :X âŠ† XÎ£r âŠ† X
âˆ—
Î£r
ce qui nous permet de rÃ©Ã©crire la dÃ©finition 6 de la faÃ§on suivante.
DÃ©finition 8 Fermeture dâ€™un ensemble dâ€™attributs conditionnels dans une relation
Soit X un ensemble dâ€™attributs conditionnels, X âŠ† ASPCFD(R, r). Sa fermeture dans r est
redÃ©finie comme suit :X
âˆ—
Î£r = X

Î£r âˆª{A | A.att âˆˆ Râˆ’X

.attâˆ§ |ÏƒC
X
(r)| = |ÏƒC
X
âˆ§C
A
(r)|}.
La notion de quasi-fermeture est utilisÃ©e pour accumuler les fermetures des sous ensembles
propres de lâ€™attribut conditionnel considÃ©rÃ©. Ceci nous permet dans le thÃ©orÃ¨me suivant de ga-
rantir la minimalitÃ© des DFC extraites.
Le thÃ©orÃ¨me suivant prouve que lâ€™ensemble de DFC constantes caractÃ©risÃ© Ã  lâ€™aide des concepts
introduits est la couverture canonique des DFC constantes pour la relation r.
ThÃ©orÃ¨me 1 Î£cc(r, ) = {X â†’ A | X âˆˆ CFSr, freq(X, r) â‰¥  et A âˆˆ Xâˆ—Î£r âˆ’X

Î£r}
La frÃ©quence freq(X, r) Ã©tant utilisÃ©e pour filtrer les DFC frÃ©quentes, elle nâ€™a pas Ã  inter-
venir dans la dÃ©monstration.
Preuve 1 Supposons tout dâ€™abord que la DFC X â†’ A âˆˆ CC(r, ) (DFC minimale et non
triviale). Nous avons donc âˆ€ X â€² âŠ‚ X , |X â€²|r = |X|r donc X âˆˆ CFSr (conformÃ©ment Ã  la
dÃ©finition 5). De plus, A âˆˆ Xâˆ—Î£r puisque la DFC est valide. Elle est minimale donc A âˆˆ X

Î£r
(cf. DÃ©finition 8). Donc si la DFC X â†’ A âˆˆ CC(r, ) alors X âˆˆ CFSr et A âˆˆ Xâˆ—Î£r âˆ’X

Î£r .
Supposons maintenant que X âˆˆ CFSr et A âˆˆ Xâˆ—Î£r âˆ’ X

Î£r . Puisque A âˆˆ X
âˆ—
Î£r , A est
dÃ©terminÃ©e parX , donc r |= X â†’ A. Elle est minimale puisqueX âˆˆ CFSr donc âˆ€X â€² âŠ‚ X ,
|X â€²|r = |X|r et non triviale puisque A âˆˆ XÎ£r . Donc X â†’ A âˆˆ CC(r, ).
Exemple 4 Pour illustrer cette section (cf. figure 3), nous utilisons la relation dÃ©jÃ  dÃ©crite (cf.
figure 2). La premiÃ¨re colonne du tableau suivant reprÃ©sente le candidat X qui peut Ãªtre un
ensemble conditionnel libre ou non libre. Les candidats prÃ©cÃ©dÃ©s dâ€™un â€™*â€™ sont des ensembles
conditionnels non libres. La deuxiÃ¨me colonne correspond Ã  la cardinalitÃ© de X et pour finir,
les deux derniÃ¨res colonnes reprÃ©sentent la quasi-fermeture conditionnelle (X

Î£) et la ferme-
ture conditionnelle (X
âˆ—
Î£) de X . A droite, les DFC dÃ©couvertes sont affichÃ©es.
RNTI-E-19 - 320 -
T. Diallo et N. Novelli
X |X| XÎ£ X
âˆ—
Î£
A0 3 A0 A0
A2 2 A2 A2 C0 D1 Aâ†’ CD (2 || 0, 1)
B1 3 B1 B1
B0 1 B0 A0 B0 C0 D1 Bâ†’ ACD (0 || 0, 0, 1)
B2 1 B2 A2 B2 C0 D1 Bâ†’ ACD (2 || 2, 0, 1)
C0 4 C0 C0
C3 1 C3 A0 B1 C3 D2 Câ†’ ABD (3 || 0, 1, 2)
D2 2 D2 A0 B1 D2 Dâ†’ AB (2 || 0, 1)
D1 3 D1 C0 D1 Dâ†’ C (1 || 0)
A0 B1 2 A0 B1 A0 B1 D2 ABâ†’ D (0, 1 || 2)
*A0 B0 1 A0 B0 C0 D1 A0 B0 C0 D1
A2 B1 1 A2 B1 C0 D1 A2 B1 C0 D1
*A2 B2 1 A2 B2 C0 D1 A2 B2 C0 D1
A0 C0 2 A0 C0 A0 C0
*A0 C3 1 A0 B1 C3 D2 AO B1 C3 D2
*A2 C0 2 A2 C0 D1 A2 C0 D1
*A0 D2 2 A0 B1 D2 A0 B1 D2
A0 D1 1 A0 C0 D1 A0 B0 C0 D1 ADâ†’ B (0, 1 || 0)
A2 D1 2 A2 C0 D1 A2 C0 D1
... ... ... ...
FIG. 3 â€“ Illustration de la caractÃ©risation proposÃ©e
3.2 ImplÃ©mentation de lâ€™approche
Le cadre thÃ©orique proposÃ© est trÃ¨s bien adaptÃ© Ã  une approche par niveau pour lâ€™implÃ©-
mentation de la dÃ©couverte de DFC. Notre algorithme, appelÃ© CFUN, est donc basÃ© sur les
concepts dâ€™Apriori afin de dÃ©couvrir lâ€™ensemble des ensembles conditionnels libres. Une fois
ces derniers dÃ©couverts pour chaque niveau ainsi que les valeurs correspondantes de frÃ©quence
(comptage), quasi-fermeture et fermeture, la dÃ©couverte des DFC est triviale suivant le thÃ©o-
rÃ¨me 1.
Cette philosophie est la mÃªme que celle utilisÃ©e pour lâ€™extraction de DF de lâ€™approche FUN de
Novelli et Cicchetti (2001a,b).
Algorithme CFUN Lâ€™algorithme gÃ©nÃ©ral, donnÃ© ci-aprÃ¨s, initialise les niveaux L0 (ligne 1)
et L1 (ligne 2) avant de commencer Ã  proprement dit la boucle de calcul niveau par niveau
(lignes 3-8). Cette derniÃ¨re calcule tout dâ€™abord la fermeture (ligne 4) de tous les attributs
conditionnels du niveau Lkâˆ’1 Ã  lâ€™aide du niveau Lk (comparaison de frÃ©quences) puis cal-
cule les quasi-fermetures (ligne 5) du niveau Lk Ã  partir des fermetures obtenues au niveau
prÃ©cÃ©dant Lkâˆ’1 (DÃ©finition 6). Une fois les fermetures et quasi-fermetures du niveau Lkâˆ’1
calculÃ©es il est trivial dâ€™afficher les DFC frÃ©quentes obtenues Ã  ce niveau (ThÃ©orÃ¨me 1). Une
phase dâ€™Ã©lagage Ã©limine les Ã©lÃ©ments du niveau courant qui nâ€™appartiennent pas Ã  CFSr (ligne
7). Ceci permet lors de la gÃ©nÃ©ration des candidats du niveau suivant (ligne 8) que seuls les
sur-ensembles des ensembles conditionnels libres soient considÃ©rÃ©s. Lâ€™algorithme se termine
RNTI-E-19- 321 -
DÃ©couverte des DFC frÃ©quentes
en affichant les DFC dÃ©couvertes au dernier niveau (ligne 9).
Chaque niveau contient des quadruplets < X , |X|, XÎ£, X
âˆ—
Î£ > comme le montre la figure 3.
Algorithm CFUN
1 L0 := < âˆ…, 1, âˆ…, âˆ… >
2 L1 := { < A, |A|, A, A > | A âˆˆ ASPCFD(R, r) âˆ§ |A.att| = 1 }
3 for ( k := 1 ; Lk = âˆ… ; k := k + 1 ) do
4 ComputeClosure( Lkâˆ’1, Lk )
5 ComputeQuasiClosure( Lk , Lkâˆ’1 )
6 DisplayCFD( Lkâˆ’1 )
7 PruneNonFreeSets( Lk , Lkâˆ’1 )
8 Lk+1 := GenerateCandidate( Lk )
9 DisplayCFD( Lkâˆ’1 )
end CFUN
La phase de gÃ©nÃ©ration de candidats requiert une attention toute particuliÃ¨re. En effet, il
ne faut pas gÃ©nÃ©rer de combinaison dâ€™attributs conditionnels qui nâ€™existe pas dans la relation
considÃ©rÃ©e (par exemple, la combinaison AA). Pour Ã©viter ces erreurs de gÃ©nÃ©ration de candi-
dats, nous avons utilisÃ© la notion de partition.
Optimisation et ressource mÃ©moire nÃ©cessaire Afin de pallier le problÃ¨me de gÃ©nÃ©ration
et dâ€™optimiser les calculs, nous avons optÃ© pour une structure interne de reprÃ©sentation de
lâ€™information basÃ©e sur la notion de partitions introduite par Cosmadakis et al. (1986); Spy-
ratos (1987). Lâ€™opÃ©ration de partitionnement dâ€™une relation r selon un ensemble dâ€™attributs
X consiste Ã  regrouper en classes dâ€™Ã©quivalence, les tuples ayant mÃªme valeur pour X . Lâ€™en-
semble des classes dâ€™Ã©quivalence constitue une partition de r selon X . Les partitions peuvent
Ãªtre reprÃ©sentÃ©es de deux maniÃ¨res efficaces dâ€™aprÃ¨s Novelli et Maabout (2003) : soit on utilise
un vecteur de numÃ©ros de classe dâ€™Ã©quivalence dont lâ€™indexation se fait par le numÃ©ro du tuple ;
soit on utilise un vecteur dâ€™identifiants de tuples rangÃ©s dans lâ€™ordre des classes dâ€™Ã©quivalence
ce qui est trÃ¨s bien adaptÃ© aux calculs de DF (cf. Huhtala et al. (1998, 1999a); Lopes et al.
(2000); Novelli et Cicchetti (2001a,b)) et donc pour les DFC. De plus, le produit de partitions
proposÃ© dans Novelli et Maabout (2003) nous permet aussi de calculer trÃ¨s rapidement les
frÃ©quences de chaque attributs conditionnels en ne gÃ©nÃ©rant pas les combinaisons inexistantes
dans la relation.
Exemple 5 Pour illustrer lâ€™utilisation des partitions, nous reprenons la relation de la figure 2.
Le seuil est fixÃ© Ã  1. Les partitions suivant les attributs A et C sont Ï€A = {(1, 2, 3), (4, 5)} et
Ï€C = {(1, 3, 4, 5), (2)}. Les valeurs correspondantes aux classes dâ€™Ã©quivalence sont 0, 2 pour
A et 0, 3 pour C. Le produit de Ï€A et Ï€C est Ï€AC = {(1, 3), (2), (4, 5)}. Les valeurs corres-
pondantes sont (0, 0), (0, 3) et (2, 0). Ceci nous fournit directement les attributs conditionnels
avec leur frÃ©quence : freq(< A0 >) = 3, freq(< A2 >) = 2, freq(< C0 >) = 4, freq(<
C3 >) = 1, freq(< A0, C0 >) = 2, freq(< A0, C3 >) = 1, freq(< A2, C0 >) = 2.
Dâ€™oÃ¹ la DFC A â†’ C(2||0) est valide puisque freq(< A2 >) = freq(< A2, C0) >) = 2.
De plus, aucune combinaison impossible nâ€™a Ã©tÃ© gÃ©nÃ©rÃ©e.
Pour une relation Ã  n tuples et k attributs, le nombre correspondant de combinaisons dâ€™attributs
est de 2k (ensemble des parties). Dans le pire des cas, chaque combinaison dâ€™attributs engendre
n combinaisons dâ€™attributs conditionnels (toutes les valeurs de cette combinaison dâ€™attributs
sont distinctes). Cela implique que dans le pire des cas le nombre total dâ€™attributs conditionnels
est de n Ã— 2k. Chaque attribut conditionnel est reprÃ©sentÃ© par un quadruplet dâ€™entier (4 Ã—
RNTI-E-19 - 322 -
T. Diallo et N. Novelli
4 octets) ce qui signifie que la quantitÃ© maximale de mÃ©moire pour conserver la totalitÃ© des
niveaux de notre approche est de 16nÃ— 2k octets.
Lâ€™algorithme proposÃ© Ã©tant par niveau, seuls deux niveaux sont obligatoirement conservÃ©s en
mÃ©moire. De fait, les besoins mÃ©moire sont trÃ¨s facilement rÃ©duits Ã  16n Ã— 2( kk/2) octets soit
Ã  la partie la plus large du treillis de combinaisons dâ€™attributs (les deux niveaux centraux).
4 ExpÃ©rimentations
Afin dâ€™Ã©valuer les performances, lâ€™approche dÃ©crite dans la section 3.1 a Ã©tÃ© implÃ©mentÃ©e
en C++. Lâ€™exÃ©cutable peut Ãªtre obtenu Ã  lâ€™aide des compilateurs MS Visual C++ 9.0 ou GNU
g++. DiffÃ©rentes expÃ©rimentations ont Ã©tÃ© rÃ©alisÃ©es sur un ordinateur Ã©quipÃ© dâ€™un processeur
Pentium Centrino 2 GHz avec 2 Go de RAM avec un systÃ¨me Linux.
Au moment de la rÃ©daction de lâ€™article, les auteurs des approches existantes (Chiang et
Miller (2008); Fan et al. (2009)) nâ€™ont pas encore pu nous faire parvenir un exÃ©cutable ou le
code source de leurs approches. De fait, nous nâ€™avons pas pu comparer notre proposition avec
les leurs. Toutefois, nous avons utilisÃ© les mÃªmes jeux de donnÃ©es rÃ©elles ce qui nous permet
dâ€™effectuer une comparaison approximative grossiÃ¨re des rÃ©sultats. Pour les expÃ©rimentations
sur des donnÃ©es rÃ©elles, nous avons utilisÃ© Winsconsin breast cancer (WBC) et Chess datasets
(comme les approches citÃ©es) issues du UCI machine learning repository1.
Le tableau suivant rÃ©sume les caractÃ©ristiques des jeux de donnÃ©es rÃ©elles.
Datasets #Attributs #Tuples Taille (Ko)
Wirsconsin Breast Cancer 11 699 19 917
Chess 7 28 056 531 820
La figure 4 montre le comportement de notre approche sur les donnÃ©es rÃ©elles dÃ©crites prÃ©-
cÃ©demment lorsque le seuil de frÃ©quence des DFC varie. La courbe de gauche reprÃ©sente les
temps dâ€™exÃ©cution en seconde alors que celle de droite illustre les consommations mÃ©moire en
Mo. Comme attendu, quand le support minimal augmente, le temps dâ€™exÃ©cution et la consom-
mation mÃ©moire diminuent.
Nous avons aussi gÃ©nÃ©rÃ© des donnÃ©es synthÃ©tiques avec notre propre gÃ©nÃ©rateur de don-
nÃ©es : câ€™est un gÃ©nÃ©rateur uniforme de donnÃ©es pour chaque colonne indÃ©pendamment des
autres colonnes de la relation. Les jeux de donnÃ©es synthÃ©tiques sont automatiquement gÃ©nÃ©-
rÃ©s Ã  lâ€™aide des paramÃ¨tres suivants : |r| reprÃ©sente la cardinalitÃ© de la relation, |R| correspond
au degrÃ© de la relation et c fixe le taux de corrÃ©lation entre les valeurs dâ€™un attribut. Plus ce
taux est grand, plus le nombre de DFC satisfaites dans la relation augmente.
La figure 5 illustre le comportement lorsque le nombre de tuples augmente de 5 000 Ã 
50 000 pour diffÃ©rents jeux de donnÃ©es synthÃ©tiques. Le taux de corrÃ©lation de donnÃ©es est
fixÃ© Ã  30% pour montrer le passage Ã  lâ€™Ã©chelle de notre proposition en fonction du nombre de
tuples. En effet, cela permet de fixer le nombre de DFC satisfaites indÃ©pendamment du nombre
de tuples. Le support est fixÃ© Ã  1 afin quâ€™aucune technique dâ€™Ã©lagage ne soit appliquÃ©e ce qui
correspond au pire cas dâ€™extraction de DFC. Les besoins mÃ©moire et le temps dâ€™exÃ©cution sont
linÃ©aires au nombre de tuples de la relation considÃ©rÃ©e.
La figure 6 illustre le comportement de notre approche lorsque le taux de corrÃ©lation de
donnÃ©es varie de 30% Ã  70% sur diffÃ©rents jeux de donnÃ©es synthÃ©tiques avec un nombre fixe
1http ://archive.ics.uci.edu/ml
RNTI-E-19- 323 -
DÃ©couverte des DFC frÃ©quentes
 0
 0.1
 0.2
 0.3
 0.4
 0.5
 0  10  20  30  40  50  60  70  80  90 100
E
xe
cu
tio
n 
T
im
e 
(s
)
Minimal support of frequent CFD
WBC
Chess
 0
 2
 4
 6
 8
 10
 12
 14
 16
 18
 0  10  20  30  40  50  60  70  80  90 100
M
em
or
y 
us
ag
e 
(M
o)
Minimal support of frequent CFD
WBC
Chess
FIG. 4 â€“ Temps dâ€™exÃ©cution et consommation mÃ©moire pour les jeux de donnÃ©es rÃ©ellesWis-
concin Breast Cancer et chess
 0
 0.1
 0.2
 0.3
 0.4
 0.5
 0.6
 0.7
 0.8
 0  10  20  30  40  50  60  70  80  90 100
E
xe
cu
tio
n 
tim
e 
(s
)
Number of tuples (x1000)
 0
 10
 20
 30
 40
 50
 60
 70
 80
 0  10  20  30  40  50  60  70  80  90 100
M
em
or
y 
us
ag
e 
(M
o)
Number of tuples (x1000)
FIG. 5 â€“ Temps dâ€™exÃ©cution et consommation mÃ©moire pour diffÃ©rentes cardinalitÃ©s
 0
 0.005
 0.01
 0.015
 0.02
 30  35  40  45  50  55  60  65  70
E
xe
cu
tio
n 
T
im
e 
(s
)
Data correlation rates
 0
 0.5
 1
 1.5
 2
 2.5
 3
 3.5
 4
 30  35  40  45  50  55  60  65  70
M
em
or
y 
us
ag
e
Data correlation rates
FIG. 6 â€“ Temps dâ€™exÃ©cution et besoin mÃ©moire pour diffÃ©rents taux de corrÃ©lation
de tuples (5 000) et dâ€™attributs (7). Lâ€™idÃ©e est dâ€™Ã©tudier le comportement de notre algorithme
lorsque la taille de lâ€™espace de recherche des attributs conditionnels croÃ®t.
Le temps dâ€™exÃ©cution et les besoins mÃ©moire augmentent lÃ©gÃ¨rement en fonction du taux
de corrÃ©lation ce qui est un rÃ©sultat surprenant en raison de la complexitÃ© exponentielle inhÃ©-
rente. La principale raison est due Ã  lâ€™efficacitÃ© de notre implÃ©mentation basÃ©e sur les partitions
RNTI-E-19 - 324 -
T. Diallo et N. Novelli
de valeurs des attributs et leur produit (Novelli et Maabout (2003)).
En outre, il est intÃ©ressant de noter que notre mise en Å“uvre ne consomme que peu de
mÃ©moire. Par exemple, pour un ensemble de donnÃ©es synthÃ©tiques avec 1 000 000 de tuples
et 9 attributs, le temps dâ€™exÃ©cution approche 31 secondes en nâ€™utilisant que 1 Go de mÃ©moire
principale.
5 Conclusion
Dans cet article, nous introduisons une nouvelle notation pour les dÃ©pendances fonction-
nelles conditionnelles rendant leur dÃ©couverte Ã  partir dâ€™une relation existante plus facile. Nous
avons proposÃ© lâ€™adaptation dâ€™une approche bien connue dans le contexte de lâ€™infÃ©rence de dÃ©-
pendances fonctionnelles Ã  la dÃ©couverte de DFC constantes frÃ©quentes. Elle est basÃ©e sur
lâ€™approche FUN (Novelli et Cicchetti (2001a,b)) et peut Ãªtre utilisÃ©e pour lâ€™extraction de DFC
constantes frÃ©quentes. Cette approche a Ã©tÃ© implÃ©mentÃ©e et testÃ©e sur diffÃ©rents jeux de don-
nÃ©es synthÃ©tiques et rÃ©elles.
Par souci de clartÃ©, nous mettons lâ€™accent dans cet article sur la dÃ©couverte de DFC constan-
tes. Dans lâ€™avenir, nous envisageons de traiter le problÃ¨me de la dÃ©couverte de DFC variables.
Deux approches sont en effet possibles : la premiÃ¨re consiste Ã  rÃ©duire lâ€™ensemble des DFC
constantes (si toutes les valeurs de ADOM(X, r) sont prÃ©sentes alors nous pouvons les sub-
stituer par â€™_â€™) pour obtenir un ensemble Ã©quivalent restreint de DFC variables. La seconde
consiste Ã  enrichir lâ€™approche actuelle pour obtenir des algorithmes dÃ©diÃ©s.
Une campagne approfondie dâ€™expÃ©rimentations reste Ã  faire pour Ã©valuer en profondeur
nos rÃ©sultats actuels.
Il est Ã  noter que lâ€™extraction de DFC frÃ©quentes partage certaines caractÃ©ristiques avec
le problÃ¨me dâ€™extraction de requÃªtes conjonctives frÃ©quentes de projection-sÃ©lection (voir par
exemple Jen et al. (2008)). Nous avons lâ€™intention dâ€™approfondir ces deux domaines afin dâ€™en
extraire de nouvelles techniques bÃ©nÃ©fiques Ã  leurs problÃ¨mes.
RÃ©fÃ©rences
Bohannon, P., W. Fan, F. Geerts, X. Jia, et A. Kementsietsidis (2007). Conditional functional
dependencies for data cleaning. In Proceedings of ICDEâ€™07, April 15-20, Istanbul, Turkey,
pp. 746â€“755.
Chiang, F. et R. J. Miller (2008). Discovering data quality rules. VLDB 1(1), 1166â€“1177.
Cosmadakis, S., P. Kanellakis, et N. Spyratos (1986). Partition Semantics for Relations. Jour-
nal of Computer and System Sciences 33(2), 203â€“233.
Fan, W., F. Geerts, X. Jia, et A. Kementsietsidis (2008). Conditional functional dependencies
for capturing data inconsistencies. ACM Trans. Database Syst. 33(2).
Fan, W., F. Geerts, L. V. S. Lakshmanan, et M. Xiong (2009). Discovering conditional func-
tional dependencies. In Proceedings of the 25th International Conference on Data Enginee-
ring, ICDE 2009, March 29 2009 - April 2 2009, Shanghai, China, pp. 1231â€“1234.
RNTI-E-19- 325 -
DÃ©couverte des DFC frÃ©quentes
Huhtala, Y., J. KÃ¤rkkÃ¤inen, P. Porkka, et H. Toivonen (1998). Efficient Discovery of Functional
and Approximate Dependencies Using Partitions. In ICDEâ€™98, Orlando, Florida, USA, pp.
392â€“401.
Huhtala, Y., J. Karkkainen, P. Porkka, et H. Toivonen (1999a). TANE : An Efficient Algorithm
for Discovering Functional and Approximate Dependencies. The Computer Journal 42(2),
100â€“111.
Huhtala, Y., J. KÃ¤rkkÃ¤inen, P. Porkka, et H. Toivonen (1999b). Tane : An efficient algorithm
for discovering functional and approximate dependencies. The Computer Journal 42(3),
100â€“111.
Jen, T.-Y., D. Laurent, et N. Spyratos (2008). Mining all frequent projection-selection que-
ries from a relational table. In EDBT 2008, 11th International Conference on Extending
Database Technology, Nantes, France, March 25-29, 2008, Proceedings, pp. 368â€“379.
Kivinen, J. et H. Mannila (1995). Approximate inference of functional dependencies from
relations. Theor. Comput. Sci. 149(1), 129â€“149.
Lopes, S., J. Petit, et L. Lakhal (2000). Efficient Discovery of Functional Dependencies and
Armstrong Relations. In Proc. EDBTâ€™00, pp. 350â€“364.
Novelli, N. et R. Cicchetti (2001a). Fun : An efficient algorithm for mining functional and
embeddeddependencies. In Proceedings of the 8th International Conference on Database-
Theory (ICDTâ€™01), Volume 1973 of Lecture Notes in Computer Science, pp. 189â€“203.
Novelli, N. et R. Cicchetti (2001b). Functional and embedded dependency inference : a data
mining point of view. Information Systems (IS) 26(7), 477â€“506.
Novelli, N. et S. Maabout (2003). Algorithme efficace de calcul du produit de partitions et ses
applications. In 19Ã¨me confÃ©rence Bases de DonnÃ©es AvancÃ©es (BDAâ€™03), pp. 343â€“362.
Spyratos, N. (1987). The partition model : A deductive database model. ACM TODS 12(1),
1â€“37.
Wyss, C., C. Giannella, et E. Robertson (2001). Fastfds : A heuristic-driven, depth-first algo-
rithm for mining functional dependencies from relation instances extended abstract. Data
Warehousing and Knowledge Discovery, 101â€“110.
Summary
Conditional Functional Dependencies (CFDs) have been recently introduced in the context
of data cleaning. They can be seen as an unification of Functional Dependencies (FD) and As-
sociation Rules (AR) since they allow to mix attributes and attribute/values in dependencies.
In this paper, we introduce our ongoing work on CFD inference which can be seen as a clarifi-
cation of some simple and basic notions underlying CFDs. Not surprisingly, we point out how
data mining techniques developed for functional dependencies and association rules can be
reused for constant CFD mining. We focus on how to extent a know technique for discovering
exacts and approximates FDs to discovering CFDs. We have implemented the technique on
which experiments have been carried out showing both the feasibility and the scalability of our
proposition.
Keywords: Data dependencies, Data mining, Databases theory.
RNTI-E-19 - 326 -
