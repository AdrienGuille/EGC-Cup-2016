Approche binaire pour la g¶en¶eration des fortes
rµegles d'association
Thabet Slimani, Boutheina Ben Yaghlane, Khaled Mellouli
LARODEC, IHEC Carthage, Carthage Pr¶esidence 2016, Tunisia
thabet.slimani@issatm.rnu.tn
boutheina.yaghlane@ihec.rnu.tn
khaled.mellouli@ihec.rnu.tn
R¶esum¶e. Dans ce papier, nous proposons une nouvelle m¶ethode d'ex-
traction des rµegles d'association dans des bases de donn¶ees relationnelles
bas¶ee sur la technologie des arbres de Peano (Ptree). La structure de
donn¶ees utilis¶ee pour repr¶esenter la base de donn¶ees est un ensemble
de Ptrees de base repr¶esentant chacun un vecteur binaire et tous ces
Ptrees sont stock¶es dans des ¯chiers binaires. Nous montrons que la struc-
ture Ptree combin¶ee avec la technique de r¶eduction appel¶ee ¶elagage par
support minimum produisent des rµegles d'association fortes et r¶eduisent
consid¶erablement le temps de construction de l'association. En e®et, notre
approche pr¶esente l'avantage de ne pas e®ectuer des parcours cou^teux de
la base de donn¶ees. Cette approche a ¶et¶e test¶ee µa travers un prototype
que nous avons impl¶ement¶e. Les r¶esultats exp¶erimentaux montrent que
les rµegles d'association fortes sont g¶en¶er¶ees dans un temps minimum com-
parativement µa d'autres travaux.
Keywords : Fouille de donn¶ees, Rµegle d'association, Itemsets fr¶equents,
Arbres de Peano (Ptree), Rµegles ANDing.
1 Introduction
L'extraction de connaissances µa partir des donn¶ees ECD (KDD en anglais pour
"Knowledge Discovery in Data") constitue un thµeme important du domaine de la fouille
de donn¶ees. Elle consiste en la recherche des connaissances implicites, cach¶ees dans un
ensemble volumineux d'informations stock¶ees dans des bases de donn¶ees. L'extraction
des rµegles d'association est l'un des principaux problµemes trait¶es de l'ECD. Ce thµeme
a ¶et¶e initialement abord¶e par (Agrawal et al 1993) pour l'analyse des bases de donn¶ees
de transactions de ventes oµu chaque transaction est constitu¶ee d'une liste d'articles
achet¶es (items), le but ¶etant de d¶ecouvrir les groupes d'articles (itemsets) achet¶es le
plus fr¶equemment ensembles. Une rµegle d'association est une relation d'implication
X!Y entre deux itemsets disjoints X et Y. Dans l'exemple du panier de la m¶enagµere,
cette rµegle indique que les transactions qui contiennent les items de l'ensemble X ont
tendance µa contenir les items de l'ensemble Y. Il existe deux mesures de quali¶e associ¶ees
µa chaque rµegle, con¯ance et support. Une rµegle appara^³t dans l'ensemble de transactions
D avec une con¯ance c si c% des transactions dans D qui contiennent X contiennent
aussi Y. Une rµegle d'association X!Y a comme support s si s% des transactions
dans D contiennent X[Y. Une rµegle d'association forte est une rµegle dont le support
Approche binaire pour la g¶en¶eration des fortes rµegles d'association
d¶epasse un seuil du support minimum (MinSup) et dont la con¯ance d¶epasse un seuil
de con¯ance minimale (MinConf ). Les seuils du support minimum et de la con¯ance
minimale doivent e^tre ¯x¶es d'avance par l'expert.
L'extraction des rµegles d'association µa partir de larges bases de donn¶ees est une ta^che
cruciale, la principale application est "l'analyse du panier de la m¶enagµere", mais au-
jourd'hui, cette technique a fait l'objet de plusieurs applications r¶eelles dans di®¶erents
domaines n¶ecessitant la recherche des groupements potentiels de produits ou de ser-
vices, par exemple secteur bancaire, secteur de t¶el¶ecommunications, secteur m¶edical
pour la recherche de complications du^es µa des associations de m¶edicaments, ou encore
traitement d'images (donn¶ees spatiales), analyse des accµes internet, ... N¶eanmoins, cette
ta^che est cou^teuse en temps de calcul car elle consiste µa faire plusieurs parcours de la
base de donn¶ees relationnelle pour l'identi¯cation des itemsets fr¶equents1. Les algo-
rithmes de d¶ecouverte de connaissances sont devenus ine±caces devant l'abondance de
donn¶ees d'oµu la n¶ecessit¶e d'utiliser des algorithmes rapides.
C'est dans ce cadre que se situe notre travail qui a pour objectif de proposer une
nouvelle m¶ethode permettant d'extraire des rµegles d'association fortes µa partir des
bases de donn¶ees volumineuses. En e®et, ¶etant donn¶ee une base de donn¶ees relation-
nelle repr¶esent¶ee sous forme d'un ensemble de tuples appel¶es aussi ensemble d'attri-
buts2 de nature diverse (des attributs de domaine binaire ou non binaire), nous pro-
posons d'abord de convertir les donn¶ees non binaires de la base relationnelle origi-
nale en une table binaire (Bitmap). Cette transformation est une caract¶eristique de
la m¶ethode rough set d¶ecrite dans (Munkata 1998). Ensuite, nous utilisons une struc-
ture de donn¶ees, appel¶ee arbre de Peano (Ptree), pour stocker, d'une fa»con compacte,
toutes les informations utiles. Les Ptrees sont utilis¶es, dans ce cadre, pour ¶etendre
les op¶erations ANding (Ding et al. 2002b) des Ptrees sur les attributs de la base de
donn¶ees. En utilisant Ptrees, nous n'avons pas µa faire des parcours cou^teux de la base
de donn¶ees pour calculer les supports des itemsets puisque la base de donn¶ees, comme
nous l'avons d¶ejµa mentionn¶e, est charg¶ee dans un ¯chier binaire, et par cons¶equent l'al-
gorithme B-ARM (en anglais "Binary Association Rule Mining"), que nous proposons,
permettra d'extraire les itemsets fr¶equents sur divers types de bases de donn¶ees en un
temps minimum comparativement µa d'autres travaux.
L'organisation de ce papier est la suivante : la Section 2 pr¶esente un ¶etat de l'art des
travaux e®ectu¶es sur les rµegles d'association. La Section 3 est une pr¶esentation som-
maire de la technique Ptree, ensuite la section 4 est consacr¶ee pour les caract¶eristiques
des attributs d'une base de donn¶ees. Dans la Section 5, nous pr¶esentons le principe
et le modµele de la g¶en¶eration des rµegles d'association. La conversion des attributs aux
Ptrees est abord¶ee dans la Section 6. Notre algorithme de g¶en¶eration des rµegles d'asso-
ciation est pr¶esent¶e dans la Section 7 et les r¶esultats exp¶eriementaux de notre prototype
impl¶ement¶e dans la Section 8. En¯n, dans la Section 9, nous concluons par quelques
voies de recherche.
1Un itemset est dit "fr¶equent" si son support est sup¶erieur µa un seuil correspondant au support
minimum (MinSup) sp¶eci¯¶e pr¶ealablement par l'expert.
2Dans le cas des applications du panier de la m¶enagµere, ces tuples sont repr¶esent¶es par un ensemble
de transactions ou ensemble d'items.
RNTI - 2
Thabet Slimani et al.
2 Etat de l'art
Les travaux e®ectu¶es sur les rµegles d'association dans le domaine de fouille de
donn¶ees sont trµes nombreux. L'algorithme de base Apriori (Agrawal et Srikant 1994)
est l'algorithme le plus populaire, il a ¶et¶e d¶evelopp¶e pour la d¶ecouverte des rµegles d'as-
sociations dans des bases de donn¶ees larges. Une extension de l'algorithme Apriori,
appel¶ee algorithme DHP (Direct Hashing and Pruning), est propos¶ee dans (Park et al
1995) utilisant la technique de hachage. Un algorithme plus r¶ecent appel¶e FDM (Fast
Distributed Mining of association rules) a ¶et¶e propos¶e par (Cheung et al 1996), il est
caract¶eris¶e par la g¶en¶eration d'un plus petit ensemble d'itemsets candidats et par la
r¶eduction du nombre de messages µa passer. Pincer Search (Lin et Kedem 1998) ¶etend
l'algorithme Apriori pour g¶en¶erer les itemsets fr¶equents. Depth-project (Agarwal et al
2000) parcourt le treillis des itemsets en profondeur et utilise un r¶eordonnancement
dynamique a¯n de r¶eduire l'espace de recherche. Un travail assez r¶ecent r¶ealis¶e par
(Delic et al 2002) procµede µa l'am¶elioration de la qualit¶e des rµegles d'association par
des techniques rough sets. En¯n, plus proches de notre travail, d'une part, l'algorithme
FP-growth qui repr¶esente la base de transactions sous forme d'un arbre compress¶e
appel¶e FP-tree (Han et al 2000) et d'autre part, l'algorithme MFItemsets (Maximal
Frequent Itemsets) qui repr¶esente la base des transactions sous forme d'un arbre binaire
et renvoie un ensemble de produits bool¶eens correspondants aux itemsets fr¶equents
maximaux associ¶es aux transactions donn¶ees (Salleb et Maazouzi 2002).
3 La technique Ptree
La structure de donn¶ees arbre de Peano (Ptree), appel¶ee aussi "Peano Count Tree"
est une repr¶esentation compacte et e±cace utilis¶ee pour le stockage de la base de
donn¶ees sous forme de bits binaires (0 et 1). Cette structure a ¶et¶e initialement introduite
pour la repr¶esentation de donn¶ees spatiales telles que les donn¶ees des applications RSI
(Remotely Sensed Imagery) (Perrizo et al 2001a, Ding et al 2002a, Ding et al 2002b).
Un Ptree est un arbre bas¶e sur des quadrants. Le principe de Ptree consiste µa diviser
r¶ecursivement la totalit¶e des donn¶ees spatiales en des quadrants et µa compter les bits 1
pour chaque quadrant, en formant de ce fait un arbre de calcul de quadrants. Dans la
¯gure 1, 55 est le nombre de bits 1 dans l'image entiµere, Ce niveau racine est ¶etiquet¶e
de niveau 0. Les nombres 16, 8, 15 et 16 du niveau suivant (niveau 1) sont les nombres
de bits 1 pour les quatre principaux quadrants dans l'ordre Z de la trame (sup¶erieur-
gauche, sup¶erieur-droite, bas-gauche, bas-droite). Puisque les premiers et les derniers
quadrants de niveau 1 se composent entiµerement de 1-bits (appel¶es quadrants pure-1 ),
les sous-arbres ne sont pas n¶ec¶essaires et ces branchements se terminent. De me^me, des
quadrants compos¶es entiµerement de 0-bits s'appellent des quadrants pure-0 et causent
¶egalement l'arre^t des banchements. Ce processus se r¶epµete r¶ecursivement en utilisant
l'ordre Z des quatre sous-quadrants µa chaque nouveau niveau. Eventuellement, chaque
niveau se termine puisqu'au niveau "feuille" tous les quadrants sont purs.
Les Ptrees sont un peu semblables, dans leur construction, µa d'autres structures de
donn¶ees dans la litt¶erature, par exemple Quadtrees (Samet 1984) et HHcodes3. Lors de
3http ://www.statkart.no/nlhdb/iveher/hhtext.html
RNTI - 2
Approche binaire pour la g¶en¶eration des fortes rµegles d'association
l'utilisation de la structure Ptree, tout calcul de l'information peut e^tre e®ectu¶e d'une
maniµere acc¶el¶er¶ee. L'analyse de performance e®ectu¶ee dans (Ding et al 2002a) montre
que Ptree produit un cou^t de calcul faible (en temps microprocesseur) et un espace de
stockage r¶eduit compar¶e avec les donn¶ees originales.
Un PM-tree (Peano mask tree) est une variante de Ptree, particuliµerement utile pour
l'optimisation de l'op¶eration ANDing entre deux Ptrees. PM-tree consiste µa utiliser une
logique de 3-valeurs, dans laquelle 1 est employ¶e pour repr¶esenter un quadrant pure-1,
0 est employ¶e pour repr¶esenter un quadrant de pure-0 et m est utilis¶e pour repr¶esenter
un quadrant mixte. Un exemple de PM-tree est donn¶e dans la ¯gure 1.
Fig. 1 { Image 8*8 et ses Ptree et PM-tree (Perrizo et al 2001b).
4 Caract¶eristique de la m¶ethode
Une base de donn¶ees est repr¶esent¶ee par une table binaire ou table Bitmap dont les
colonnes sont des attributs et chaque attribut possµede un ensemble limit¶e de valeurs
(items) connues par domaine d'attribut de la base de donn¶ees. La base de donn¶ees peut
avoir deux types de domaines : des attributs de domaine binaire DB et des attributs
de domaine non binaire NDB.
4.1 Les attributs de domaine binaire
Un attribut de domaine binaire est repr¶esent¶e par un vecteur ¡!v ½ fv1; v2g de
taille k tels que les valeurs v1 et v2 sont prises dans l'ensemble f0,1g et k est le nombre
des k-uplet de valeurs prises dans f0,1g. Un 1-uplet repr¶esente un tuple de la base de
donn¶ees ou une transaction en terme du panier de la m¶enagµere.
Une base de donn¶ees An de dimension n est constitu¶ee de n vecteurs binaires,
chacun de taille 2n et chaque vecteur est constitu¶e µa son tour de 4 vecteurs binaires
de taille 2n/4 (pour des raisons de simplicit¶e, nous avons d¶ecompos¶e chaque vecteur
binaire en 4 quadrants). Les lignes de An rep¶esentent alors, toutes les combinaisons
possibles de n valeurs binaires 0 et 1. Dans l'exemple donn¶e dans TAB.1, la pr¶esence
d'un article ordinateur dans une transaction ou son absence repr¶esente son domaine
fachet¶e, non achet¶eg et la transformation binaire rend la valeur de l'attribut a1=1 si
l'ordinateur est achet¶e ou a1=0 si l'ordinateur n'est pas achet¶e.
RNTI - 2
Thabet Slimani et al.
T id Ordinateur
1 Achet¶e
2 Non achet¶e
3 Achet¶e
4 Non achet¶e
::: :::
=)
T id a1
1 1
2 0
3 1
4 0
::: :::
Tab. 1 { Transformation des donn¶ees brutes en une repr¶esentation Bitmap pour des
attributs de domaine binaire
4.2 Les attributs de domaine non binaire
Un attribut de domaine non binaire Aj est constitu¶e de j items et la base de donn¶ees
est repr¶esent¶ee de
Pn
i=1 j ¤ i vecteurs binaires tel que n est le nombre d'attributs du
domaine non binaire (NDB). A titre d'exemple, pour une meilleure repr¶esentation du
pro¯t d'un client, on associe µa l'attribut revenu le domaine constitu¶e de j = 3 items
fhaut, moyen, faibleg d¶e¯ni comme suit : a1=\revenu haut", a2=\revenu moyen" et
a3=\revenu faible" et repr¶esent¶e par la table binaire suivante :
T id Revenu
1 Haut
2 Moyen
3 Faible
4 Haut
::: :::
=)
T id a1 a2 a3
1 1 0 0
2 0 1 0
3 0 0 1
4 1 0 0
::: ::: ::: :::
Tab. 2 { Transformation des donn¶ees brutes en une repr¶esentation Bitmap pour des
attributs de domaine non binaire.
5 G¶en¶eration des rµegles d'association
5.1 Principe
Etant donn¶ee une base de donn¶ees compos¶ee de n attributs associ¶es µa m tuples,
l'id¶ee principale de notre algorithme s'appuie sur l'algorithme Apriori (Agrawal et
Srikant 1994) qui consiste µa balayer la base de donn¶ees pendant des passages multiples
dans le but de rechercher des itemsets fr¶equents. Aprµes chaque passage, le nombre des
items dans les sous-ensembles des itemsets larges s'incr¶emente de 1 jusqu'µa ce que les
ensembles possibles dans la base de donn¶ees sont construits, ensuite, l'algorithme utilise
les larges itemsets pour g¶en¶erer les rµegles d'association. L'algorithme Apriori s'arre^te
lorsqu'aucun itemset large ne peut e^tre cr¶ee. Ainsi, pour un nombre ¶elev¶e d'items n
et un nombre de tuples m trµes grand, on peut associer 2n combinaisons possibles qui
augmente le temps de calcul puisque le calcul s'e®ectue directement sur la base de
donn¶ees, d'oµu la n¶ecessit¶e d'architectures plus e±cace qui permettent des accµes rapides
µa de grands jeux de donn¶ees.
RNTI - 2
Approche binaire pour la g¶en¶eration des fortes rµegles d'association
Pour cela, nous avons adopt¶e la technique Ptree dont l'avantage est de ne pas
e®ectuer des parcours cou^teux sur la base de donn¶ees car les donn¶ees originales sont
converties en donn¶ees spatiales (ou binaires), puis stock¶ees dans un ¯chier binaire. En
utilisant l'organisation REL (repr¶esentation de la base de donn¶ees sous forme d'une
table Bitmap), l'id¶ee de Ptree consiste, d'une part, µa diviser r¶ecursivement les donn¶ees
spatiales dont les colonnes de la table Bitmap forment chacune une bande de bits et
d'¶eviter, d'autre part, de comparer µa chaque fois les items 1 par 1 et de proc¶eder, au
contraire, µa la comparaison des blocs de tuples, ce qui diminue le temps de calcul.
5.2 Modµele
La g¶en¶eration des rµegles d'association est mod¶elis¶ee sur la base du modµele rough
set (Munkata 1998), dont l'univers ­ des attributs de la table Bitmap est divis¶e en
deux ensembles disjoints, un ensemble constituant les attributs de condition ­c et un
deuxiµeme ensemble constituant les attributs de d¶ecision ­d.
Soit la TAB. 3 oµu les attributs de l'ensemble des donn¶ees sont repr¶esent¶es par fXg,
fYg et fZg. L'attribut X a deux valeurs fA et Bg= fCompte d¶ebit¶e, Compte nulg,
l'attribut Y a trois valeurs fC, D et Eg=frevenu faible, revenu haut, revenu moyeng et
l'attribut de d¶ecision Z a deux valeurs fF, Gg=faccorder pre^t, ne pas accorder pre^tg.
Il y en a 7 items pour la table Bitmap r¶esultante fA, B, C, D, E, F et Gg.
T idclient Compte Revenu Accorder pre^t
1 D¶ebit¶e Moyen Oui
2 D¶ebit¶e Faible Non
3 D¶ebit¶e Moyen Oui
4 D¶ebit¶e Haut Oui
5 Nul Haut Non
=)
T id A B C D E F G
1 1 0 0 0 1 1 0
2 1 0 1 0 0 0 1
3 1 0 0 0 1 1 0
4 1 0 0 1 0 1 0
5 0 1 0 1 0 0 1
Tab. 3 { Table de donn¶ees originales et son ¶equivalente Bitmap
Dans la premiµere ¶etape, toutes les rµegles possibles sont construites µa partir de tous
les attributs de la table Bitmap. Par exemple, pour X!Y ; 6 rµegles di®¶erentes peuvent
e^tre form¶ees. Elles sont obtenues par le produit cart¶esien des items des deux attributs
X et Y fA!C, A!D, A!E, B!D, B!Eg. Le choix d'une rµegle d'association est bas¶e
sur les quantit¶es num¶eriques, support et con¯ance, d¶e¯nies par l'utilisateur, qui vont
servir µa valider l'intere^t d'une telle rµegle, ainsi toutes les rµegles qui ne satisfont pas les
contraintes du support minimum et de la con¯ance minimale sont ¶elimin¶ees.
6 Des attributs aux Ptrees
Dans notre approche, chaque item est repr¶esent¶e par un Ptree. Un ensemble de
tuples, selon la repr¶esentation Ptree, doit e^tre une puissance de 2. Le nombre des tuples
dans une base de donn¶ees est transform¶e µa la plus proche puissance de 2, sachant que les
tuples compl¶et¶es sont des itemsets incluant uniquement la valeur 0. La table des tuples
est repr¶esent¶ee d'une maniµere analogique µa la repr¶esentation ensembliste sous formes
d'itemsets. Soit I un itemset, la transformation binaire consiste µa mettre la valeur 1 µa
RNTI - 2
Thabet Slimani et al.
l'item Ij s'il appartient µa ~I, et 0 sinon. Dans l'approche Ptree, chaque colonne de la
table Bitmap est repr¶esent¶ee par un vecteur de bits dont la taille est divisible par 4,
appell¶e Ptree de base.
Consid¶erons la base de donn¶ees de la table 4. Soient les attributs de condition de
l'espace ­c form¶es par les attributs fA, B, C, D, E, Fg d¶esignant l'ensemble des pro-
duits fcartouche imprimante, lecteur vid¶eo, voiture, ordinateur, cam¶era, imprimanteg
et l'attribut de d¶ecision de l'espace ­d form¶e par fGg d¶esignant l'attribut flogiciel
graphiqueg. Soit MinSup=10% et MinConf=30% repr¶esentant le support minimum
et la con¯ance minimale. TAB.4 pr¶esente cette base de donn¶ees convertie sous forme
d'une table Bitmap.
Tid A B C D E F G
Tid1 oui oui non non non non non
Tid2 oui oui oui oui oui oui non
Tid3 non oui non oui non non oui
Tid4 non oui non non oui non oui
Tid5 non non non oui non oui oui
Tid6 non non non oui oui non oui
Tid7 non oui non non oui non non
Tid8 non oui non oui oui oui non
)
Tid A B C D E F G
Tid1 1 1 0 0 0 0 0
Tid2 1 1 1 1 1 1 0
Tid3 0 1 0 1 0 0 1
Tid4 0 1 0 0 1 0 1
Tid5 0 0 0 1 0 1 1
Tid6 0 0 0 1 1 0 1
Tid7 0 1 0 0 1 0 0
Tid8 0 1 0 1 1 1 0
Tab. 4 { Exemple d'une base de donn¶ees et sa table Bitmap correspondante
6.1 Construction des Ptrees
Pour des raisons de simplicit¶e, nous supposons que le fan-out (les noeuds sortants)
est quatre. Pour chaque vecteur de bits, on associe un Ptree de base. Il y en a six Ptrees
de base pour l'univers ­c de la table 4, et puisque chaque Ptree pr¶esente un nombre de
bits divisible par 4, donc, il est constitu¶e par quatre sous-quadrants dont le quadrant
d'origine est la totalit¶e des bits formant un item de la table Bitmap. Il y a toujours
n Ptrees de base pour une table Bitmap form¶ee de n items. Comme nous l'avons d¶ejµa
expliqu¶e, l'id¶ee de construction d'un Ptree consiste µa diviser p¶eriodiquement le vecteur
binaire (item) en des sous-quadrants et d'enregistrer le nombre des bits 1 pour chaque
sous-quadrant en formant, de ce fait, un arbre de calcul des quadrants.
6.2 Stockage de Ptrees
D'une maniµere similaire µa la g¶en¶eration de la s¶equence de Peano µa partir des
trames de donn¶ees spatiales, on doit cr¶eer l'arbre Ptree d'une maniµere ascendente.
La g¶en¶eration de Ptree d¶epend du nombre de fan-out dans les noueds internes de
l'arbre Ptree et dans le noeud racine. Pour repr¶esenter Ptree avec di®¶erents fan-outs,
on introduit la notation P-tree-(r-i) ; oµu r=fan-out du noeud racine et i=fan-out de
tous les noeuds internes du niveau 1. On utilise dans notre travail la repr¶esentation
P-tree-(4-4-n) cµad on divise le nombre des tuples composant la base de donn¶ees par 4
blocs (les blocs de transactions doivent avoir au minumum 4 tuples). Par exemple, si
le nombre de tuples est inf¶erieur µa 16, on complµete par des 0 pour obtenir le format
Ptree sur 16 tuples. En rµegle g¶en¶erale, si le nombre de transactions est inf¶erieur µa 2n+1
et sup¶erieur µa 2n alors le Ptree de base est stock¶e avec un nombre ¶egal µa 2n+1:
RNTI - 2
Approche binaire pour la g¶en¶eration des fortes rµegles d'association
6.3 Les op¶erations d'intersection (ANDing) des Ptrees
ANDing est une op¶eration trµes importante et fr¶equemment utilis¶ee pour les Ptrees.
Il y a plusieurs voies d'ex¶ecuter l'op¶eration ANDing de Ptree. Nous pouvons l'ex¶ecuter
niveau par niveau µa partir du niveau racine. TAB 5 donne les rµegles de l'op¶eration
ANDing de Ptrees. L'op¶erande 1 et l'op¶erande 2 sont deux Ptrees avec la racine X1 et
X2 respectivement. En utilisant PM-trees, X1 et X2 pourraient e^tre n'importe quelle
valeur parmi 1, 0 et m. Par exemple, µa l'op¶eration ANDing, un Ptree des bits pures-1
avec n'importe quel Ptree aura comme cons¶equence la deuxiµeme op¶erande et un Ptree
des bits pures-0 avec n'importe quel Ptree aura comme cons¶equence le Ptree pure-0.
Op¶erande1 Op¶erande2 R¶esultat
1 X2 Sous-Arbre avec comme racine X2
0 X2 0
X1 1 Sous-Arbre avec comme racine X1
X1 0 0
m m 4 si le r¶esultat de 4 sous-quadrants = 0 ; m sinon
Tab. 5 { Les rµegles d'intersection des Ptrees.
7 Algorithme B-ARM (Binary Association Rule Mi-
ning)
Dans Apriori et la plupart des algorithmes ARM, la base de donn¶ees doit e^tre
balay¶ee entiµerement pour calculer le support de chaque itemset candidat. Lorsque l'en-
semble de transactions est large, le cou^t sera extre^mement ¶elev¶e. Alors qu'µa partir de
l'op¶eration ANDing des Ptrees, le support de chaque itemset candidat peut e^tre obtenu
directement, cµad le compte du support est juste le compte de la racine de chaque Ptree
de base, et par cons¶equent, il n'y a aucun besoin de balayer la base de donn¶ees. En se
basant sur cette id¶ee, on a d¶evelopp¶e un nouveau algorithme, appel¶e B-ARM, pour la
g¶en¶eration des rµegles d'association en utilisant des Ptrees. Comme pour l'algorithme
Apriori, l'algorithme B-ARM sert µa la d¶ecouverte des itemsets fr¶equents.
A¯n de g¶en¶erer des itemsets fr¶equents, l'algorithme B-ARM procµede comme suit :
Il commence par le stockage des Ptrees de base dans deux vecteurs, un vecteur pour le
stockage des quadrants (les blocs des bits de chaque noeud interne) et un autre pour
le stockage des noeuds racines, ensuite il s'agit de d¶egager les attributs fr¶equents dont
le support est sup¶erieur ou ¶egal au support minimum sp¶eci¯¶e par l'utilisateur. L'¶etape
suivante consiste µa it¶erer r¶ecursivement l'intersection par des op¶erations ANDing des
Ptrees de base de la partie condition avec les Ptrees de base des attributs de d¶ecision,
a¯n de d¶egager l'ensemble des nouveaux itemsets admissibles de la partie condition.
Les rµegles sont g¶en¶er¶ees aprµes v¶eri¯cation de la con¯ance de la partie condition et
la partie conclusion. L'algorithme s'arre^te lorsqu'aucun itemset fr¶equent n'existe dans
l'ensemble des attributs candidats Ck.
RNTI - 2
Thabet Slimani et al.
Algorithm B-ARM
Discr¶etisation de donn¶ees ;
Stockage Ptrees ;
Pour chaque attribut i ½ ­c
C1 = F1 ;
FinPour
Ck = C1 ;
Tant que (Ck 6= ;) faire
Pour chaque attribut i ½ Ck
Pour chaque attribut j ½ ­d
Fij = AND Ptreebase(i,j) ;
Stockage Ptrees ;
FinPour
Fk = Fk[ Fi; == itemsets candidats
FinPour
C k = Fkfc 2 Ckj c:count >=MinSupg ;
FinTantque
Dans la proc¶edure de stockage de Ptree, on stocke les noeuds racines de Ptree dans
un vecteur et les noeuds binaires (formant les sous-quadrants) dans un autre vecteur
a¯n de faciliter l'accµes aux donn¶ees des sous-quadrants de chaque bande (colonne de la
table Bitmap), en vue de les comparer pour v¶eri¯er les associations entre ces bandes.
Soit Nt = nombre de tuples ; n est initialis¶e µa 3 ; I d¶esigne le nombre total des attributs.
Proc¶edure Stockage Ptrees
Pour (bandej=1 ; j<I ; j++)
racine[j] :=rootcount(1 ; bandej)//vecteur qui stocke les racines des Ptrees.
Si(2n ·Nt et Nt < 2
n+1) alors
Pour (i :=Nt ; i· 2
n+1 ; i++)
bandj[i+1] :=0 ;
Finpour
Finsi
k :=0 ;
Pour (i :=1 ; i· 2n; 2n=4) // calcul des racines ou sous-quadrants
k :=k+1 ;
rootsBandj[k] :=rootcount (1 ; bandj) ;// vecteur racines internes
FinPour
Pour (i :=1 ; i· 2n; 2n=4)
Si (rootsBandj[i]<>2n ou rootsBandj[i]<>0) alors
bitsBandj[i] :=rootsBandj[i] ;//vecteur des bits
Finsi
Finpour
FinPour
La liste des rµegles fortes g¶en¶er¶ees dans l'exemple d¶ecrit pr¶ec¶edemment est r¶esum¶ee
dans la table 6. Les rµegles sont classi¯¶ees par attribut de d¶ecision G ou F.
RNTI - 2
Approche binaire pour la g¶en¶eration des fortes rµegles d'association
Att d¶ecision = G Att d¶ecision = F
Rµegles fortes µa deux attributs B!G A!F
D!G B!F
E!G C!F
F!G D!F
E!F
Rµegles fortes µa 3 attributs B,D!G A, B!F
A,C!F
A,D!F
A,E!F
B,C!F
B,D!F
C,D!F
Rµegles fortes µa 4 attributs A,B,C!F
A,B,D!F
A,B,E!F
A,C,D!F
B,C,D!F
B,C,E!F
B,D,E!F
C,D,E!F
Rµegles fortes µa 5 attributs A,B,C,D!F
A,B,C,E!F
A,C,D,E!F
B,C,D,E!F
Rµegles fortes µa 6 attributs A, B,C,D,E!F
Tab. 6 { Sch¶ema illustratif des rµegles fortes retenues.
8 Impl¶ementation et expr¶ementation
Nous avons d¶evelopp¶e un prototype de g¶en¶eration des rµegles fortes. La structure de
donn¶ees utilis¶ee pour repr¶esenter la base de donn¶ees (BD) est un ensemble de Ptrees
de base repr¶esentant chacun un vecteur binaire de la table Bitmap et tous ces Ptrees
sont stock¶es dans des ¯chiers binaires. Cette structure de donn¶ees permet de charger
complµetement la BD volumineuse dans un ¯chier binaire. L'objectif de cette op¶eration
est d'¶eviter le balayage direct de la BD.
La transformation d'une BD en une repr¶esentation Bitmap et l'utilisation du sch¶ema
de production des rµegles d'association n¶ecessite une comparaison objective de cette
m¶ethode avec d'autres travaux. La comparaison de notre travail est facilit¶ee par l'uti-
lisation d'un benchmark data4. On a choisi une BD (car evaluation database) µa travers
laquelle on a compar¶e notre travail. Cette BD comprend 1728 tuples et 25 valeurs
d'attributs (items) dans la table Bitmap.
Nous avons compar¶e notre travail par rapport µa deux approches Apr+ (Apriori+)
et Rs+ (RS-Rules+) (Delic et al 2002). La proc¶edure Apr+ est une extension de
la m¶ethode "faster association rule" combin¶ee avec la proc¶edure "rough set". Cette
proc¶edure utilise un attribut de d¶ecision ¯xe comme le principe de notre travail, mais,
en plus de cela, notre travail ajoute la notion de la technique Ptree pour acc¶el¶erer le
temps de g¶en¶eration des rµegles d'association admissibles uniquement et utilise µa chaque
¶etape la partie condition de ces me^mes rµegles pour g¶en¶erer d'autres rµegles. Les rµegles
d¶eriv¶ees sont produites sur la base de la r¶eduction successive des rµegles inutiles.
4Le \benchmark data" se trouve dans \UCI Repository of Machine Learning Database and Domain
Theories"(URL : ftp.ics.uci.edu/pub/machine learning-databases/Adult, /car, /mushroom).
RNTI - 2
Thabet Slimani et al.
Dans notre travail, on ne produit pas des rµegles redondantes, alors que dans Rs+
et Apr+, des rµegles redondantes sont produites et enlev¶ees par la suite. Les premiµers
r¶esultats, non d¶e¯nitifs, donn¶es dans TAB.7 montre que notre travail produit un temps
de g¶en¶eration des rµegles d'association ¶egale µa 0,083 min pour des attributs ayant comme
valeurs d'items ¶egale µa 1 et un temps ¶egale µa 0,067 min pour des attributs ayant comme
valeurs d'items ¶egale µa 0 qui est un temps r¶eduit par rapport µa Rs+ et Apr+. Notons
que notre approche produit les me^mes rµegles g¶en¶er¶ees par les m¶ethodes Rs+ et Apr+.
Database Car Evaluation
Support minimum 0,10
Con¯ance minimale 0,75
Attribut de d¶ecision 1 0
M¶ethode Rs+ Apr+ B-ARM Rs+ Apr+ B-ARM
Temps CPU (min) 1,15 1,12 0,083 1,10 3,15 0,067
Tab. 7 { Tableau comparatif des algorithmes de g¶en¶eration des rµegles d'association
9 Conclusion
La m¶ethode de g¶en¶eration des rµegles d'association de notre algorithme B-ARM est
bas¶ee sur l'¶elagage par con¯ance minimale et support minimum. La d¶ecouverte des
similarit¶es entre des attributs/items a ¶et¶e bas¶ee sur des rµegles de comparaison des
Ptrees. Notre travail est avantageux car, d'une part, il ¶evite le balayage direct de la
base de donn¶ees qui est une op¶eration cou^teuse en m¶emoire et en temps de calcul
qui d¶epasse largement la capacit¶e des ordinateurs, malgr¶e leurs ¶evolutions rapide et,
d'autre part, il o®re un gain de comparaison des attributs/items car la comparaison
s'e®ectue par bloc des tuples de la base de donn¶ees.
Comme extension de ce travail, nous comptons utiliser la me^me m¶ethode pour
g¶en¶erer des rµegles d'association dans un temps limit¶e tout en ajoutant aux rµegles d'as-
sociation la contrainte du temps (domaine nouveau pour l'identi¯cation des s¶equences).
R¶ef¶erences
Agarwal R.C., Aggarwal C.C. & Prasad V.V.V. (2000). Depth First Generation of
Long Patterns. In Proc. of the 6th Int. Conf. on Knowledge Discovery and Data
Mining, pp. 108-118.
Agrawal R., Imielinski T. & Swami A.N. (1993). Mining Association Rules between
Sets of Items in Large Databases. In Proc. of the ACM SIGMOD International
Conference on Management of Data, pp. 207-213.
Agrawal R. & Srikant R. (1994). Fast Algorithms for Mining Association Rules. In
Proc. 20th Int. Conf. Very Large Data Bases (VLDB), pp. 487-499.
RNTI - 2
Approche binaire pour la g¶en¶eration des fortes rµegles d'association
Cheung C., Han J., Ng V.T., Fu A.W. & Fu Y. (1996). A Fast Distributed Algorithm for
Mining Association Rules. In Proc. of 1996 Int'l Conf. on Parallel and Distributed
Information Systems (PDIS'96), Miami Beach, Florida, USA.
Delic D., Lenz L. & Neiling N. (2002). Improving the Quality of Association Rule
Mining by means of Rough Sets. Free university of Berlin, Institute of Applied
Computer Science, Garystr. 21, D-14195, Berlin, Germany.
Ding Q., Ding Q. & Perrizo W. (2002a). Association Rule Mining on Remotely Sensed
Images using P-trees. In Proceedings of the PAKDD, Taipei, Taiwan, pp. 66-79.
Ding Q., Khan M., Roy A. & Perrizo W. (2002b). The Ptree Algebra. In Proc. of
ACM Symposium on Applied Computing (SAC'02), Madrid, Spain, pp. 413-417.
Han J., Pei J. & Yin Y. (2000). Mining Frequent Patterns without Candidate Gene-
ration. In Proc. 2000 ACM SIGMOD Intl. Conference on Management of Data,
Chen W., Naughton J. & Bernstein P.A. (Eds), ACM Press, pp. 1-12.
Lin D. & Kedem Z. M. (1998). Pincer Search : A New Algorithm for Discovering the
Maximum Frequent Set. In Proc. Int. Conf. on Extending Database Technology.
Munkata T. (1998). Rough Sets. In Fundamentals of the New Arti¯cial Intelligence,
New York : Springer-Verlag, pp. 140-182.
Park J.S., Chen M.S. & Yu P.S. (1995). An E®ective Hash-based Algorithm for Mi-
ning Association Rules. In Proc. 1995 ACM SIGMOD International Conference on
Management of Data, pp. 175-186.
Perrizo W., Ding Q., Ding Q. & Roy A. (2001a). On Mining Satellite and other
Remotely Sensed Images. In Proc. of Workshop on Research Issues on Data Mining
and Knowledge Discovery, pp. 33-44.
Perrizo W., Ding Q., Ding Q. & Roy A. (2001b). Deriving High Con¯dence Rules
from Spatial Data using Peano Count Trees. In Advances in Web-Age Information
Management : Second International Conference WAIM 2001, Wang X.S., Yu G.
and Lu H. (Eds), Springer-Verlag, LNCS 2118, pp. 91-102.
Salleb A. & Maazouzi Z. (2002). Approche Bool¶eenne pour l'extraction des itemsets
fr¶equents maximaux. In Conf. d'Apprentissage (CAp'02), Orl¶eans, pp. 111-122.
Samet H. (1984). The Quadtree and Related Hierarchical Data Structures. In Com-
puting Surveys, 16(2), pp. 187-260.
Summary
In this paper, we propose a new method for the association rule mining in relationnel
data bases by the use of Peano tree (Ptree) technology. The data of the association
rules model are organized in format REL which is a converted organization of the not-
spatial data to spatial data (binary). A data base is seen as a Bitmap table whose each
column represents an attribute and each row represents a tuple of data base. We show,
in this work, that the Ptree structure, combined with the technique of reduction called
pruning by minimum support, can produce strong rules by reducing considerably the
time of association construction. Our prototype and experiments have shown that it is
possible to produce a strong rules in a minimum time comparing to other works.
RNTI - 2
