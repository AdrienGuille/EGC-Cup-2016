Ontology Evolution and Source Autonomy in
Ontology-based Data Warehouses
Dung Nguyen Xuan∗ Ladjel Bellatreche∗ Guy Pierra ∗
∗ LISI/ENSMA - Poitiers University
1 Avenue Clément Ader 86960 Futuroscope - France
(nguyenx, bellatreche, pierra)@ensma.fr
Abstract. Ontology-based integration systems (OBIS) use ontologies in order
to describe the semantic of sources and to make the content explicit. Two major
architectures of OBISs are available: (i) those using an unique ontology, and (ii)
those using multiple ontologies. In the first architecture, all sources are related
to one shared ontology. This architecture suffers from changes of ontology and
sources which can affect the conceptualization of the domain represented in the
ontology. Any change in the ontology may affect the sources. Therefore, sources
are not really autonomous. In hybrid ontologies, each source is described by its
own ontology, called local ontology. Each one references/maps a shared on-
tology in order to guarantee that each source shares the same vocabulary. The
articulation between local ontologies and the shared ontology can be done either
a posteriori or a priori. Two major issues are raised in this architecture: (i) evo-
lution of the shared ontology and its consequence on the integrated system, and
(ii) autonomy of the ontology and the local schema of each source. In this pa-
per, we propose an approach and a model to manage asynchronous evolution of
warehouse integrated systems where the articulation is done in an a priori man-
ner. The fundamental hypothesis of our work, called principle of ontological
continuity, supposes that an evolution of an ontology does not make false an ax-
iom that was previously true. This principle allows to manage each old instance
using the actual ontology. Therefore, it simplifies significantly the management
of the evolution process and allows a complete automation of the whole inte-
gration process. Our work is motivated by the automatic integration of catalogs
of industrial components in engineering databases. It has been validated by a
prototype using ECCO environment and EXPRESS language.
1 Introduction
It is widely recognized that an automatic integration of heterogeneous data sources is one
of the keys to improve management and productivity of several application domains like data
warehouse, bio-informatic, e-commerce, etc. Generally, a data integration system combines
the data residing at different heterogeneous and autonomous sources, and provides an unified,
reconciled view of these data, called global schema, which can be queried by the users. A
- 55 -
Ontology Evolution and Source Autonomy in Ontology-based Data Warehouses
warehouse integration consists in materializing the data frommultiple sources into a warehouse
and executing all queries on the data contained in the warehouse rather than in the actual
sources. Warehousing emphasizes data translation, as opposed to query translation in mediator-
based integration Wiederhold (1992).
There is an important number of research projects dealing with data integration. The spec-
trum ranges from early multi-database systems Lander and Rosenberg (1982) over mediator
systems (e.g., Garlic Roth et al. (1996); Wiederhold (1992)), warehouse systems Bellatreche
et al. (2004a) to ontology-based integration approaches (e.g., Observer Mena et al. (1996),
Picsel Reynaud and Giraldo (2003), and a priori integration Bellatreche et al. (2004a)).
Note that each integration system addresses the following issues: (i) the source autonomy,
known as the receiver heterogeneity problem Goh et al. (1994), and (ii) resolution of vari-
ous conflicts from multiple sources due to semantic heterogeneities. Among these conflicts
we can cite Goh et al. (1999): naming conflicts, scaling conflicts, confounding conflicts and
representation conflicts.
Source autonomy: Sources are not forced to adapt their data and their semantics to integrate
sources Goh et al. (1994). Therefore, most of the sources operate autonomously: i.e., they
are free to modify their ontology and/or schema, remove some data without any prior "public"
notification, or occasionally block access to the source for maintenance or other purposes.
Moreover, they may not always be aware of or concerned by other sources referencing them or
integration systems accessing them. Consequently, the relation between the integrated system
represented by a warehouse and its autonomous sources is slightly coupled. Consequently, it
may generates maintenance anomalies Chen et al. (2004). In that context (where changes are
asynchronous), evolution management concerns schema and populations of sources, and the
shared and local ontologies.
The problem of source autonomy has received a little attention in the literature, especially in the
context of ontology-based integration systems compared to the first issue (conflict resolution).
Conflict Resolution: The fundamental challenge of the source integration systems is the
difficulty to integrate automatically, at the meaning level, multiple sources Levy et al. (1996),
Doan et al. (2004), Lawrence and Barker (2001), Chawathe et al. (1994), Reynaud and Giraldo
(2003) and Castano and Antonellis (1997). By exploring the existing integration systems, two
generations of integration are distinguished: In the first generation of integration systems (e.g.,
TSIMMIS Chawathe et al. (1994)), data meaning was not explicitly represented. Thus, the
meaning of concepts and the mappings between concepts were manually encoded in a view
definition Chawathe et al. (1994) (SQL view).
Systems in the second generation use ontology and in particular a shared ontology to map
meaning of each data source Wache et al. (2001). Ontologies provide a way to represent
explicitly the formal semantics. These systems are called ontology-based integration systems
(OBISs). An ontology is "an explicit specification of a conceptualization" Gruber (1995). A
classical definition of an ontology is an explicit, and formal shared and referencable description
of concepts and their relationships that exist in a certain universe of discourse. References to
an ontology provides a shared vocabulary that labels concepts of a domain. Ontologies are
then used in an integration task to describe the semantic of the sources and to make the content
- 56 -
Xuan et al.
explicit. Two main architectures of OBISs are available Wache et al. (2001): (i) those using an
unique ontology, and (ii) those using multiple ontologies.
1. In the unique ontology architecture, all information sources are related to one shared on-
tology. A prominent approach of this kind of architecture is SIMS Arens and Knoblock
(1993). This architecture suffers from changes of ontology and sources which can af-
fect the conceptualization of the domain represented in the ontology. Any change in the
ontology may affect the sources. Therefore, sources are not really autonomous.
2. In hybrid ontologies, each source is described by its own ontology, called local ontology.
Each one references a shared ontology in order to guarantee that each source shares the
same vocabulary Mitra et al. (2000); Hakimpour and Geppert (2002); Goh et al. (1999).
The articulation (or linkage) between local ontologies and the shared ontology (each
concept of a local ontology Oi is mapped into a concept of the shared ontology) can
be done either a posteriori Mitra et al. (2000) or a priori Bellatreche et al. (2004a). In
a posteriori articulation it is hard to ensure a fully automatic integration process Mitra
et al. (2000).
In a number of domains, including Web service, e-procurement, synchronization of dis-
tributed databases, the new challenge is to perform a fully automatic integration of au-
tonomous sources.
Claim 1 In order to avoid a human-controlled mapping between concepts at integration
time, this mapping shall be done a priori at the database design time.
This means that some formal shared ontologies must exist, and each local source shall
embed some ontological data that references explicitly this shared ontology. Some sys-
tems are already developed based on this hypothesis: Picsel2 Reynaud and Giraldo
(2003) project for integrating Web services, the COIN project for exchanging for in-
stance financial data Goh et al. (1999). Their weakness is that once the shared ontology
is defined, each source shall used the common vocabulary. The shared ontology is in
fact a global ontology and each source is less autonomous.
Two major issues are raised in the multiple ontologies architecture: (i) the evolution of the
shared ontology and its consequence on the integrated system, and (ii) the schematic autonomy
of the local ontology and the local schema of each source.
Our work deals with an integration of autonomous and asynchronous data sources, where
each one has its own ontology referencing a shared one Bellatreche et al. (2004b). In this
situation, it may be impossible to find a local ontology similar to the shared one. This is
because of two reasons: (i) the first one concerns the covered domain (autonomy of domains
of each source), and (ii) the second one concerns the synchronism (asynchronous evolution):
1. generally, the covered domain is not the same:
• each local source references the shared ontology, but it takes just a fragment of that
ontology,
• conversely, usually, some shared concepts have to be refined locally in order to
represent the local requirements. Our goal is to ensure a maximal autonomy of
sources, and provides an automatic integration.
- 57 -
Ontology Evolution and Source Autonomy in Ontology-based Data Warehouses
 

 

 

...
 



	


	

	
 

 

 

 



	


	

	







	


	

	










	


	

	





FIG. 1 – The two possible ways for using ontologies for content explication.
2. Ontologies evolve, and it is impossible to completely synchronize them. This is due to
following factors:
• the evolution of the shared ontology and existing data: one source may disparate,
and we want to save the old data,
• the time needed to broadcast evolution among local and shared ontologies.
We have already proposed a solution for the problem of domain autonomy, called semantic
integration approach by articulating ontologies Bellatreche et al. (2004a). It consists in giving
to each source the autonomy on defining its own ontology, but, it should (the local ontology)
references systematically shared ontology(ies) (the notion of smallest subsumes class reference
Bellatreche et al. (2004b)).
In this paper, we propose an approach and model dealing with the problem of management
of asynchronous evolution of ontologies and data. Our approach is based on the particular
characteristics of ontologies (contrary to conceptual model), which consists in defining a set
of constraints to be respected simultaneously by the shared ontology and all the data sources
participating in the integration process.
2 Problem Position
Let’s consider a warehouse integrated system described in Figure 2. Let O be the shared
ontology, and S = {S1, ..., Sn} a set of data sources participating in the integration process,
where each source Si (1 ≤ i ≤ n), stores explicitly its local ontology referencing the shared
one O (this reference is done a priori), and the mappings between the local ontology and the
data. This kind of sources, is called, ontology-based data source (OBDS) Pierra et al. (2004).
The warehouse integrated system has also an OBDS structure. The data warehouse ontology
may be the shared one.
In several situations, members of a community defining an ontology (resulting from a con-
sensus) want to extend it. This extension may refine some already modeled concepts or to
acknowledge an evolution in the conceptualized world. For instance, in a product ontology,
the fact that a new kind of products have been appeared on the market. In this case, we cannot
assume that each source will immediately reflect the changes in the shared ontology.
- 58 -
Xuan et al.
   ff fi
   ff fl
   ff ffi
  ! " # $ % & "
ff#  ! " '
$ ffi ( $ ) $ * +
ff $ % ! , "
-ffi ( " * !  (
-
$ ffi
FIG. 2 – Semantic integration by a priori ontology articulation.
In this context, where changes occur in a asynchronous manner across the various sources
and the shared ontology, three problems should be resolved:
1. The traceability of two links between local ontologies and the shared ontology: local
ontologies define the meaning of local data. Moreover, when a local ontology references
a shared ontology, the meaning of the local ontology entries are themselves imported
from the shared one. Therefore, if the shared ontology evolves, it should contribute
with a particular release to the definition of local data. This problem may be solved by
assigning a version number to each concept of the shared ontology, and by increasing
this number when some changes occur in the concept definition Noy and Klein (2003);
Klein and Noy (2003).
2. The data access transparency: evolution of the shared ontology must not destroy the
integration system: a single version of the shared ontology must provide an access to all
integrated data, despite the fact that they might correspond to different versions of the
shared ontology.
3. The management of life cycle of instances: in some situations it will be interesting to
know at each moment the existence of each instance. This requires to save all versioned
instances of all tables. This problem is known as "schema versioning" in the literature
Wei and Elmasri (1999). But two difficulties exist: (i) the replication of data (mainte-
nance and storage overhead) et (ii) the conflict between the automatic refreshment and
the query processing on multi-versioned data Wei and Elmasri (1999).
Example 1 To illustrate these problems, let consider the following example:
Figure 3 shows a warehouse integrating two ontology-based sources, Source1 and Source2,
where each one references a shared ontology. Suppose that at instant t, the version of the local
and shared ontologies is 1. At instant (t+1), the shared ontology and the Source2 endure the
following asynchronous evolutions:
1. The shared ontology evolves independently from sources, where its class C changes and
its version becomes 2,
2. The Source2 has a change in the ontology level, where a new attribute is added to class
C2. Consequently, the class C2 and its sub class C21 have the version 2,
- 59 -
Ontology Evolution and Source Autonomy in Ontology-based Data Warehouses
.
/
01
2 3
45
67
89:
; <
=
>
<?<
@A
BC D
E8
C
E8
F
E8
G
BC
H
IJKL2 M N
O
2KP
Q
IR
M
S
H
IJKL2 T N
O
2KP
Q
IR
M
S
UV
W
UV
X
D
Y
Z
[
Z
\ ]^
[___
`
ab
c
Zadeb
D
f
Ug
h
Ug
i
Z
[
Z
\
.
/
01
2 3M
H
IJKL2 T
N
O
2KP
Q
IR T
S
Z
[
Z
\ j
k l
m_ `
ab
c
Zadeb
n
o__ `
ab
c
Zadeb
.
/
01
2 3TM
E8
C
E8
F
E8
G
E/
p
D
B F
q
r
<?
s
>
t<
=
3
45 u
]^
u
]v
Ug
h
Ug
i
Uw
x
D
Y
D
Yf
U
yh
U
yz
`
b
{
Z |
l
}e~b
`
a
[
|
l

/K2

IJP2
67
89:
; <
=
>
<?<
@A
BF
`
b
{
Z
D
D
f
D
Y
3
45
Z
[
Z
\
Z
[
Z
\ ]^
|
[
|
[
|
[
|
[

j
]
 


j
]
 
^ 
2

K2P

Ł2R
.
|
[
|
[
g




g



g




g



FIG. 3 – Evolution examples.
3. Two different changes are done on the table corresponding to the sub class C21 on con-
tent and schema levels, respectively: (1) insertion and deletion operations (750 instances
are deleted et 900 are inserted), and (2) the attribute b1 is deleted and a4 is added.
These evolution scenarios of sources and ontologies cause the following problems:
1. How to integrate the Source2 of version 2 which does not reference the last version of
the shared ontology in the warehouse?
2. Suppose that an user wants to store the class C of version 2 in the warehouse. In this
case, is it possible to access data of Source1 using the class C of version 2 1? How the
link between the class C with version 2 and Source1 is established?
3. Suppose that we want to store all data of two versions of table TC21 in the warehouse.
Therefore, how we dial with replicated data and its maintenance?
In the following sections, we give answers to these problems.
3 Notions of the semantic integration method using an a pri-
ori articulation of ontologies
In this section, we present formally our approach for an automatic integration process
based on a priori articulation between local ontologies and a shared ontology. In the next
section, this model will be used to present our proposal concerning both ontology evolution
and source autonomy.
3.1 Basic concepts
Formally, an ontology is defined as the 4-tuples O < C,P, Sub,Applic >, with:
1note that the articulation between Source1 and the shared ontology is represented by the relation between the
class C and the class C1 all of version 1
- 60 -
Xuan et al.
• C is the set of the classes used to describe the concepts of a given domain (like travel
service Reynaud and Giraldo (2003), equipment failures, electronic components Pierra
et al. (2003) etc.).
• P is the set of properties used to describe the instances of the C classes. Note that it is
assumed that P defines a much greater number of properties that are usually represented
in a database. Only a subset of them might be selected by any particular database 2.
• Sub is the subsumption function defined as Sub : C → 2C 3, where for a class ci of the
ontology it associates its direct subsumed classes 4. Sub defines a partial order over C.
• Finally, Applic is a function defined asApplic : C → 2P . It associates to each ontology
class those properties that are applicable (i.e., rigid) for each instance of this class. Appli-
cable properties are inherited through the is-a relationship and partially imported through
the case-of relationship, i.e, ∀cs, c ∈ C, cs ∈ Sub(c)⇒ Applic(c) ⊂ Applic(cs).
Example 2 To illustrate the case-of relationship, let’s consider Figure 4 showing an
extension of the shared ontology Hard Disk using the case-of relationship. The local
ontology External Disk of S2 imports some properties of the shared one (Model Code,
Capacity, Interface, Transfer rate, etc.). Note that this local ontology does not import
some properties of the shared ontology like Rotational rate, Data buffer, etc. To satisfy
its needs, it adds other properties describing its External Disk like Read Rate, Write
Rate, Marque and Price. This particular relationship is a key mechanism allowing each
source both to make its own extensions and to exchange information with other actors
referencing the same shared ontology.
S2 : a source extending locally a shared ontology
My
External Disk
Is-Case-Of
1
2
6
7
8
9
12
Marque
U1
Write Rate
U2
Read Rate
U3
Imported 
properties from 
«External Disk» 
……………
12Mb/sec USB1.1128MBTS2OO2/128Toshiba
480Mb/secUSB2.01024MBKUSBDTI/1GB Kingston 
Transfer rateInterfaceCapacityModel CodeMarque
Hard Disk Ontology (shared ontology)
Price
U4
Is-depended-of
Seek time 
4
Is-A
1
Hard Disk
Model Code
Capacity
Data buffer
Software requirement 
2
37
External Disk
Interface
Weight
Dimension
10
8
9
Transfer rate
11
Rotational rate
Power type
6
5
Colour12
FIG. 4 – Case_of and IS_A relationships.
To associate instances with an ontology, we define the three following constraints referenced
to as the ontology-instance’s strong typing assumptions Pierra et al. (2004); Jean et al. (2005):
2a particular database may also extend the P set
3We use the symbol 2C to denote the power set of C.
4C1 subsumes C2 iff ∀x ∈ C2, x ∈ C1.
- 61 -
Ontology Evolution and Source Autonomy in Ontology-based Data Warehouses
1. R1-We assume that the set of classes to which an instance belongs to are ordered by the
subsumption relationship has an unique minimal class (called instance basis class).
2. R2- Each ontology specifies for each of its classes, those properties that are allowed for
use in a class instance (applicable properties).
3. R3- Each object can be described only by applicable properties of its basis class (Applic(c),
where c is the basic class of the considered instance).
On the basis of these assumptions, an ontology-based data source (OBDB) may be formally
defined as 4-tuples < O, I, Sch, Pop >, where:
• O is an ontology (O :< C,P, Sub,Applic >);
• I is the set of instances of the source; each one represented as an instance of its basis
class;
• Pop : C → 2I , associates to each class (leaf class or not) its own instances (polymorph),
that consists of instances of which this class, or any of its subsumed classes, is the basic
class.
• Sch : C → 2P associates to each ontology class ci of C the properties which are
effectively used to describe the instances of the class ci; Sch has two definitions based
on the nature of each class (a leaf or a no-leaf class). For each class ci, Sch(ci) shall
satisfy the following: Sch(ci) ⊆ Applic(ci).
Note that Sch and Pop are two functions linking the ontology part and data part in an OBDS.
For each leaf class of the subsumption hierarchy, i.e., each class ci such that Sub(ci) = φ, its
corresponding table Ti is such that: (i) the schema of Ti is Sch(ci), and (ii) the population of
Ti is Pop(ci). For all non leave classes, ck, Pop(ck) is union of population of all the tables
associated with classes that are subsumed by ck. Sch(ck) is the projection on Applic(ck), of
the union of schemas of all classes subsumed by ck 5.
3.2 An a Priori Integration Approach
Let O :< C,P, Sub,Applic > the shared ontology and S = {S, ..., Sn} the set of OBDSs
participating in the integration process. In an a priori integration, we first integrate ontologies,
and then data Bellatreche et al. (2004b). Integration of ontologies is done using subsumption
relationships between classes of different ontologies and by "importation" of properties from
the subsuming class to the sub summed class. We assume then that each source Si has been
designed following two steps Bellatreche et al. (2004b,a):
1. The source administrator has to define its own ontology: Oi : < Ci, Pi, Subi,Applici >.
But we assume that that each local ontology class cl references by a case-of relation-
ship, its smallest (w.r.t sub order) subsuming class cg in the shared ontology. We also
5in the presentation of Pop(ck), a property of Sch(ck) which is not represented for a sub class, will be , for a
particular need, valued to null. This allows to integrate sources do not having the same choice about the properties of
the ontology that are not used effectively for each class
- 62 -
Xuan et al.
assume that through this case-of relationship, cl "imports" from ck all the properties of
Applic(cg) that the source administrator wants to use in the context of its own source.
These mappings are stored in the source Si and constitute an articulation Mi between
O and Oi that defines a function: Mi : C → 2Ci , where Mi(c) is the set of classes of
Ci directly subsumed by c ∈ C,
2. The administrator chooses for each class ci: (i) its schema Schi(ci), and (ii) its instances
Popi(ci)
6
.
A source Si articulated with the shared ontology O can thus be formulated as follows:
Si :< Oi, Ii, Schi, Popi,Mi >. The integration system is also an OBDS structure: DW :<
ODW , IDW , SchDW , PopDW >. We assume that in the integration system, each instance of
each particular source is represented as an instance of its smallest subsuming class in the shared
ontology. This means that each class of Si references (directly or by inheritance ) its smallest
subsumed class(es) of the shared ontology. It (the class of Si) imports from the subsumed
classes of the shared ontology the relevant properties. All classes and properties of Si that are
not identified to the imported ones are specific to the source Si.
1. ODW is computed as an integration of the local ontologies into the shared one.
(a) CDW = C ∪ (∪1≤i≤nCi),
(b) PDW = P ∪ (∪1≤i≤nPi),
(c) ApplicDW (c) =
{
Applic(c), if c ∈ C
Applici(c), if c ∈ Ci
(d) SubDW (c) =
{
Sub(c) ∪Mi(c), if c ∈ C
Subi(c), if c ∈ Ci
2. IDW = ∪1≤i≤nIi,
The instances are stored in tables as in their sources.
(a) ∀ci ∈ CDW ∧ ci ∈ Ci ∧ ∀i ∈ [1..n]:
• SchDW (ci) = Schi(ci), and
• PopDW (ci) = Popi(ci),
(a) ∀c ∈ C
• SchDW (c) = Applic(c) ∩ (Sch(c) ∪ (∪cj∈SubDW (c)Sch(cj))),
• PopDW (c) = ∪cj∈Sub(c)Pop(cj)
6for non leaf classes, these choices should respect constraints resulting from the polymorphism: ∀ci ∈ Sub(ck) :
Pop(ci) ⊂ Pop(ck), Sch(ci) ∩Applic(ck) ⊂ Sch(ci)
- 63 -
Ontology Evolution and Source Autonomy in Ontology-based Data Warehouses
4 Constraints for evolving warehouse ontology-based inte-
gration systems
4.1 The Principle of Ontological Continuity
The constraints that we should define in order to handle the evolution of warehouse ontology-
based integration systems result from the fundamental differences existing between the evolu-
tion of conceptual models and ontologies. According to Minsky, a conceptual model is a object
allowing to respond questions on another object, named the modeled domain Minsky (1979).
When the questions change (when the organizational objectives are modified), its conceptual
model is modified too, without broadcasting the information that the modeled domain is mod-
ified. Contrary to conceptual models, an ontology is a conceptualization aiming to represent
entities of a particular domain in consensual form for a community. It is a logic theory of a part
of the world, shared by the whole of the community, and allows to their members to under-
stand each others. That can be, for example, the set theory (for mathematicians), mechanic (for
mechanics) or analytical counting (for accountants). For this type of ontologies, two changes
should be identified: normal evolution, and revolution. A normal evolution of a theory is its
deepening. New truths, more detailed are added to the old truths. What was true yesterday
remains true today. Concepts are never deleted contrary to Maedche et al. (2002). But it may
be possible that axioms of a theory become false. In this case, It is not any more an evolution
but a revolution, where two different logical systems will coexist or be opposed.
The ontologies that we consider correspond to this philosophy. They are ontologies either
standardized, for example at the international level, or defined by significant consortium which
formalize in a stable way knowledge of a technical domain. The changes in which we are
interested in our approach are those representing evolution of the axioms of an ontology and
not revolution.
Therefore, we thus impose to all manipulated ontologies (local and shared) to respect the
following principle:
Principle of ontological continuity: if we consider that each ontology of the integrated sys-
tem as a set of axioms, then any true axiom for a certain versions of ontology will remain true
for all the later versions.
4.2 Constraints on the Evolution of Ontologies
In this section, we show the constraint on each concept (classes, relation between classes,
properties and instances) of an ontology. Let Ok =< Ck, P k, Subk, Applick > be the ontol-
ogy with version k.
4.2.1 Permanence of the classes
The existence of a class could not be disapproved in a later stage: Ck ⊂ Ck+1. To take
into account the reality, it will be relevant to consider it obsolete. It will then be marked as
("defecated"), but will continue to form part of the later versions of the ontology. In addition,
the definition of a class could be refined without inferring the membership of form instance to
that class. This is means that:
- 64 -
Xuan et al.
• The definition of classes itself may evolve,
• Each class definition will be associated to a version number.
4.2.2 Permanence of properties
Similarly P k ⊂ P k+1. A property may become obsolete while the existing value of that
property remains undisputed. Similarly, a definition or a domain values of a property may
evolve. Taking into account the ontological principle of continuity, the domain of values could
be only increasing, certain values may eventually marked as obsolete.
4.2.3 Permanence of the Subsumption
Subsumption is also an ontological concept which could not be infirmed. Let Sub∗ : C →
2C be the transitive closure of the direct subsumption relation Sub. We have then:
∀C ∈ Ck, Sub∗k(c) ⊂ Sub∗k+1(c).
This constraint allows obviously a refreshment of the hierarchy of subsumption of the classes,
for example by intercalating intermediate classes between two classes linked by a relation of
subsumption.
4.2.4 Description of instances
The fact that a property p ∈ Applic(c) means that this property is rigid for each instance
of c. This is an axiom that cannot be infirmed:
∀c ∈ Ck, Applic∗k(c) ⊂ Applic∗k+1(c).
Note that this does not suppose that same properties are always used to describe the in-
stances of the same class. It is not a question of an ontological characteristic but only of a
schematic nature.
4.3 Identification of Different Elements
Evolution management supposes the power to indicate and thus identify all the evolved
elements.
4.3.1 Identification of classes and properties
We already specified that any class and any property were associated universal identifiers
(GUI). In fact these identifiers contain two parts: a code (unique) and a version (integer): GUI:
= version code.
Any reference between elements using the GUI is itself versioned by the versions of its
extremities. Finally, any definition of class or property contains in particular the date from
which this version is valid.
Note that a class has three types of evolution: (1) an ontological evolution (for example,
modification of the definition or augmentation of the applicable properties), (2) a schematic
evolution (more or less properties used to describe the instances), and (3) evolution of its pop-
ulation (insertion and deletion of instances). For reasons of simplicity, these three types of
- 65 -
Ontology Evolution and Source Autonomy in Ontology-based Data Warehouses
changes is ensured by incrementing the same indicator of the version. A version thus charac-
terizes a definition, a schema and a population.
4.3.2 Identification of instances
In order to recognize at the maintenance time of the warehouse, any source must define for
each class having a population a semantic key. This key is constituted by the representation
(in character string form) of one or several values of applicable properties of this class. The
properties are always provided for each instance of the class and will have never to be modified.
The other properties could or not be provided according to choice’s (with each version) of the
schema of the instances of the class. Their values will not have, on the other hand, to be
modified from one version to another.
The life cycle of an instance (appearance and disappearance) is then defined by the versions
of the classes to which it belongs.
5 Floating Version Model
Our management model has several objectives: (i) to allow a total access to the whole of
the existing instances of the warehouse via shared ontology, (ii) to know the history of the in-
stances, and (iii) possibly, to know, for each instance, which version of ontology it corresponds.
We describe below successively how we can reach the three aspects above defined.
5.1 Management of Updates
We suppose that our warehouse is refreshed in the following way. At given moments cho-
sen by the data warehouse administrator, the current version of a source Si is integrated in the
warehouse. It includes its ontology, its references to shared ontology, and its contents (cer-
tain instances were eventually already integrated, others are new, others are removed). This
scenario corresponds, for example, in the engineering domain with a warehouse consolidating
descriptions of components of a whole of suppliers. A maintenance is carried out each time
that a new version of an electronic catalogue of a supplier is received.
5.2 A Global Access to Current Instances
We call current instances of the warehouse the instances resulting from most recent mainte-
nance from each source. The principal difficulty, resulting from the autonomy of each source,
is that during two successive maintenance done by two different sources, the same class of
shared ontology c can be referred by an articulation of subsumption (see section 3.2) in dif-
ferent versions. For example ck and ck+j by two classes cni and c
p
j . According to ontological
principle of continuity, it is advisable to note that:
1. All applicable properties in ck are also applicable in ck+j ,
2. All subsumed classes by ck are also subsumed by ck+j ,
- 66 -
Xuan et al.
The relation of subsumption between ck and cni could be replaced by a relation of subsumption
between ck+j and cni . The class ck is not thus necessary to reach the instances of cni . This
remark leads us to propose a model, called model of the floating versions, which enables us to
reach the data via only one version of the warehouse ontology. This version, called "current
version" of the warehouse ontology, such as the current version of each one of its classes cf is
higher or equal to the largest version of that class referred by an articulation of subsumption at
the time of any maintenance.
In practice, this condition is satisfied as follows:
• If an articulationMi references a class cf with a version lower than f , thenMi is updated
in order to reference cf ,
• If an articulationMi references a class cf with a version greater than f , then the ware-
house load the last version of the shared ontology and migrates all references Mi (i =
1..n) to new current versions.
Example 3 During the maintenance process of a class C1 that references the class C with
version 2, the version of C in current ontology is 1. In this case, the warehouse downloads
the current version of shared ontology. This one being 3, therefore the class C1 is modified to
reference the version 3 (Figure 5).



 
















 
¡
¢



¢
¡
£

¤

¥
¦§





 



 ¨


¤
©


 
¡
¢

©

¨ ª
«¬­
®
¯
FIG. 5 – A Model of the floating versions.
If the only requirements of users is to know the current instances, then, at each mainte-
nance step, the table eventually associated to each class coming from a local ontology in the
warehouse is simply replaced by the corresponding current table in the local source.
5.3 Representation of history of instances
In some situations, it may be useful to know the existence of instances in the warehouse
at any last moment. To do so, we do not need to archive also the versions of ontologies
since the current version is compatible with all the last instances. This problem is known by
"schema versioning" Wei and Elmasri (1999), where all versioned data of a table are saved.
Two solutions are possible to satisfy this requirement:
- 67 -
Ontology Evolution and Source Autonomy in Ontology-based Data Warehouses
• In the approach explicit storage Bebel et al. (2004); Wei and Elmasri (1999), all the ver-
sions of each table are explicitly stored (see Figure 6). This solution has two advantages:
(i) it is easy to implement and allows an automation of the process of update of data, and
(ii) query processing is straitforward in cases where we precise the versions on which
the search will be done. On the other hand, the query processing cost can be very impor-
tant if the query needs an exploration of all versioned data of the warehouse. Another
drawback is due to the storage of the replicated data.
• In the approach implicit storageWei and Elmasri (1999): only one version of schema of
each table T is stored. This schema is obtained by making the union of all properties
appearing in various versions. To each maintenance, we add the existing instance of
the current table. The instances are supplemented by null values (see Figure 6). This
solution avoid the exploration of several versions of a given table. The major drawbacks
of this solution are: (i) the problem of replicated data is always present, (ii) the imple-
mentation is more difficult than the previous one concerning the automatic computation
of the schema of stored tables; (iii) the layout of the cycle of life of data is difficult to
implement ("valid time"Wei and Elmasri (1999)) and (iv) the semantics ambiguity of
the null values.
°
±
²
³
´
µ
´
¶
·
¶
¸
¹
º
»
¼
¸
½
¾
¼
¹
·
´
¸
¿
·
¸
½
¶
º
º
À
³
¼
°
±
²
³
´
µ
´
¶
·
¶
¸
¹
º
»
¼
Á Â Ã Ä Å Æ Å Ç È ÉÊ É Ë Ì Å Ç È Í ÉÊ Î Ï
Ð ÐÑ Ò
Í
Ó
Í Ô Å Ê ÈÕ Í
Ö
× Ø
Ù Ú Û Ü Ý Þ ßà á âã
ä
å å æ ç ç ç
å å Ï Î Í Å
Ó
Ê Â è
é Â è Í Ä
ê
Ñ Â è Å Ñ Â è Å
ë ë
ì Å Å í î Ê ï
ë ëë ë
Ïå å å
ëë ë
Æ Å Ç È É Ê Á Â Ã Ä Å É Ë Ì ÅÇ È Í ÉÊ Î æ
Ð ÐÑ Ò
Í
Ó
Í Ô Å Ê ÈÕ Í
Ö
× ð ñ ñ ò ó
ô
ã
ä
õ å å Á ö Õ Â ÷
ë ë
Ñ Â è Å
Ð Â Ä ÂÇ
ê
×
ø ù
í ÅÕ Ïú å å
ë ë
Ïå å å
ëë ë
Ïå å Ï
ëë ë
ë ëë ë
Ñ É Ð Ð Ò
Í
Ó
Í Ô ÅÊ ÈÕ Í
Ö
× ð ñ ñ
Û Ü Ý Þ ß à á âã
ä
å å Ï
ë
ë ë
é Â è Í Ä
ê
Ñ Â è Å
Ð Â Ä ÂÇ
ê
×
ø ù
ì Å Å Ê î Ä Ä
ë
Ê î Ä Ä
Ñ Â è Å
í î Ê ï
ë
õ å å Á ö Õ Â ÷í Å Õ Ïú å å
ë
ë ëë ëë
Ïå å Ï
ëë ë
Ê î Ä Ä
ë ëë ë
Ê î Ä Ä
FIG. 6 – Implicit and explicit storage.
Our solution follows the second approach and solves the problems in the following way:
1. The problem of replicated data is solved thanks to the single semantic identification
(value of the semantic key) of each instance of data,
- 68 -
Xuan et al.
2. The problem of automation of the update process of table schema is solved through the
use of universal identifiers (GUI) for all the properties which can result from a null value
in the table of a source, or the need for supplementing each instance.
3. The problem of the representation of the cycle of life of the instances is solved by a pair
of properties: (V ersionmin, V ersionmax). It enables us to know the validation of a
given instance.
4. The problem of semantic ambiguity of the null values: is handled by archiving the func-
tions Sch of various versions of each basic class of a table. This archive enables us to
determine the true schema of version of a table, and thus the initial representation of
each instance.
5.4 The Data Warehouse Structure
û ü
ý þ ß          
ý þ ß         
û ü
û 	
û ü
û ü
û ü
û ü
û ü
û ü

               
           
    ff fi fl ffi     fi !
 " # $ fi ffi
% & ' ' ( ) *
+
) *
+ , + - .
/ ' 0 1 2 3 (
+ 4 +
) *
+ , + -
2 ( 5
6 2 5 *
+
' 2 7 ( 8 9 : ' ( 1
+
& 5 (
FIG. 7 – Structure of warehouse integrated system.
The articulation between a local ontology and shared ontology that is stored in the current
version of the warehouse ontology may not be its original definition (see the Figure 5). In this
case, it is necessary to reach an instance through the ontological definitions existed when this
instance was itself activated. It is necessary to archive also all the versions of the warehouse
ontology. It can be useful, for example, to know what was, at the time of the instance, the exact
domain of its enumerated properties.
We also implemented this possibility to offer the archive in a warehouse, all versions of
classes having existed in the life of the warehouse, and all the relations in their original form.
Note that the principle of ontological continuity seems to make seldom necessary this complex
archive. To summarize, we present the complete structure of a warehouse in a multiversioned
environment (see Figure 7). This structure composed by three parts:
1. The current ontology: it contains the current version of the warehouse ontology. It
represent also a generic interface to access data.
2. Ontology archive: contains all versions of each class and property of the warehouse
ontology. This part gives to users the true definitions of versions of each concept if it is
- 69 -
Ontology Evolution and Source Autonomy in Ontology-based Data Warehouses
necessary. Versions of schema of table Ti are also historized by archiving the function
Schk(ci) of each version k of ci where ci corresponds to the table Ti .
3. multiversioned tables: contain all instances and their first and last activated versions.
; < =
; < >
? =
@ A B C D E F =
@ A B C D E F =
G H I J K L M N J K O N P L I O Q J R
? = ? S < = ? T
F U V V
F U V V
=W W W
D F C X ? F Y A C
Z
W W
D F C X ? F Y A C
> [ W
D F C X ? F Y A C
; ? =
; ? >
; ? S
; \ ]
; < =
; < >
^ _
; ? =
; ? S
; ? T
^ _ `
^
@ A B C D E F >
@ A B C D E F =
@ A B C D E F >
; ? =
; ? >
; ? S
^ _
^ _ `
^ ^
@ A B C D E F >
@ A B C D E F =
? S
^ _ `
^ `
; ? =
; ? S
^ `
@ A B C D E F >
^ _
; ? =
; ? S
@ A B C D E F >
@ A B C D E F >
@ A B C D E F =
a b c d e f g h i e g j
k
b c d e f g h i l m
FIG. 8 – Figure 3 after the maintenance phase.
The result of problem of asynchronous evolution management presented in example of
section 2 is illustrated in Figure 8.
6 Implementation
In order to validate our work, we have developed a prototype integrating several OBDSs
(Figure 9), where ontologies and sources are described using PLIB ontology models Pierra
et al. (2003)which are specified by Express language Schenk and Wilson (1994) . Such ontolo-
gies are exchangeable as instances of EXPRESS files ("physical file"). To compile EXPRESS
files, the ECCO Toolkit of PDTec which offers the following main functions Staub and Maier
(1997):
1. Edition and syntax and semantic checker of EXPRESS models;
2. Generation of functions (Java and C++) for reading, writing and checking integrity con-
straints of a physical file representing population of instances of an EXPRESS schema;
3. Manipulation of the population (physical file) of EXPRESS models using a graphical
user interface;
4. Access to the description of a schema in the form of objects of a meta-model of EX-
PRESS;
- 70 -
Xuan et al.
5. Availability of a programming language called EXPRESS-C. It is an extension of the
EXPRESS language. It allows managing an EXPRESS schema and its instance objects.
It has two main extensions: capability to make input-output with external environments
and to support event-based programming i.e., triggering a program by event occurrence.
n o p q r s t u q v w t x t y
z { n | t z n v q u u } y
} | ~ 
| ~ | }
| ~ | } 

















Ł
}       
q        q       x        
             } | ~ 
x                 
z { n | q ~ n p } r
FIG. 9 – Architecture of our Prototype.
An ontology (or OBDS), described in file of instances of Express, is created via editor
called, PLIBEditor. It is used also to visualize, edit and evolve ontologies and sources. It
uses a set of PLIB API developed under ECCO. PLIBEditor proposes a QBE-like graphical
interface to query the data from the ontologies. This interface relies on the OntoQL query
language Jean et al. (2005) to retrieve the result of the interactively constructed queries. Figure
10 shows an ontology defining concepts of the LMD (License, Master, Doctorate) university
cursus in the PLIB ontology model Pierra et al. (2003). Description of shared ontology and
local ontologies is done using PLIBEditor.
FIG. 10 – PLIBEditor.
- 71 -
Ontology Evolution and Source Autonomy in Ontology-based Data Warehouses
generic access through 
the standard ontology
specific assess 
to each catalogue
Thanks to an generic access, nail instances of all specific catalogues are loaded in the same table
FIG. 11 – An example of nail integrated system.
We have developed a set of integration API allowing the management of the warehouse
integrated system through a domain ontology and integrate OBDSs in that warehouse. Figure
11 shows a scenario of integrating sources modeling nails of 6 companies from China, France,
Germany, Thailand, USA and Vietnam. We have also implement an ontological archiving
option, allowing to store just relevant versions (chosen by the warehouse administrator). These
integration APIs are incorporated in PLIBEditor.
7 Conclusion
In this article, we presented the problem of management of asynchronous evolution of the
data and ontologies in a warehouse ontology-based integration systems. The sources that we
considered are those containing local ontologies referencing in a priori manner a shared one.
These sources are autonomous and heterogeneous. Our integration process integrates first on-
tologies and then the data. The presence of ontologies allows an automation of the integration
process of integration by facilitating the conflict resolution. But it makes the management of
autonomy of sources more difficult. This difficulty is due to the presence of a new dimension
which is the ontology. To solve this problem, we presented a multi-version approach. Initially,
some constraints on ontologies and the data of the sources were defined. The evolution of on-
tologies is carried out according to the principle of ontological continuity (an evolution of an
ontology cannot cancel an axiom previously true). A structure of a ontology-based warehouse
(which references also the shared ontology) is presented. It consists of three parts, namely,
(1) the current ontology which contains the current version of the warehouse ontology, (2) the
archive of ontologies which contains all the versions of each class and property of the ware-
house ontology, and (3) the multiversioned tables containing all instances and their first and
last version of activities. This structure allows the tracing the cycle of life of the instances and
the data access is done in a transparent manner. Our model was validated under ECCO by
considering several domain ontologies, where for each ontology, a set of sources was defined.
- 72 -
Xuan et al.
It would be interested to consider a mediator architecture of our proposed model and archi-
tecture, the problem of view maintenance in an ontology-based warehouse and finally, evalua-
tion of our approach in order to measure its scalability.
References
Arens, Y. and C. A. Knoblock (1993). Sims: Retrieving and integrating information from
multiple sources. Proceedings of the International Conference on Management of Data
(SIGMOD’1993), 562–563.
Bebel, B., J. Eder, C. Koncilia, T. Morzy, and R. Wrembel (2004). Creation and management
of versions in multiversion data warehouse. Proceedings of the 2004 ACM symposium on
Applied computing, 717–723.
Bellatreche, L., G. Pierra, D. Nguyen Xuan, H. Dehainsala, and Y. Ait Ameur (2004a). An
a priori approach for automatic integration of heterogeneous and autonomous databases.
International Conference on Database and Expert Systems Applications (DEXA’04) (475-
485).
Bellatreche, L., G. Pierra, D. Xuan, and D. Hondjack (2004b). Intégration de sources de
données autonomes par articulation a priori d’ontologies. Proc. du 23ème congrès Inforsid,
283–298.
Castano, S. and V. Antonellis (1997). Semantic dictionary design for database interoperability.
Proceedings of the International Conference on Data Engineering (ICDE), 43–54.
Chawathe, S. S., H. Garcia-Molina, J. Hammer, K. Ireland, Y. Papakonstantinou, J. D. Ull-
man, and J. Widom (1994). The tsimmis project: Integration of heterogeneous information
sources. Proceedings of the 10th Meeting of the Information Processing Society of Japan,
7–18.
Chen, S., B. Liu, and E. A. Rundensteiner (2004). Multiversion-based view maintenance over
distributed data sources. ACM Transactions on Database Systems 4(29), 675–709.
Doan, A., N. F. Noy, and A. Y. Halevy (2004). Introduction to the issue on semantic integration.
SIGMOD Record 33(4).
Goh, C., S. Bressan, E. Madnick, and M. D. Siegel (1999). Context interchange: New fea-
tures and formalisms for the intelligent integration of information. ACM Transactions on
Information Systems 17(3), 270–293.
Goh, C. H., S. E. Madnick, and M. Siegel (1994). Context interchange: Overcoming the
challenges of large-scale interoperable database systems in a dynamic environment. in Pro-
ceedings of the Third International Conference on Information and Knowledge Management
(CIKM’94), 337–346.
Gruber, T. (1995). A translation approach to portable ontology specification. Knowledge
Acquisition 5(2), 199–220.
Hakimpour, F. and A. Geppert (2002). Global schema generation using formal ontologies. in
Proceedings of 21th International Conference on Conceptual Modeling (ER’02), 307–321.
Jean, S., G. Pierra, and Y. Ait-Ameur (2005). Ontoql: an exploitation language for obdbs.
VLDB Ph.D. Workshop, 41–45.
- 73 -
Ontology Evolution and Source Autonomy in Ontology-based Data Warehouses
Klein, M. and N. F. Noy (2003). A component-based framework for ontology evolution. Pro-
ceedings of eighteenth International Joint Conference on Artificial Intelligence.
Lander, T. and R. L. Rosenberg (1982). An overview of multibase. in Proceedings of the
Second Symposium of Distributed Databases.
Lawrence, R. and K. Barker (2001). Integrating relational database schemas using a stan-
dardized dictionary. in Proceedings of the ACM Symposium on Applied Computing (SAC),
225–230.
Levy, A. Y., A. Rajaraman, and J. J. Ordille (1996). The world wide web as a collection
of views: Query processing in the information manifold. Proceedings of the International
Workshop on Materialized Views: Techniques and Applications (VIEW’1996), 43–55.
Maedche, A., B. Motik, L. Stojanovic, R. Studer, and R. Volz (2002). Managing multiple
ontologies and ontology evolution in ontologging. Intelligent Information Processing, 51–
63.
Mena, E., V. Vipul Kashyap, A. Illarramendi, and A. P. Sheth (1996). Managing multiple in-
formation sources through ontologies: Relationship between vocabulary heterogeneity and
loss of information. in Proceedings of Third Workshop on Knowledge Representation Meets
Databases.
Minsky, M. (1979). Computer science and the representation of knowledge. in The Computer
Age: A Twenty-Year View, Michael Dertouzos and Joel Moses, MIT Press, 392–421.
Mitra, P., G. Wiederhold, and M. Kersten (2000). A graph-oriented model for articulation of
ontology interdependencies. in Proceedings of the 7th International Conference on Extend-
ing Database Technology (EDBT’00), 86–100.
Noy, N. F. and M. Klein (2003). Ontology evolution: Not the same as schema evolution.
Knowledge and Information Systems 5.
Pierra, G., H. Dehainsala, Y. A. Ameur, L.Bellatreche, J. Chochon, and M. Mimoune (2004).
Base de Données à Base Ontologique : le modèle OntoDB. Proceeding of Base de Données
Avancées 20èmes Journées (BDA’04), 263–286.
Pierra, G., J. C. Potier, and E. Sardet (2003). From digital libraries to electronic catalogues for
engineering and manufacturing. International Journal of Computer Applications in Tech-
nology (IJCAT) 18, 27–42.
Reynaud, C. and G. Giraldo (2003). An application of the mediator approach to services
over the web. Special track "Data Integration in Engineering, Concurrent Engineering
(CE’2003) - the vision for the Future Generation in Research and Applications, 209–216.
Roth, M. T., M. Arya, L. Haas, M. Carey, W. Cody, R. agin, P. Schwarz, J. Thomas, and
E. Wimmers (1996). The garlic project. Proceedings of the ACM SIGMOD International
Conference on Management of Data, 557–557.
Schenk, D. and P. Wilson (1994). Information Modelling The EXPRESS Way. Oxford Univer-
sity Press.
Staub, G. and M. Maier (1997). Ecco tool kit - an environnement for the evaluation of express
models and the development of step based it applications. User Manual.
Wache, H., T. Vögele, U. Visser, H. Stuckenschmidt, G. Schuster, H. Neumann, and S. Hübner
(2001). Ontology-based integration of information - a survey of existing approaches. Pro-
- 74 -
Xuan et al.
ceedings of the International Workshop on Ontologies and Information Sharing, 108–117.
Wei, H.-C. and R. Elmasri (1999). Study and comparison of schema versioning and database
conversion techniques for bi-temporal databases. Proceedings of the Sixth International
Workshop on Temporal Representation and Reasoning (IEEE Computer).
Wiederhold, G. (1992). Mediators in the architecture of future information systems. IEEE
Computer 25(3), 38–49.
Résumé
Une nouvelle génération de systèmes d’intégration utilise des ontologies pour résoudre
les conflits sémantiques et structurels entre les différentes sources de données participant au
processus d’intégration. Ces systèmes supposent l’existence d’une ontologie partagée de do-
maine et que chaque source possède une ontologie locale qui référence, et éventuellement étend
l’ontologie partagée. Le processus d’intégration est alors basé sur ces références qui consti-
tuent une articulation des ontologies locales et l’ontologie partagée. Notons que les sources
de données sont indépendantes, chacune peut évoluer indépendamment des autres, ce qui en-
gendre un problème d’évolution asynchrone. Dans le contexte d’une telle intégration à base
ontologique, les évolutions concernent donc à la fois les ontologies, les schémas et les don-
nées. Dans cet article, nous proposons un modèle pour la gestion de l’évolution des systèmes
d’intégration à base ontologique, dont le résultat est matérialisé sous forme d’un entrepôt de
données. L’hypothèse fondamentale de notre travail, appelée, le principe de continuité onto-
logique, stipule qu’une évolution d’une ontologie ne peut infirmer un axiome antérieurement
vrai. Ce principe permet d’interpréter toute instance représentée. En conséquence, il simplifie
considérablement la gestion de l’évolution des ontologies. Ceci permet d’assurer une inté-
gration automatique. Ce travail a été motivé par l’intégration automatique des catalogues de
composants industriels dans les bases de données d’ingénierie. Il a été validé par un prototype
sous un environnement ECCO et le langage EXPRESS.
- 75 -
- 76 -
