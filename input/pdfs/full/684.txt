Interrogation des rÃ©sumÃ©s de flux de donnÃ©es
Nesrine Gabsiâˆ—,âˆ—âˆ—, Fabrice ClÃ©rot âˆ—âˆ—
Georges HÃ©brailâˆ—
âˆ—Institut TELECOM ; TELECOM ParisTech ; CNRS LTCI
46, rue Barrault 75013 Paris
prÃ©nom.nom@telecom-paristech.fr,
âˆ—âˆ— France Telecom RD
2, avenue P.Marzin 22307 Lannion
prÃ©nom.nom@orange-ftgroup.com
RÃ©sumÃ©. Les systÃ¨mes de gestion de flux de donnÃ©es (SGFD) ont Ã©tÃ© conÃ§us
afin de traiter une masse importante de donnÃ©es produites en ligne de faÃ§on
continue. Etant donnÃ© que les ressources matÃ©rielles ne permettent pas de conser-
ver toute cette volumÃ©trie, seule la partie rÃ©cente du flux est mÃ©morisÃ©e dans la
mÃ©moire du SGFD. Ainsi, les requÃªtes Ã©valuÃ©es par ces systÃ¨mes ne peuvent por-
ter que sur les donnÃ©es les plus rÃ©centes du flux. Par consÃ©quent, les SGFD ac-
tuels ne peuvent pas traiter des requÃªtes qui portent sur des pÃ©riodes trÃ¨s longues.
Nous proposons dans cet article, une approche permettant dâ€™Ã©valuer des requÃªtes
qui portent sur une pÃ©riode plus longue que la mÃ©moire du SGFD. Ces fenÃªtres
font appels Ã  des donnÃ©es rÃ©centes et des donnÃ©es historisÃ©es. Nous prÃ©sentons
le niveau logique de cette approche ainsi que son implantation sous le SGFD Es-
per. Une technique dâ€™Ã©chantillonnage associÃ©e Ã  une technique de fenÃªtre point
de repÃ¨re est appliquÃ©e pour conserver une reprÃ©sentation compacte des donnÃ©es
du flux.
1 Introduction
Contrairement aux systÃ¨mes transactionnels classiques oÃ¹ les donnÃ©es sont conservÃ©es
avant dâ€™Ãªtre traitÃ©es, les SystÃ¨mes de Gestion de Flux de DonnÃ©es (SGFD)( Babcock et al.
(2002a)) effectuent un traitement Ã  la volÃ©e en une seule passe (sans conservation a priori des
donnÃ©es) et permettent de poser des requÃªtes continues. Compte tenu du volume et du dÃ©bit
des donnÃ©es, les SGFD ne conservent que les donnÃ©es rÃ©centes ou celles du passÃ© rÃ©cent dans
des structures appelÃ©es fenÃªtres. Ces donnÃ©es ne peuvent Ãªtre analysÃ©es a posteriori. Il est ainsi
nÃ©cessaire, pour tout besoin dâ€™analyse sur les flux, de prÃ©ciser a priori sa tÃ¢che avant lâ€™arrivÃ©e
des donnÃ©es. Cependant, si un nouveau besoin portant sur des donnÃ©es Ã©coulÃ©es est exprimÃ©,
ces tÃ¢ches ne sont plus rÃ©alisables. Une solution permettant le traitement a posteriori consiste
Ã  conserver un rÃ©sumÃ© du flux. Il sâ€™agit de rÃ©sumer le contenu du flux de faÃ§on Ã  construire
un modÃ¨le rÃ©sumÃ© qui, bien que beaucoup plus petit en taille, permet de rÃ©pondre Ã  ces tÃ¢ches
mais dâ€™une maniÃ¨re approchÃ©e.
RNTI-E-19- 247 -
Interrogation des rÃ©sumÃ©s de flux de donnÃ©es
Les rÃ©sumÃ©s des flux sont typiquement stockÃ©s dans des bases de donnÃ©es permettant aux
utilisateurs de les interroger via un langage dâ€™interrogation classique. La conservation de rÃ©-
sumÃ© permet de poser des requÃªtes sur le passÃ©. Cependant, dans plusieurs applications, il est
nÃ©cessaire de poser des requÃªtes qui portent Ã  la fois sur des donnÃ©es du passÃ© (donnÃ©es histo-
riquesmÃ©morisÃ©es dans le rÃ©sumÃ©) et les donnÃ©es du prÃ©sent (donnÃ©es conservÃ©es en mÃ©moire
du SGFD). Un exemple de requÃªte dans le domaine financier consiste Ã  envoyer une alerte si
lâ€™indice boursier observÃ© sur les 5 derniÃ¨res heures sâ€™Ã©carte de plus de 20% de celui observÃ© le
mÃªme jour il y a un mois.
Lâ€™Ã©valuation de telles requÃªtes pose un certain nombre de problÃ¨mes, le traitement dâ€™une
requÃªte qui porte sur une pÃ©riode trÃ¨s longue ne peut Ãªtre rÃ©alisÃ©e ni par les SGBD (qui ne sont
pas capables de prendre en considÃ©ration la pÃ©riode rÃ©cente du flux) ni par les SGFD (qui ne
sont pas capables de prendre en compte le passÃ©).
Ce papier prÃ©sente une nouvelle approche permettant dâ€™Ã©valuer des requÃªtes qui portent sur
une longue pÃ©riode nÃ©cessitant ainsi des donnÃ©es du prÃ©sent et des donnÃ©es du passÃ©.
2 Travaux connexes
GÃ©nÃ©ralement, il existe trois scÃ©narios possibles pour Ã©valuer des requÃªtes sur un systÃ¨me
de gestion de donnÃ©es. Le premier consiste Ã  interroger des donnÃ©es archivÃ©es (donnÃ©es histo-
riques) qui, sont prÃ©sentent dans le systÃ¨me avant lâ€™arrivÃ©e de requÃªtes. Cet axe est largement
Ã©tudiÃ© par les SGBD traditionnels. Le second scÃ©nario consiste Ã  poser des requÃªtes continues
sur des donnÃ©es Ã©phÃ©mÃ¨res. Des recherche dans ce sujet ont permis de dÃ©velopper les SGFD
ainsi que des nouveaux langages dâ€™interrogation (ex. CQL( Arasu et al. (2003))) qui permettent
de traiter les donnÃ©es rÃ©cente des flux. La derniÃ¨re classe de requÃªtes fait intervenir des don-
nÃ©es archivÃ©e et des donnÃ©es rÃ©centes. Lâ€™interrogation de telles requÃªtes est un sujet trÃ¨s rÃ©cent
et encore ouvert.
Dans Chandrasekaran et Franklin (2004), les auteurs sâ€™intÃ©ressent au traitement de requÃªtes
qui font intervenir le passÃ©. Lâ€™idÃ©e gÃ©nÃ©rale consiste Ã  Ã©valuer des requÃªtes qui portent sur des
donnÃ©es du prÃ©sent concatÃ©nÃ©es avec des donnÃ©es historiques. Cependant, lâ€™article sâ€™intÃ©resse
Ã  des requÃªtes de courtes durÃ©es (ex. 5 minutes, une plage horaire prÃ©cise dans la journÃ©e, une
semaine) et Ã  minimiser le coÃ»t des entrÃ©es/sorties dans lâ€™interrogation de la base. En revanche,
dans cette communication, notre intÃ©rÃªt se porte sur des pÃ©riodes temporelles glissantes1 et de
longues durÃ©es (ex. des mois, des annÃ©es).
Il existe plusieurs approches de rÃ©sumÃ© : approches dites simples (ex. Reservoir Sam-
pling( Vitter (1985))) et approches dites complexes (ex. StreamSamp( Csernel et al. (2006))).
Lâ€™interrogation des rÃ©sumÃ©s simples est triviale mais la qualitÃ© des rÃ©sultats est mÃ©diocre. Dans
le cas du reservoir sampling les poids associÃ©s au Ã©chantillons augmentent linÃ©airement, ce qui
rend insatisfaisante la qualitÃ© des rÃ©ponses aux requÃªtes. Tandis que lâ€™interrogation des rÃ©su-
mÃ©s complexes est difficile mais fournit une meilleur performance. Cet article prÃ©sente lâ€™inter-
rogation dâ€™un rÃ©sumÃ© complexe et plus prÃ©cisÃ©ment le cas de rÃ©sumÃ©s conÃ§us par lâ€™approche
StreamSamp.
StreamSamp. StreamSamp est basÃ© sur une technique de rÃ©-Ã©chantillonnage alÃ©atoire des
donnÃ©es. DÃ¨s leur arrivÃ©e, les donnÃ©es du flux sont Ã©chantillonnÃ©es Ã  un taux Î± et placÃ©es
1Lâ€™aspect glissant des fenÃªtres concerne Ã  la fois la partie rÃ©cente et la partie historique du flux.
RNTI-E-19 - 248 -
Gabsi et al.
dans des Ã©chantillons de taille fixe T . Lorsque T est atteint, lâ€™algorithme mÃ©morise lâ€™Ã©chan-
tillon ainsi que sa date de dÃ©but et fin de constitution. Lorsque L Ã©chantillons sont constituÃ©e,
lâ€™algorithme fusionne les deux plus anciens Ã©chantillons pour former,par rÃ©-Ã©chantillonnage
alÃ©atoire, un nouvel Ã©chantillon de taille T couvrant ainsi une pÃ©riode temporelle deux fois
plus grande. Lâ€™idÃ©e consiste ainsi Ã  conserver des Ã©chantillons de taille constante qui sâ€™Ã©talent
sur des pÃ©riodes temporelles de durÃ©e variable, plus courtes pour le prÃ©sent et plus longues
pour le passÃ© lointain. Pour modÃ©liser la reprÃ©sentativitÃ© des Ã©chantillons, lâ€™algorithme se base
sur un systÃ¨me de pondÃ©ration croissante (voir Csernel et al. (2006) pour plus de dÃ©tails sur le
fonctionnement de cet algorithme).
3 SpÃ©cification du problÃ¨me
Dans cette communication, nous nous sommes intÃ©ressÃ©s Ã  lâ€™Ã©valuation des requÃªtes hy-
brides.
DÃ©finition 1.Une requÃªte est dite hybride si elle porte Ã  la fois sur des donnÃ©es anciennes et
des donnÃ©es rÃ©centes. Les donnÃ©es anciennes sont disponibles sous forme de rÃ©sumÃ© en base
de donnÃ©es et, les donnÃ©es rÃ©centes le sont sous forme de flux.
Deux grandes familles de requÃªtes hybrides peuvent se distinguer : (1) requÃªtes rÃ©fÃ©ren-
Ã§ant des donnÃ©es rÃ©centes et une pÃ©riode passÃ©e fixe (ex. vÃ©rifier si les indices boursiers actuels
sâ€™Ã©cartent de plus de 10% de la moyenne de ceux du mois de juin 2006) et, (2) requÃªtes rÃ©fÃ©ren-
Ã§ant des pÃ©riodes rÃ©centes et une pÃ©riode passÃ©e mobile (ex. une requÃªte qui permet de dÃ©tecter
dâ€™Ã©ventuelles fraudes dans les systÃ¨mes bancaires en comparant lâ€™activitÃ© actuelle de la carte
de crÃ©dit Ã  lâ€™activitÃ© des 30 derniers jours glissants). Le traitement de la premiÃ¨re catÃ©gorie de
requÃªte est simple, il suffit dâ€™appliquer (une seule fois) la requÃªte SQL Ã  la base de rÃ©sumÃ© et
enchaÃ®ner par la suite par le traitement de la fenÃªtre glissante sur les donnÃ©es rÃ©centes. Tandis
que, le traitement de la seconde catÃ©gorie de requÃªte est plus compliquÃ© puisquâ€™il sâ€™agit dâ€™une
requÃªte glissante sur la base de donnÃ©es et, les systÃ¨mes de gestion de donnÃ©es existants ne dis-
posent pas des outils nÃ©cessaires pour de tels traitements. Câ€™est lâ€™objectif sur lequel se base ce
travail. Lâ€™idÃ©e consiste Ã  Ã©tendre un SGFD existant pour lâ€™enrichir de faÃ§on Ã  pouvoir Ã©valuer
des requÃªtes glisantes portant sur une base de donnÃ©es associÃ©e.
Soit un utilisateur qui dÃ©finit une requÃªtes continue sur une pÃ©riode de longueur (N ) items.
Cette requÃªte est rÃ©Ã©valuÃ©e tous les Î” items2. On note n le nombre dâ€™items que le SGFD peut
conserver en mÃ©moire. Ces items sont traitÃ©s sous la forme dâ€™une fenÃªtre glissante de t âˆ’ n
jusquâ€™Ã  t. Deux situations peuvent rÃ©sulter de cette description :
â€“ Si n â‰¥ N : Cela veut dire que la totalitÃ© de la pÃ©riode dÃ©crite par la requÃªte de lâ€™utilisa-
teur peut Ãªtre mÃ©morisÃ©e dans la mÃ©moire du SGFD. Ainsi, cette requÃªte sera traitÃ©e par
le mÃ©canisme classique du SGFD.
â€“ Si n â‰ºâ‰º N : La requÃªte posÃ©e par lâ€™utilisateur porte sur des donnÃ©es qui ne peuvent Ãªtre
mÃ©morisÃ©es en totalitÃ© dans la mÃ©moire du SGFD (cf. figure 1). Le systÃ¨me doit ainsi
combiner un traitement sur des donnÃ©es stockÃ©es dans le rÃ©sumÃ© (pÃ©riode tâˆ’N Ã  tâˆ’n)
et sur des donnÃ©es prÃ©sentes dans la mÃ©moire du SGFD (pÃ©riode tâˆ’ n Ã  t). Câ€™est le cas
que nous traitons dans cet article. Lâ€™approche dÃ©finit dans la section suivante consiste Ã 
mettre Ã  jour une fenÃªtre temporelle comprenant les donnÃ©es nÃ©cessaires Ã  lâ€™Ã©valuation
2Î” est un paramÃ¨tre fixÃ© par lâ€™utilisateur.
RNTI-E-19- 249 -
Interrogation des rÃ©sumÃ©s de flux de donnÃ©es

		




	
		
	

	 

	
	
	




 
		
	

			
		
		
		

	
FIG. 1 â€“ Exemple de fenÃªtre faisant appel Ã  des donnÃ©es du passÃ© et des donnÃ©es rÃ©centes.
de la requÃªte. Cette fenÃªtre est mise Ã  jour chaque fois que Î” items du flux sont insÃ©rÃ©s
dans la mÃ©moire du SGFD.
4 Approche proposÃ©e
Dans cet article, nous considÃ©rons un flux F observÃ© aux instants 1, ..., t. Au fur et Ã  mesure
de lâ€™arrivÃ©e des items, le flux est traitÃ© par le SGFD et par un algorithme de rÃ©sumÃ©. Nous
considÃ©rons ici un rÃ©sumÃ© par Ã©chantillonnage alÃ©atoire qui est conservÃ© dans une base et
mis Ã  jour avec lâ€™arrivÃ©e du flux. Nous disposons ainsi dâ€™un Ã©chantillon pour toute fenÃªtre du
passÃ©. Pour simplifier, nous considÃ©rons les requÃªtes dâ€™agrÃ©gat appliquÃ©es Ã  lâ€™ensemble de la
pÃ©riode interrogÃ©e, seul le cas des fenÃªtres logiques (exprimÃ©es en terme de nombre dâ€™items)
est traitÃ©. Ces requÃªtes peuvent Ãªtre alors estimÃ©es Ã  partir des Ã©chantillons conservÃ©s. Pour
quantifier lâ€™imprÃ©cision liÃ©e Ã  lâ€™utilisation dâ€™un rÃ©sumÃ©, un intervalle de confiance est associÃ©
Ã  la rÃ©ponse de la requÃªte. Il nâ€™y a pas de difficultÃ©s Ã  gÃ©nÃ©raliser Ã  des requÃªtes rÃ©alisant une
sÃ©lection dÃ©finie par une condition sur des attributs quantitatifs ou qualitatifs.
Pour pouvoir rÃ©pondre aux requÃªtes dÃ©finies prÃ©cÃ©demment, nous maintenons deux ta-
bleaux en mÃ©moire centrale3 :
â€“ Le premier tableau TNew couvre la pÃ©riode [tâˆ’ n, t] (câ€™est lâ€™ensemble des Ã©lÃ©ments qui
satisfont la requÃªte de lâ€™utilisateur et qui sont inclus dans la mÃ©moire du SGFD). Ce
tableau est maintenu de faÃ§on standard par le SGFD.
â€“ Le second tableau THist couvrant la pÃ©riode [t âˆ’N, t âˆ’ n] contient les items qui satis-
font la requÃªte de lâ€™utilisateur et qui sont extraits Ã  partir du rÃ©sumÃ©. Le rÃ©sumÃ© Ã©laborÃ©
en utilisant lâ€™algorithme StreamSamp est conservÃ© sur disque dans une table nommÃ©e
"RÃ©sumÃ©".
A chaque rafraÃ®chissement de la fenÃªtre temporelle, le tableau TNew est mis Ã  jour de faÃ§on
standard par le SGFD. De mÃªme, le tableau THist doit Ãªtre lui aussi mis Ã  jour : les items ayant
un timestamp infÃ©rieur Ã  tâˆ’N sont supprimÃ©s et remplacÃ©s par les items extraits de la base et
qui appartiennent Ã  lâ€™intervalle [tâˆ’ nâˆ’Î”, tâˆ’ n].
3Nous supposons quâ€™on dispose de lâ€™espace nÃ©cessaire pour maintenir en mÃ©moire centrale ces deux tableaux
RNTI-E-19 - 250 -
Gabsi et al.
Temps de latence Vs DÃ©bit du flux. Pour que lâ€™approche dÃ©crite ci-dessus puisse fonction-
ner correctement, il faut sâ€™assurer quâ€™Ã  lâ€™instant t, tous les items qui ont un timestamp infÃ©rieur
Ã  (tâˆ’ n) ont dÃ©jÃ  Ã©tÃ© sauvegardÃ©s dans le rÃ©sumÃ©.
Soit Ï„ le dÃ©lai nÃ©cessaire pour traiter, Ã©crire et valider un item dans le rÃ©sumÃ©. Lâ€™item Ft
est disponible Ã  partir de lâ€™instant t+ Ï„ . Soit d le dÃ©bit dâ€™arrivÃ©e des items du flux. La fenÃªtre
temporelle de n items couvre une pÃ©riode de (n/d). Afin dâ€™assurer le bon fonctionnement de
lâ€™approche, il faut que la contrainte Ï„ â‰º (n/d) soit respectÃ©e. Cependant, dans la pratique, il
est difficile dâ€™agir sur le dÃ©bit du flux d ou sur le temps de latence Ï„ . La contrainte porte alors
sur n : il faut que n  d âˆ— Ï„ . Dans le cas oÃ¹ les items du flux arrivent avec un dÃ©bit variable,
cette contrainte doit Ãªtre appliquÃ©e sur un dÃ©bit maximum (dmax) du flux. Toutefois, si cette
condition ne peut pas Ãªtre satisfaite, nous pouvons envisager une technique dâ€™Ã©chantillonnage
sur la fenÃªtre glissante [t âˆ’ n, t]. Ainsi, la fenÃªtre de taille n ne contient plus les n items les
plus rÃ©cents du flux mais plutÃ´t un Ã©chantillon alÃ©atoire de taille n correspondant Ã  plus de n
items dans le flux (voir Babcock et al. (2002b) pour un tel algorithme).
5 Implantation de lâ€™approche proposÃ©e
Nous avons testÃ© la solution proposÃ©e sous le SGFD Esper. La technique de rÃ©sumÃ© utilisÃ©e
est StreamSamp ( Csernel et al. (2006)). Un travail antÃ©rieur( Gabsi et al. (2009)) a permit
dâ€™Ã©valuer les performances de cette approche de rÃ©sumÃ©.
Esper. Esper est un SGFD open source utilisÃ© au sein dâ€™une communautÃ© trÃ¨s active. Il
sâ€™agit dâ€™un ensemble de bibliothÃ¨ques Java permettant de dÃ©clarer un flux et son schÃ©ma ainsi
que de crÃ©er des requÃªtes continues en EPL4. Ces requÃªtes peuvent sâ€™appliquer sur trois types
de fenÃªtres : glissantes, sautantes ou partitionnÃ©es. Dans Esper, les items du flux sont appelÃ©s
des Ã©vÃ©nements. Une requÃªte EPL reÃ§oit en entrÃ©e les Ã©vÃ©nements du flux, et fournit en sortie
soit des Ã©vÃ©nements individuels, soit un lot de plusieurs Ã©vÃ©nements. A chaque Ã©vÃ©nement
(ou lot dâ€™Ã©vÃ©nements), le serveur Esper5 invoque une mÃ©thode appelÃ©e update. Les arguments
de cette mÃ©thode sont deux tableaux qui sont remplis Ã  la volÃ©e par le serveur Esper lors de
lâ€™exÃ©cution dâ€™une requÃªte. Le tableau oldEvents contient le(s) dernier(s) Ã©vÃ©nement(s) expirÃ©(s)
de la fenÃªtre alors que le tableau newEvents contient le(s) dernier(s) Ã©vÃ©nement(s) insÃ©rÃ©(s)
dans la fenÃªtre.
Implantation de lâ€™approche sous Esper. Lâ€™implantation de lâ€™approche sous Esper se tra-
duit par la dÃ©finition dâ€™un nouvel opÃ©rateur de fenÃªtrage. Cet opÃ©rateur reÃ§oit deux paramÃ¨tres
utilisateur : (1) N qui permet de spÃ©cifier la taille de la fenÃªtre sur laquelle va sâ€™appliquer la
requÃªte, (2)Î” qui permet de prÃ©ciser le taux de rafraÃ®chissement du rÃ©sultat. Dans le cas idÃ©al,
le nombre dâ€™items du flux n est fixÃ© par le systÃ¨me en fonction de sa charge, cependant, dans
lâ€™implantation proposÃ©, il sâ€™agit dâ€™un paramÃ¨tre supplÃ©mentaire fixÃ© lors de la dÃ©finition de la
fenÃªtre.
La mise Ã  jour des items de la fenÃªtre du prÃ©sent (n) est prise en charge par le SGFD Esper.
Cependant, pour les donnÃ©es du passÃ©, un tableau doit Ãªtre maintenu en mÃ©moire centrale, il
contient les items, ainsi que leurs poids, nÃ©cessaires Ã  lâ€™Ã©valuation de la requÃªte. Il sâ€™agit de
maintenir une fenÃªtre glissante sur les donnÃ©es de la base. A chaque invocation de la mÃ©thode
update, on supprime du tableau les items ayant expirÃ© de la fenÃªtre, et Ã  lâ€™aide dâ€™une requÃªte
4Event Processing Language : Langage dâ€™interrogation dans Esper
5La tÃ¢che du serveur Esper consiste Ã  compiler, enregistrer et exÃ©cuter les requÃªtes EPL.
RNTI-E-19- 251 -
Interrogation des rÃ©sumÃ©s de flux de donnÃ©es
SQL appliquÃ©e Ã  la base des rÃ©sumÃ©s, les nouveaux items sont extraits et insÃ©rÃ©s dans le ta-
bleau. AprÃ¨s la mise Ã  jour de ce tableau, lâ€™algorithme de la mÃ©thode update fait appel aux
fonctions de calcul dâ€™agrÃ©gats avec intervalle de confiance. Lâ€™algorithme ci-dessous illustre le
fonctionnement de la mÃ©thode update dans Esper.
Algorithm 1 update
Require: N : Taille de la fenÃªtre dâ€™intÃ©rÃªt, Agr : AgrÃ©gat de la requÃªte, Tableaux : THist,
TNew
n : Nombre dâ€™items dans la mÃ©moire du SGFD, Î” : Taux de rafraÃ®chissement de la fenÃªtre
Update(TNew) {Mise Ã  jour automatique par le SGFD}
iâ† 0
while i < THist.taille() & THist[i].Timestamp < tâˆ’N do
THist.Supprimer(i) {Supprimer lâ€™item dâ€™indice i du tableau THist}
iâ† i+ 1
end while
Req =SELECT * FROM RÃ©sumÃ© WHERE Timestamp BETWEEN tâˆ’ nâˆ’Î” AND tâˆ’ n
RÃ©sultatâ† ExÃ©cuter_requÃªte(Req)
THist.Ajouter(RÃ©sultat) {Insertion des nouveaux Ã©lÃ©ments dans le tableau}
RÃ©ponse = Fonction_AgrÃ©gat(Agr)
return RÃ©ponse
Esper ne fournit pas des fonctions dâ€™agrÃ©gats avec des intervalles de confiance, mais offre
la possibilitÃ© dâ€™implanter de nouvelles fonctions. Ainsi, des fonctions faisant intervenir la pon-
dÃ©ration des items et fournissant un intervalle de confiance de lâ€™agrÃ©gat sont Ã  dÃ©velopper.
La requÃªte "utilisateur" illustrÃ©e ci-dessous est appliquÃ©e sur le flux Flux_CONSO ayant la
structure suivante : Timestamp, id_Client, Consommation. Cette requÃªte permet de retourner
la consommation moyenne en Ã©lectricitÃ© sur une fenÃªtre de taille 107 items avec un taux de
rafraÃ®chissement de 102 items.
SELECT AVG(CONSOMMATION) FROM
Flux_CONSO . winHi s t : l e n g t h (107 ,102 )
Lâ€™Ã©valuation de cette requÃªte permet de retourner deux valeurs : la valeur de lâ€™estimateur de
la moyenne ainsi que son intervalle de confiance. Pour calculer lâ€™intervalle de confiance de
lâ€™agrÃ©gat, on fait appel Ã  la thÃ©orie des sondages. Lâ€™exemple ci-dessous illustre le calcul des
deux bornes de lâ€™intervalle de confiance de lâ€™agrÃ©gat moyenne Ã  partir dâ€™un Ã©chantillon de taille
m :
IC =
[
yÌ‚ âˆ’ 1.96 Sâˆš
m
; yÌ‚ + 1.96 Sâˆš
m
]
yÌ‚ =
mâˆ‘
i=1
viwi
mâˆ‘
i=1
wi
;S2 = 1
mâˆ’1
mâˆ‘
i=1
(vi âˆ’ vÌ‚)2
m : taille des tableaux THist et TNew concatÃ©nÃ©s, wi : poids dâ€™un item, vi : item
RNTI-E-19 - 252 -
Gabsi et al.
La solution proposÃ©e nâ€™est pas trÃ¨s coÃ»teuse Ã©tant donnÃ© quâ€™Ã  chaque mise Ã  jour effectuÃ©e
par le SGFD sur la fenÃªtre glissante, Î” Ã©lÃ©ments sont supprimÃ©es du tableau THist et sont
remplacÃ©s par les Î” items qui suivent et qui sont extraits de la base.
6 Conclusion et perspectives
La gÃ©nÃ©ration actuelle des SystÃ¨mes de gestion de Flux de donnÃ©es a Ã©tÃ© conÃ§ue et opti-
misÃ©e pour interroger le prÃ©sent dâ€™un flux et se rÃ©vÃ¨le inadaptÃ©e pour lâ€™interrogation du passÃ©.
Cependant, dans plusieurs applications telle que les applications dâ€™aide Ã  la dÃ©cision, il est nÃ©-
cessaire dâ€™interroger non seulement le prÃ©sent dâ€™un flux mais Ã©galement son passÃ©. Dans cet
article nous avons proposÃ© un nouvelle approche permettant de rÃ©pondre au besoin de telles ap-
plications. Une implantation de cette approche est proposÃ©e en utilisant Esper comme systÃ¨me
de gestion de flux de donnÃ©es et StreamSamp comme algorithme de rÃ©sumÃ©. Afin dâ€™Ã©valuer
les requÃªtes et de quantifier lâ€™imprÃ©cision liÃ©e Ã  lâ€™utilisation des rÃ©sumÃ©s, des fonctions dâ€™agrÃ©-
gats doivent Ãªtre implantÃ©es sous Esper. Une perspective de ce travail est dâ€™Ã©tudier le cas des
fenÃªtres physiques. Par ailleurs, des travaux sur lâ€™Ã©tude des performances de la technique pro-
posÃ©e sont en cours.
RÃ©fÃ©rences
Arasu, A., S. Babu, et J. Widom (2003). The cql continuous query language : Semantic foun-
dations and query execution. Technical report, VLDB Journal.
Babcock, B., S. Babu, M. Datar, R. Motwani, et J. Widom (2002a). Models and issues in data
stream systems. In ACM PODS, New York, NY, USA, pp. 1â€“16. ACM.
Babcock, B., M. Datar, et R. Motwani (2002b). Sampling from a moving window over strea-
ming data. In SODA, Philadelphia, pp. 633â€“634.
Chandrasekaran, S. et M. Franklin (2004). Remembrance of streams past : Overload-sensitive
management of archived streams. In VLDB, pp. 348â€“359. VLDB.
Csernel, B., F. ClÃ©rot, et G. HÃ©brail (2006). Streamsamp : Datastream clustering over tilted
windows through sampling. In ECML PKDD.
Gabsi, N., F. ClÃ©rot, et G. HÃ©brail (2009). RÃ©sumÃ© hybride de flux de donnÃ©es par Ã©chantillon-
nage et classification automatique. In EGC, pp. 229â€“240.
Vitter, J. S. (1985). Random sampling with a reservoir. ACM Trans. Math. Softw. 11(1), 37â€“57.
Summary
Data Stream Management Systems (DSMS) are designed to process large amounts of data.
Given that hardware resources cannot store all data, only the most recent part of the stream
is stored in the DSMSâ€™s buffer. Therefore, DSMS cannot handle queries that relate to past
periods. We propose in this paper, a new approach to evaluate queries that include both data
on old and recent periods. We present the definition of this approach and its implementation
using the Esper DSMS.
RNTI-E-19- 253 -

