Conception et optimisation d’un entrepoˆt de
donne´es me´dicales
Maria Trinidad Serna Encinas, Michel Adiba
LSR-IMAG Laboratory, BP 72 38402 Saint-Martin d’He`res, France
http ://www-lsr.imag.fr/Les.Groupes/STORM/Storm2002/Francais/index.html.
{Maria-Trinidad.Serna, Michel.Adiba}@imag.fr
Re´sume´. Un entrepoˆt de donne´es inte`gre des informations provenant
des sources de donne´es internes mais aussi externes a` l’entreprise. L’en-
semble des donne´es est utilise´ pour l’aide a` la de´cision, ainsi la concep-
tion du mode`le multidimensionnel et la se´lection des vues a` mate´rialiser
repre´sentent un processus complexe et de´licat. Dans cet article, nous pro-
posons la de´finition d’un mode`le multidimensionnel qui se compose de
trois classes : cube, dimension et hie´rarchie. Nous proposons e´galement un
algorithme pour la se´lection de l’ensemble optimal des vues a` mate´rialiser.
Notre algorithme utilise les parame`tres de fre´quence d’utilisation, de couˆt
de calcul et de fre´quence de mises a` jour des relations de base. Nous avons
eu l’opportunite´ de travailler dans le cadre d’un projet me´dical, ce qui
nous a permis de ve´rifier et de valider notre proposition sur des donne´es
re´elles.
1 Introduction
Les entrepoˆts de donne´es sont apparus au de´but des anne´es 1990 en re´ponse a` la
ne´cessite´ de rassembler toutes les informations de l’entreprise en une base de donne´es
unique destine´e aux analystes et aux gestionnaires [Doucet et Gangarski, 2001]. Un
processus de transformation et de nettoyage doit eˆtre applique´ aux donne´es avant leur
stockage dans l’entrepoˆt. L’ensemble des donne´es, y compris leur historique, est utilise´
pour l’aide a` la de´cision [Kimball, 1996, Kimball et Ross, 2003].
La conception et la mise en oeuvre d’un entrepoˆt de donne´es est une taˆche com-
plexe et de´licate. Elle se compose de divers processus commune´ment appele´s extraction-
inte´gration, organisation et interrogation. Pour l’extraction, nous devons analyser l’en-
semble des sources de donne´es internes et externes. Cette analyse sert aussi bien a` la
se´lection de l’ensemble de donne´es a` stocker dans l’entrepoˆt, qu’a` la se´lection des outils
requis pour l’extraction et la transformation de ces donne´es avant leur stockage. Le
deuxie`me processus consiste a` organiser ces donne´es a` l’inte´rieur de l’entrepoˆt. Pour
ce faire, nous devons concevoir le mode`le multidimensionnel a` utiliser ainsi que de´finir
l’ensemble optimal de vues a` mate´rialiser. Finalement, le dernier processus consiste a`
de´terminer les outils ne´cessaires pour la visualisation de l’ensemble des donne´es.
Nous avons participe´ au projet ADELEM (Aide a` la DEcision Logistique Et Me´di-
cale). Ce projet nous a permis de valider notre proposition. Ainsi, dans ce travail, nous
pre´sentons une expe´rimentation sur les donne´es me´dicales du projet.
- 122 -RNTI-B-1
Mode´lisation multidimensionnelle et se´lection des vues a` mate´rialiser
Cet article se focalise sur le processus d’organisation. D’abord, la section 2 de´crit
le projet ADELEM et les sources de donne´es. La section 3 pre´sente la de´finition d’un
mode`le multidimensionnel. La section 4 montre la mate´rialisation de l’hypercube et un
algorithme propose´ pour la se´lection de l’ensemble optimal de vues a` mate´rialiser. Dans
la section 5, nous analysons les travaux existants et finalement, la section 6 pre´sente
nos conclusions.
Ce travail est re´alise´ dans l’e´quipe NODS (Networked Open Database Services)
http ://www-lsr.imag.fr/Les.Groupes/STORM/Storm2002/Francais/index.html.
2 Le projet ADELEM
Ce projet consiste en la mise au point d’outils logiciels ne´cessaires a` l’aide a` la
de´cision logistique et me´dicale, dans le cadre des SROS (Sche´mas d’Organisation Sani-
taire et Sociale) ge´re´s par les ARH (Agences Re´gionales de l’Hospitalisation). Dans le
syste`me de soins d’une re´gion, ces agences sont charge´es de re´partir de manie`re opti-
male les moyens me´dicaux (l’”offre”) en fonction des besoins sanitaires (la ”demande”).
A partir des observations de sante´ constituant l’information primaire, essentiellement
contenues dans les donne´es PMSI (Programme de Me´dicalisation du Syste`me d’Infor-
mation des hoˆpitaux), il est ne´cessaire de mettre au point des outils logiciels d’analyse
et de visualisation.
Ce projet a e´te´ aborde´ par une e´quipe interdisciplinaire : le personnel me´dical
(Laboratoire TIMC IMAG, UMR CNRS 5525), le Laboratoire de Biome´trie et Biologie
e´volutive, UMR CNRS 5558, qui fournit l’analyse statistique des donne´es me´dicales
et l’Organisation Mondiale de la Sante´ (base´e en Suisse) qui a de´veloppe´ le logiciel
HealthMapper pour la cre´ation et la manipulation des donne´es ge´ographiques. Notre
e´quipe (Laboratoire LSR IMAG, UMR CNRS 5526) fournit le support sur les bases de
donne´es et les entrepoˆts.
Dans le cadre du projet ADELEM, nous nous proposons d’adapter notre savoir-
faire au proble`me de la gestion de donne´es me´dicales qui constituent un cadre ap-
plicatif particulie`rement inte´ressant. En effet, ces donne´es se trouvent re´parties dans
plusieurs sources qu’il faut, dans un premier temps, fe´de´rer pour constituer un en-
trepoˆt de donne´es pertinentes pour l’application vise´e. Cette e´tape est importante car
elle doit non seulement identifier les sources, mais aussi de´terminer comment extraire
de ces sources les donne´es de´sire´es. Nous devons de´terminer si les donne´es doivent
eˆtre extraites telles quelles ou bien s’il faut les traiter au pre´alable en leur appliquant
des fonctions spe´cifiques comme des agre´gats, des sommes, ... En plus, nous devons
e´tablir un me´canisme pour la gestion de l’e´volution. Dans ce cas, il faut de´terminer
l’adaptation au niveau : de l’application d’extraction, des agre´gats et de l’application
d’analyse.
Cette proble´matique est ge´ne´rale a` la constitution de tout entrepoˆt mais nous devons
ici tenir compte de la nature particulie`re des donne´es sur lesquelles portent l’e´tude :
type, format, se´mantique, confidentialite´, degre´ de fiabilite´ et de confiance, informa-
tions manquantes ou incomple`tes, ... En re´sume´, il s’agit de constituer un entrepoˆt qui
contient des donne´es pertinentes et de qualite´ sur lesquelles sera base´ l’outil d’interro-
gation et le processus d’aide a` la de´cision.
RNTI - E -
- 123 - RNTI-B-1
Serna et al.
Les sources du projet ADELEM sont distribue´es et he´te´roge`nes, elles contiennent
les donne´es publiques concernant la sante´ (RSA ”Re´sume´s de Sortie Anonymes”, RHA
”Re´sume´s Hebdomadaire Anonymes”, CIM10 ”Classification International des Mala-
dies Version 10” et FINESS ”Fichier National des E´tablissements Sanitaires et So-
ciaux”) et les donne´es de´mographiques (RP99 ”Recensement Population”) [Belot, 2002].
Ces dernie`res proviennent de l’Institut National de la Statistique et des Etudes Econo-
miques. Le tableau 1 de´crit les diffe´rentes proprie´te´s des sources.
Source Proprie´taire Type de fichier Mode Taille Anne´e Mise a`
d’obtention jour
RSA ARH Texte (ASCII fixe) Gratuit 11 Go 2000 Annuelle
ou Access
RHA ARH Texte (ASCII fixe) Gratuit 3 Go 2000 Annuelle
ou Access
FINESS MCASS Texte (ASCII fixe) Gratuit 2.24 Mo 2000 Annuelle
ou Access
CIM10 OMS Excel - 1.34 Mo 1995 -
RP90/99 INSEE DBF Achat (625,04) 50.8 Mo 1999 Tous les
9 ans
Tab. 1 – Description des sources de donne´es
Le tableau pre´ce´dent indique des caracte´ristiques essentielles a` prendre en compte
lors des premie`res phases de la conception d’un entrepoˆt. Ne´anmoins, si nous reprenons
les deux dernie`res proprie´te´s, l’anne´e et la mise a` jour, pour les repre´senter dans le
tableau 2 qui aura des donne´es sur 10 ans, nous avons les caracte´ristiques des donne´es
historise´es.
Source Taille Optimisation Rafraˆıchisse- Requeˆtes Agre´gats Evolution
du stockage ment complexes du sche´ma
RSA 110 Go Oui Annuel Oui Oui Oui
RHA 30 Go Oui Annuel Oui Oui Oui
FINESS 22.4 Mo Non Annuel Non Non Oui
CIM10 13.4 Mo Non - Non Non Oui
RP90/99 508 Mo Oui Annuel Non Oui Oui
Tab. 2 – Caracte´ristiques des sources de donne´es historiques
L’analyse du tableau pre´ce´dent, nous permet de remarquer les sources RSA et RHA.
Leurs tailles nous obligent a` rechercher des me´canismes d’optimisation pour le stockage
(partitionnement, paralle´lisme, agre´gats) et pour traiter des requeˆtes complexes. Nous
proposons un algorithme pour la selection de l’ensemble optimal des vues a` mate´rialiser
en conside´rant leur couˆt de calcul et leur couˆt de stockage.
Une autre partie a` ge´rer est l’e´volution du sche´ma, pour prendre en compte des chan-
gements dans la structure logique de la source et qui peuvent avoir des re´percussions sur
la structure logique de notre entrepoˆt, voire l’affecter. Ceci nous oblige a` proposer une
conception adaptable de l’entrepoˆt de donne´es pour mieux inte´grer ces changements a`
notre sche´ma.
Par rapport a` la gestion des aspects temporels de l’entrepoˆt de donne´es, nous pou-
vons utiliser l’e´volution de sche´mas ou les versions de sche´mas. Nous devons choisir la
RNTI - E -
- 124 -RNTI-B-1
Mode´lisation multidimensionnelle et se´lection des vues a` mate´rialiser
technique a` utiliser par rapport aux caracte´ristiques de l’application cible.
3 Conception d’un mode`le multidimensionnel
Nous avons dit pre´ce´demment que la conception d’un mode`le est une taˆche complexe
et de´licate. Ainsi, nous conside´rons essentiel d’avoir un fondement formel qui nous
permet d’aboutir a` la conception d’un sche´ma multidimensionnel. Notre proposition
repose sur la de´finition formelle d’un mode`le multidimensionnel. Pour celui-ci, nous
de´finissons une base de donne´es multidimensionnelle, un cube, une dimension et une
hie´rarchie. Ceci nous a permis d’aboutir a` la conception d’un sche´ma en constellation
pour le projet ADELEM.
3.1 De´finition d’un mode`le multidimensionnel
Nous sommes partis de travaux existants [Benitez, 2002, Hurtado et al., 1999a,
Hurtado et al., 1999b, Li et Wang, 1996, Quix, 1999] pour la de´finition d’un sche´ma
et d’une instance. La plupart des travaux proposent un ensemble d’ope´rateurs pour
l’e´volution d’un syste`me multidimensionnel. Dans [Grandi et Mandreoli, 2002], l’au-
teur propose un mode`le formel des versions de sche´mas temporelles pour des bases de
donne´es a` objets.
Nous faisons la diffe´rence entre une dimension et une hie´rarchie. Ainsi, notre mode`le
se compose de quatre e´le´ments essentiels : une base multidimensionnelle, un cube, une
dimension et une hie´rarchie. Nous donnons pour chacun la de´finition de sche´ma et
d’instance. Nous supposons l’existence de :
DOM = dom(char)
⋃
dom(integer)
⋃
dom(float)
⋃
dom(decimal)
⋃
dom(date)
⋃ {t}
contenant le domaine de chaque type atomique plus la valeur distingue´e t.
C = Ensemble de noms de cubes.
D = Ensemble de noms de dimensions.
H = Ensemble de noms de hie´rarchies.
M = Ensemble de noms de mesures.
P = Ensemble de noms de proprie´te´s.
L = Ensemble de noms de niveaux.
R = Ensemble de contraintes.
Nous associons a` chaque cube c∈C un ensemble de valeurs {a1, ..., an} tel que
∀i=1,...nai ∈ DOM. De meˆme pour chaque dimension d∈D, nous associons un ensemble
de valeurs {b1, ..., bn} tel que ∀i=1,...nbi∈DOM. Finalement, pour chaque niveau l∈L,
nous associons un ensemble de valeurs {f1, ..., fn} tel que ∀i=1,...nfi∈DOM.
Nous supposons l’existence des fonctions suivantes :
measuredom : M −→ E(DOM)1, qui retourne l’ensemble des valeurs associe´es a` une
mesure.
propertydom : P −→ E(DOM), qui retourne l’ensemble des valeurs associe´es a` une
proprie´te´.
levelset : H −→ E(DOM), qui retourne l’ensemble des membres associe´s a` un niveau.
1L’ensemble E(A) est l’ensemble des parties de A. E(A) = {X|X ⊂ A}.
RNTI - E -
- 125 - RNTI-B-1
Serna et al.
De´finition 3.1 : Sche´ma de base de donne´es et d’instance multidimension-
nelle.
Le sche´ma d’une base de donne´es multidimensionnelle est un n-uplet SM = (Cs,
Ds, Hs, R), ou` Cs est un ensemble de sche´mas de cubes, Ds est un ensemble de sche´mas
de dimensions, Hs est un ensemble de sche´mas de hie´rarchies et R est un ensemble de
contraintes.
L’instance d’une base multidimensionnelle est un n-uplet IM = (Ci, Di, Hi, Ri), ou`
Ci est un ensemble d’instances de cubes tel que pour chaque instance ci∈Ci, il existe un
sche´ma cs∈Cs avec ci conforme a` cs. Di est un ensemble d’instances de dimensions tel
que pour chaque instance di∈Di, il existe un sche´ma ds∈Ds avec di conforme a` ds. Hi
est un ensemble d’instances de hie´rarchies tel que pour chaque instance hi∈Hi, il existe
un sche´ma hs∈Hs avec hi conforme a` hs. Finalement, Ri est un ensemble d’instances
de contraintes tel que chaque instance ri∈Ri.
De´finition 3.2 : Sche´ma et instance du cube.
Un sche´ma de cube est un n-uplet Cs = (cn, M, D), ou` cn∈C est le nom du cube,
M est un ensemble de mesures et D est un ensemble de dimensions.
Une instance de cube est un ensemble de cellules. Une cellule est un n-uplet Ic =
(cn, {v1,...,vk}, {d}), ou` cn est le nom du cube, {v1,...,vk} est l’ensemble de mesures
tel que ∀i=1,...nvi ∈ measuredom(mi) avec mi∈M et d∈D est l’ensemble de dimensions.
Par exemple, la figure 1 repre´sente le sche´ma et l’instance du cube Ventes.
SUM
03/01/2000
02/01/2000
01/01/2000
SUM
Annecy
Grenoble
Lyon
TV R CS CP
S
U
M
All
Temps
Magasin
Produit
Schéma du cube Ventes
Quantité
Instance
Temps
Magasin
Produit
Fig. 1 – Sche´ma et une possible instance du Cube
La partie gauche de la figure 1 montre le sche´ma du cube de nom Ventes. L’ensemble
{Temps, Magasin, Produit} sont les axes du cube et la mesure est Quantite´. La partie
droite montre une instance de ce cube. Par exemple, nous avons 100 Te´le´viseurs vendus
dans le magasin d’Annecy le 1er janvier 2000.
De´finition 3.3 : Sche´ma et instance de dimension.
Un sche´ma de dimension est un n-uplet Ds = (dn, P, H), ou` dn∈D est le nom de
la dimension, P est l’ensemble de proprie´te´s de la dimension dn et H est l’ensemble de
hie´rarchies.
RNTI - E -
- 126 -RNTI-B-1
Mode´lisation multidimensionnelle et se´lection des vues a` mate´rialiser
Une instance de dimension est un n-uplet Id = (dn, {(v1,...,vi)}, {h}), ou` dn∈D est
le nom de la dimension, (v1,...,vi) est un ensemble de proprie´te´s tel que ∀j=1,...nvj ∈
propertydom(pj) avec pj∈P. Enfin, h∈H est l’ensemble de hie´rarchies qui appartiennent
a` dn.
Par exemple, le sche´ma de la dimension Magasin est de´fini de la manie`re suivante :
dn = Magasin
{p1,...pi} = {Cle Magasin, Libelle Magasin }
hn = H Geo (cf. De´finition 3.4)
Sche´ma et instance de hie´rarchie.
Pour nous un sche´ma et une instance de hie´rarchie peuvent prendre la forme d’un
graphe se´quentiel ou d’un graphe acyclique dirige´ repre´sentant les hie´rarchies de ni-
veaux. Chaque noeud du graphe contient un niveau et un arc entre deux noeuds
repre´sente une association entre les niveaux. Nous supposons l’existence de deux noeuds,
nomme´s base et sommet, a` partir desquels tous les autres noeuds peuvent eˆtre atteints
directement ou par transitivite´. Le noeud sommet contient le niveau > de la hie´rarchie.
La figure 2 pre´sente un exemple de graphe se´quentiel. Comme exemple de graphe acy-
clique dirige´, nous pouvons conside´rer le sche´ma de hie´rarchie suivant : H Temps =
({(Jour, Mois), (Mois, Semestre), (Semestre, Annee)}, {(Jour, Semaine), (Semaine,
Annee)}), ou` la base=Jour et le Sommet=Annee. Dans notre mode`le, nous conside´rons
les caracte´ristiques suivantes :
1. Nous distinguons les termes de dimension et de hie´rarchie. Ainsi, une dimension
peut relier 0, une ou plusieurs hie´rarchies. Pour une hie´rarchie donne´e, il y a une
liaison directe avec la dimension associe´e dans le cube. Par exemple, si le cube
Ventes comporte la dimension Magasin relie´e a` une commune, ce cube sera alors
indirectement lie´ aux niveaux supe´rieurs a` commune (De´partement, Re´gion, >).
Ainsi, il sera possible d’effectuer des agre´gats sur ces niveaux supe´rieurs.
2. Nous pouvons inse´rer un niveau de hie´rarchie soit a` coˆte´ de la hie´rarchie de´ja`
de´finie soit a` l’inte´rieur. Pour faire cela, nous avons besoin de spe´cifier trois ni-
veaux, le premier est le niveau a` inse´rer, les deux derniers repre´sentent les niveaux
infe´rieur et supe´rieur a` partir desquels le nouveau niveau sera place´.
3. Dans la de´finition du sche´ma de hie´rarchie, nous conside´rons le cas ou` l=>, c’est
a` dire quand nous avons seulement les niveaux base et sommet.
Nous donnons dans la suite la de´finition de sche´ma et d’instance de hie´rarchie.
De´finition 3.4 : Sche´ma et instance de hie´rarchie.
Un sche´ma de hie´rarchie est un n-uplet Hs = (hn, L, ≺), ou` hn∈H est le nom de
la hie´rarchie, L est l’ensemble de niveaux a` l’inte´rieur de la hie´rarchie hn et le symbole
≺ est une relation de de´pendance entre les niveaux telle que sa fermeture transitive et
re´flexive ¹* repre´sente un ordre partiel dans L. Il existe un seul niveau l⊥ tel que (i)
si l 6=>, ∀l∈L l⊥ ¹* l ∧ ∀l∈L l ¹* > et (ii) si l=>, l⊥ ¹* >. Un niveau lj∈L est un
niveau imme´diatement supe´rieur (relation de de´pendance) de li∈L si li ≺ lj .
Une instance de hie´rarchie organise les proprie´te´s participant aux hie´rarchies d’agre´-
gation. Pour chaque arc dans un sche´ma de dimension, il existe une fonction de rollup
associe´e.
RNTI - E -
- 127 - RNTI-B-1
Serna et al.
Une instance de hie´rarchie est un n-uplet Ih = (
⋃
li∈L levelset(li), RUP), ou` RUP
est un ensemble de fonctions rupljli tel que (i) ∀(l1, l2) ∈ L tels que l1 ≺ l2, il existe une
fonction rupl2l1 : levelset(l1) −→ levelset(l2) et (ii) ∀(l1, l2, l3) ∈ L tels que l1 ≺ l2 et l2
≺ l3, ran(rupl2l1) ⊆ dom(rupl3l2).
Par exemple, dans la figure 2, la partie gauche pre´sente le sche´ma de la hie´rarchie
H Geo. Il est de´fini de la manie`re suivante : hn est le nom de la hie´rarchie H Geo, l’en-
semble de proprie´te´s (niveaux) a` l’inte´rieur de la hie´rarchie est {Commune, De´partement,
Re´gion,>} et la relation≺ est repre´sente´e par {(Commune, De´partement), (De´partement,
Re´gion), (Re´gion, >)}.
Commune
Departement
Region
T
Lyon Grenoble Annecy
Isère . . .
Rhône Alpes . . .
t
Schéma Instance
Fig. 2 – Sche´ma et une instance possible de la hie´rarchie H Geo
La partie droite de la figure 2 montre une instance possible de ce sche´ma. La fonc-
tion rupDepartementCommune met en relation les proprie´te´s Lyon, Grenoble et Annecy du niveau
Commune avec la proprie´te´ Ise`re du niveau Departement. Les proprie´te´s du niveau Region
sont mises en relation avec la proprie´te´ unique t du niveau >.
3.2 Sche´ma en constellation pour ADELEM
La figure 3 montre le sche´ma en constellation avec trois relations de faits et leurs di-
mensions. La relation de faits Prise MCO (Me´decine-Chirurgie-Obstretique) a e´te´ conc¸ue
pour la gestion des se´jours hospitaliers effectue´s dans la partie court se´jour d’un
e´tablissement. La relation de faits Population manipule des informations de´mogra-
RNTI - E -
- 128 -RNTI-B-1
Mode´lisation multidimensionnelle et se´lection des vues a` mate´rialiser
phiques. La troisie`me Prise SSR (Soins de Suite et de Re´adaptation) a` diffe´rence de
Prise MCO enregistre des donne´es correspondantes a` des longs se´jours.
Cle_Semfin
Semaine_fin
Cle_Semdebut
Semaine_debut
Cle_Finess
Cle_Maladie
Cle_Mode
Cle_Temps
Cle_Age
Cle_Zone
Cle_Semdebut
Cle_Semfin
CompteJoursenwk
Comptejourshorswk
Prise_SSR
Cle_Finess
Raison_Sociale
Adresse
Codepostal
CA1
CM01
CA2
CM02
CA3
CM03
CA4
CM04
CA05
CM05
CA06
CM06
. . .
Etablissement
Cle_Poids
Libelle_poids
Poids_naissance
CIM10
Cle_Maladie
Libelle_maladie
Cle_Mode
Libelle_mode
Mode_sortie
Cle_Temps
Mois
Saison
Annee
Temps
Cle_Age
Age
Cle_Zone
Libelle_commune
Departement
Region
Pays
Zone_geo
Cle_Maladie
Cle_Finess
Cle_Mode
Cle_Temps
Cle_Age
Cle_Poids
Cle_Zone
CompteDuree_sejour
SommeDuree_sejour
Prise_MCO
Cle_Depcom
Intcom
POPF00
POPF01
POPF02
POPF03
. . .
RP99
Cle_Depcom
CompteFem_proc
Population
Fig. 3 – Sche´ma en Constellation pour ADELEM
Dans la suite, nous de´crivons la premie`re relation de faits Prise MCO du sche´ma en
constellation conc¸u :
Le sche´ma d’une base de donne´es multidimensionnelle est un n-uplet SM = (Cs,
Ds, Hs, R), ou`
Cs = {Prise MCO, Population, Prise SSR}
Ds = {Etablissement, CIM10, Mode sortie, Temps, Age, Zone geo, Poids naissance,
RP99, Semaine debut, Semaine fin}
Hs = {H Geo, H Temps}
R = {C Cube, D Dimension}
Le sche´ma d’un cube est un n-uplet Cs = (cn, M, D), ou`
cn = Prise MCO
M = {CompteDuree sejour, SommeDuree sejour}
D = {Etablissement, CIM10, Mode sortie, Temps, Age, Zone geo, Poids naissance}
Le sche´ma d’une dimension est un n-uplet Ds = (dn, P, H), ou`
dn = Etablissement
P = {Cle Finess, Raison Sociale, Adresse, Codepostal, CA1 .. CA7, CMO1 .. CMO7,
Commune, Departement, Region, Pays}
H = {H Geo}
Le sche´ma d’une hie´rarchie est un n-uplet Hs = (hn, L, ≺), ou`
hn = H Geo
L = {Commune, Departement, Region, Pays}
≺ = {(Commune, Departement), (Departement, Region), (Region, Pays)}
RNTI - E -
- 129 - RNTI-B-1
Serna et al.
4 Vues mate´rialise´es
Pour notre cas expe´rimental, nous avons repris l’e´toile Prise MCO et seulement les
dimensions : Etablissement, CIM10, Temps, Mode sortie. En utilisant ce sche´ma nous
avons construit un entrepoˆt comportant un e´chantillon de 10% des donne´es re´elles. Nous
avons utilise´ le syste`me de´cisionnel d’Oracle9i Entreprise Edition Release 9.2.0.1.0 pour
la cre´ation du sche´ma et pour la ge´ne´ration des vues mate´rialise´es. Ceci nous a permis
de connaˆıtre le couˆt de stockage (repre´sente´ par le nombre de n-uplets du re´sultat)
de chaque vue et de pouvoir facilement de´terminer leur couˆt de calcul (produit des
cardinalite´s approximatives des relations de base).
4.1 Mate´rialisation de l’Hypercube
Dans les syste`mes de´cisionnels, les utilisateurs sont inte´resse´s par des requeˆtes du
type : ”le nombre de se´jours de l’hoˆpital E1 par la maladie C1”. Dans ce cas, la cellule
(E1, C1, ALL2, ALL, m1), contient la valeur de : ”le nombre de se´jours de l’hoˆpital E1
pour la maladie C1 pour tous les mois (ALL) et pour tous les modes de sortie (ALL)”.
Nous pouvons calculer la valeur de la cellule (E1, C1, ALL, ALL, m1) comme
la somme des valeurs des cellules de (E1, C1, T1, M1, m1), ..., (E1, C1, TNtemps,
MNmode, m1), ou` TNtemps et MNmode repre´sentent respectivement l’ensemble des mois
et l’ensemble des modes de sortie. Toutes les cellules contenant la valeur ALL dans un de
ses axes sont des cellules de´pendantes. Ainsi, pour la se´lection des vues a` mate´rialiser,
le proble`me se re´duit a` de´terminer l’ensemble des cellules de´pendantes a` mate´rialiser.
Etant donne´ que le couˆt de stockage3 pour une mate´rialisation de toutes les vues est
de 206781 n-uplets (
∑
i=1,...,nCS(vi), ou` CS(vi) est le couˆt de stockage des vues du
tableau 3), nous avons un pourcentage de 74% ((206781-53799)*100/206781) de cellules
de´pendantes pour le sche´ma Prise MCO construit.
Dans la suite, nous de´finissons l’ensemble des vues possibles a` mate´rialiser. Le ta-
bleau 3 contient les 15 vues pour une mate´rialisation comple`te ainsi que leur couˆt de
stockage et de calcul. La figure 4 repre´sente l’hypercube sur 4 dimensions du sche´ma
Prise MCO, nous utilisons la notation : M pour million et K pour mille.
La figure 4 repre´sente le treillis pour l’hypercube et elle contient le couˆt de stockage
a` droite de chaque noeud (vue) et le couˆt de calcul a` gauche.
Relations de de´pendance a` l’inte´rieur de l’hypercube : Par exemple, V6 ¹ V2
si et seulement si V6 peut eˆtre re´pondu par V2, donc V6 est de´pendante de V2.
V2 : V6 ¹ V2, V7 ¹ V2, V9 ¹ V2, V12 ¹ V2, V13 ¹ V2, V14 ¹ V2, V16 ¹ V2
V3 : V6 ¹ V3, V8 ¹ V3, V10 ¹ V3, V12 ¹ V3, V13 ¹ V3, V15 ¹ V3, V16 ¹ V3
V4 : V7 ¹ V4, V8 ¹ V4, V11 ¹ V4, V12 ¹ V4, V14 ¹ V4, V15 ¹ V4, V16 ¹ V4
V5 : V9 ¹ V5, V10 ¹ V5, V11 ¹ V5, V13 ¹ V5, V12 ¹ V5, V15 ¹ V5, V16 ¹ V5
V6 : V12 ¹ V6, V13 ¹ V6, V16 ¹ v6
V7 : V12 ¹ V7, V14 ¹ V7, V16 ¹ V7
V8 : V12 ¹ V8, V15 ¹ V8, V16 ¹ V8
V9 : V13 ¹ V9, V14 ¹ V9, V16 ¹ V9
2Nous utilisons la recommandation d’ajouter la valeur ALL au domaine de la dimension T et M,
pre´sente´e dans [Gray et al., 1995]
3Le couˆt de stockage d’une requeˆte est le nombre de n-uplets du re´sultat.
RNTI - E -
- 130 -RNTI-B-1
Mode´lisation multidimensionnelle et se´lection des vues a` mate´rialiser
Vue Relations C. de Stockage C. de Calcul
V1 Prise MCO+Etablissement+CIM10+Temps+Mode sortie 53799 n-uplets 90M
V2 Prise MCO+Etablissement+CIM10+Temps 47133 90M
V3 Prise MCO+Etablissement+CIM10+Mode sortie 18456 90M
V4 Prise MCO+Etablissement+Temps+Mode sortie 603 61K
V5 Prise MCO+CIM10+Temps+Mode sortie 32918 346K
V6 Prise MCO+Etablissement+CIM10 13973 90M
V7 Prise MCO+Etablissement+Temps 184 60K
V8 Prise MCO+Etablissement+Mode sortie 58 25K
V9 Prise MCO+CIM10+Temps 26058 216K
V10 Prise MCO+CIM10+Mode sortie 8186 90K
V11 Prise MCO+Temps+Mode sortie 48 60
V12 Prise MCO+Etablissement 19 5K
V13 Prise MCO+CIM10 5329 18K
V14 Prise MCO+Temps 12 12
V15 Prise MCO+Mode sortie 4 5
Tab. 3 – Mate´rialisation comple`te de l’hypercube
4 Dim
3 Dim
2 Dim
1 Dim
0 Dim
ECTM
  V1
ECT
 V2
ECM
  V3
ETM
  V4
CTM
  V5
Etab
 V12
EC
V6
ET
V7
EM
V8
CT
V9
CM
V10
TM
V11
Cim10
V13
Temps
  V14
Mode
 V15
ALL
V16
90M 54K
90M 47K 90M 18K 61K 603 346K 33K
90M 14K 60K 184 25K 58 216K 26K 90K 8K 60 48
5K 19 18K 5K 12 12 5 4
1
Matérialisation Complète:      361M (n-uplets)
Pas de Matérialisation:            90M (n-uplets)
Coût de calcul
Fig. 4 – Hypercube avec le couˆt de calcul (a` gauche) et le couˆt de stockage (a` droite)
de chaque noeud (vue)
RNTI - E -
- 131 - RNTI-B-1
Serna et al.
V10 : V13 ¹ V10, V15 ¹ V10, V16 ¹ V10
V11 : V14 ¹ V11, V15 ¹ V11, V16 ¹ V11
V12 : V16 ¹ V12
V14 : V16 ¹ V14
V15 : V16 ¹ V15
4.2 Se´lection des vues a` mate´rialiser
Dans la suite, nous formalisons la se´lection des vues a` mate´rialiser en utilisant
l’algorithme Greedy [Harinarayan et al., 1995].
Quelques notations :
n = Nombre de choix.
C(v) = Couˆt de stockage de la vue v (repre´sente´ par le nombre de n-uplets du re´sultat).
¹ = Relation de de´pendance. Par exemple, Q2 ¹ Q1 si et seulement si Q2 peut eˆtre
re´pondu par Q1.
S = Ensemble de vues se´lectionne´es,
B(v, S) = Be´ne´fice de la vue v relative a` S,
1) Pour chaque w ¹ v, de´finir la quantite´ Bw par :
a) Si u est la vue de couˆt infe´rieur dans S, tel que w ¹ u. Nous remarquons que
l’ensemble S contient au moins la vue V1 (top view), et
b) Si C(v) < C(u), alors Bw = C(v) - C(u). Sinon Bw = 0.
2) De´finir B(v, S) =
∑
w¹v Bw.
La figure 5 de´crit l’algorithme Greedy pour une se´lection de n vues a` mate´rialiser.
S = {top view};
for i = 1 to n do begin
      select that view v not in S such that
             B(v, S) is maximized;
      S = S union {v};
end;
resulting S in the greedy selection;
Fig. 5 – Algorithme Greedy [Harinarayan et al., 1995]
Nous utilisons l’hypercube de la fig 4 pour l’application de l’algorithme. La table
4 de´crit cette application avec n e´gal a` 7, pour de´terminer l’ensemble de vues a`
mate´rialiser.
Pour le premier choix la valeur de u est e´gal a` 54K (le couˆt de V1, car elle repre´sente
la vue avec le couˆt de stockage minimum dans l’ensemble S), pour le reste elle est
repre´sente´e par 603 (V4), car elle est toujours, au moins jusqu’a` la 7e`me ite´ration,
la vue d’un couˆt de stockage minimale a` l’inte´rieur de S. Dans la premie`re ite´ration,
le choix est la vue V4, car elle repre´sente le be´ne´fice le plus e´leve´ (53K*8=424K), le
be´ne´fice est calcule´ de la manie`re suivante : couˆt(V4) - couˆt(V1) = 53K multiplie´ par
8, le nombre de vues de´pendantes de V4 (V4, V7, V8, V11, V12, V14, V15 et V16).
Le second choix est la vue V3 avec 144K (36K*4 (V3, V6, V10 et V13)), les autres
vues de´pendantes de V3 ne sont pas prises en compte, car elles tiennent un be´ne´fice plus
RNTI - E -
- 132 -RNTI-B-1
Mode´lisation multidimensionnelle et se´lection des vues a` mate´rialiser
Vue 1e`re Choix 2e`me 3e`me 4e`me 5e`me 6e`me 7e`me
V2 7K*8=56K 7K*4=28K 7K*2=14K 7K*1=7K 7K 7K -
V3 36K*8=288K 36K*4=144K - - - - -
V4 53K*8=424K - - - - - -
V5 21K*8=168K 21K*4=84K 21K*2=42K - - - -
V6 40K*4=160K 40K*2=80K 4K*2=8K 4K*2=8K 4K 4K 4K
V7 54K*4=216K 419*4=2K 419*4=2K 419*4=2K 2K 2K 2K
V8 54K*4=216K 545*4=2K 545*4=2K 545*4=2K 2K 2K 2K
V9 28K*4=112K 28K*2=56K 28K*1=28K 7K*1=7K 7K - -
V10 46K*4=184K 46K*2=92K 10K*2=20K 10K*2=20K - - -
V11 54K*4=216K 555*4=2K 555*4=2K 555*4=2K 2K 2K 2K
V12 54K*2=108K 584*2=1K 584*2=1K 584*2=1K 1K 1K 1K
V13 49K*2=98K 49K*1=49K 13K*1=13K 13K*1=13K 3K 3K 3K
V14 54K*2=108K 591*2=1K 591*2=1K 591*2=1K 1K 1K 1K
V15 54K*2=108K 599*2=1K 599*2=1K 599*2=1K 1K 1K 1K
V16 54K*1=54K 1K 1K 1K 1K 1K 1K
{V1} S+=V4 S+=V3 S+=V5 S+=V10 S+=V9 S+=V2 S+=V6
Tab. 4 – Application de l’algorithme Greedy aux donne´es ADELEM
e´leve´ avec la vue V4. Finalement, la dernie`re ligne contient le re´sultat, elle repre´sente
l’ensemble S={V1, V4, V3, V5, V10, V9, V2, V6}.
Dans la figure 6, nous avons dessine´ un graphique qui montre l’application de l’al-
gorithme Greedy par rapport aux couˆts de calcul et de stockage. Nous conside´rons
seulement les 7 premiers re´sultats, meˆme si a` partir de la 6e`me ite´ration, nous n’avons
aucun avantage pour la mate´rialisation. Par exemple, la vue V2, re´sultat de la 6e`me
ite´ration, a pour couˆt de stockage 47K et un couˆt de calcul de 90M. Si nous faisons
la comparaison de ces re´sultats, par rapport a` la vue V1, que nous sommes cense´s
mate´rialiser, nous nous apercevons que le be´ne´fice est presque minimum, mais que les
couˆts de leur mate´rialisation sont double´s.
1 2 3 4 16. . .5 6
Coût de calcul
Coût de stockage
Nombre de vues matérialisées
0
100k
300k
.
.
.
90M
200k
Nombre
    de
  tuples
7
V2 V3 V6
V5
V9
V10
V4
Fig. 6 – Ensemble ordonne´ des vues se´lectionne´es
Le graphique de la figure 6 contient les couˆts de calcul et de stockage dans l’axe
RNTI - E -
- 133 - RNTI-B-1
Serna et al.
Y et les sept premie`res vues de la table 4 ordonne´es (par rapport a` leur couˆt de
calcul) sur l’axe X. L’algorithme Greedy est simple et efficace, ne´anmoins, dans notre
expe´rimentation, a` partir du 6e`me choix, l’algorithme se´lectionne les vues les plus
couˆteuses. Ceci nous motive pour proposer un me´canisme pour une se´lection plus fiable.
Nous proposons d’inclure les parame`tres de la fre´quence d’utilisation, le couˆt de calcul
et la fre´quence de mises a` jour sur les relations de base. Dans la suite, nous de´crivons
notre proposition en de´tail.
4.3 Algorithme propose´ pour la se´lection des vues a` mate´rialiser
Dans notre algorithme, les relations de´pendantes jouent un roˆle essentiel, ainsi, nous
conside´rons que le nombre de relations de´pendantes d’une vue repre´sente un parame`tre
initial pour la fre´quence d’utilisation, ainsi que pour le couˆt de calcul. Pour le premier,
nous multiplions le be´ne´fice optimal, donne´ par l’algorithme Greedy, par le nombre
total des relations de´pendantes, car pour nous, la fre´quence d’utilisation augmente en
proportion directe du nombre des relations de´pendantes. Pour le couˆt de calcul, nous
conside´rons qu’il diminue par rapport au nombre de relations de´pendantes, car ce couˆt
est partage´ entre ces vues, ainsi, nous divisons le couˆt de calcul par le nombre total
des relations de´pendantes.
Notre algorithme conside`re aussi la fre´quence des mises a` jour des relations de
base. Dans ce cas, nous avons besoin du nombre d’e´le´ments a` l’inte´rieur de la vue qui
peuvent subir des changements. Sur l’hypercube du sche´ma Prise MCO (cf. figure 4),
nous avons 36 e´le´ments pouvant e´voluer (32 proprie´te´s et 4 dimensions). La relation
Etablissement contient 24 proprie´te´s, CIM10 et Mode sortie contiennent 2 proprie´te´s
et Temps en contient 4 (cf. paragraphe 3.2). Ainsi, par exemple, conside´rons la vue V2.
Elle se compose des relations Etablissement, CIM10 et Temps. Supposons que nous
avons une probabilite´ de changement de 20%, notre calcul pour la fre´quence des mises
a` jour de V2 est (33*100/36*.20), ou` 33 est le nombre d’e´le´ments de la vue V2. Dans
la suite, nous de´crivons l’algorithme propose´.
Quelques notations :
CC = Couˆt de calcul (produit des cardinalite´s approximatives des relations de base)
divise´ par le nombre de relations de´pendantes. Par exemple, le CC(v) si v=V2 (vue
ECT, cf. Figure 6) est : (((5K*18K) + (14K*12)=90M)/8)=11M, ou` 8 est le nombre
total des relations de´pendantes de V2.
PC = la fre´quence des mises a` jour sur les relations de base tel que PC(v) = |v|
multiplie´e par le couˆt de calcul. Par exemple, si v=V2 et si la fre´quence de mise a` jour
est de 20%, alors PC(v)=(3300/36*.20)*(11M)=2M.
V = Ensemble de vues.
S = Ensemble de vues se´lectionne´es.
w = Nombre de choix.
fq(v) = Fre´quence d’utilisation (nombre total des relations de´pendantes de la vue v).
v = Vue se´lectionne´e.
vo = C(vue > ”top view”).
La figure 7 montre l’algorithme propose´ incluant la fre´quence d’utilisation, le couˆt
de calcul et la probabilite´ de changement.
RNTI - E -
- 134 -RNTI-B-1
Mode´lisation multidimensionnelle et se´lection des vues a` mate´rialiser
S = {vue T}; vo = C(vue T); fq = 1; Bg = 0; t = 0; n = |V|;
for y = 1 to w do begin                                                 //nombre de choix
     for x = 2 to n do begin                                            //parcours de l’hypercube pour chaque vue
          i = x + 1;
          repeat                                                              //calculer la fréquence et le bénéfice de l’algorithme Greedy
               if vi dépend de vx
                   if {vx} appartient à S
                      vo=C(vx)
                      else vo=C(vue T)
                   endif
                   if vi dépend de v tel que {v} appartient à S
                      vo=C(v)
                   endif
                   fq = fq + 1;
                   if C(vx) < vo
                      B(vi) = C(vx) - vo
                      else B(vi) = 0
                   endif
                   Bg = Bg + B(vi)                                       //bénéfice Greedy
               endif
               i = ++;
          until i = n;
          Bg = Bg + (C(vx) - vo);                                      //bénéfice de vx
          B(vx, S) = (Bg * fq) - (CC(vx)/fq + PC(vx));         //bénéfice incluant la fréquence, le coût de calcul et la prob. chang. 
          if B(vx, S) > t
             t = B(vx, S);                                                   //bénéfice maximal
             v = vx;
          endif
     endfor
     t=0;                                                              
     S = S U {v};
endfor
résultat S
Fig. 7 – Algorithme propose´
RNTI - E -
- 135 - RNTI-B-1
Serna et al.
Le tableau 5 montre les re´sultats de l’application de notre algorithme pour les 7
premiers choix, en conside´rant 20% de fre´quence de mises a` jour sur les relations de
base.
Vue 1e`re Choix 2e`me 3e`me 4e`me 5e`me 6e`me 7e`me
V2 (448K-(11M*1.18))=-13M -13M -13M -13M -13M -13M -13M
V3 (2M-13M)=-11M -12M -12M -12M -12M -12M -12M
V4 (3392K-9K)=3M - - - - - -
V5 (1344K-46K)=1298K 626K - - - - -
V6 (640K-26M)=-25M -26M -26M -26M -26M -26M -26M
V7 (864K-18K)=845K -11K -11K -11K -11K -11K -11K
V8 (864K-7K)=857K 2K 2K 2K 2K - -
V9 (448K-56K)=392K 168K 0K -28K -28K -28K -28K
V10 (736K-24K)=713K 345K 177K - - - -
V11 (864K-62)=864K 9K 9K 9K - - -
V12 (216K-3K)=213K -1K -1K -1K -1K -3K -3K
V13 (196-9K)=187K 89K 47K -3K -3K -3K -3K
V14 (54K*2*2=216K)=216K 2K 2K 2K 30 30 30
V15 (54K*2*2=216K)=216K 2K 2K 2K 41 41 -
{V1} S+=V4 S+=V5 S+=V10 S+=V11 S+=V8 S+=V15 S+=V14
Tab. 5 – Application de notre algorithme aux donne´es ADELEM
Pour le premier choix la valeur de vo est e´gale a` 54K, le couˆt de V1, car elle
repre´sente la vue avec le couˆt de stockage minimum dans l’ensemble S. Pour le deuxie`me
et le troisie`me elle est repre´sente´e par 603 (le couˆt de V4), car c’est la vue ayant un couˆt
de stockage infe´rieur a` l’inte´rieur de S. Dans la premie`re ite´ration, le choix est la vue V4,
car elle repre´sente le plus haut gain ((((53K*8)*8)=3392K)-((61K/8)*1.18=9K)=3M).
Le gain est calcule´ de la manie`re suivante : couˆt(V4) - couˆt(V1) = (53K*8) repre´sente
le gain de Greedy, nous multiplions ce gain par le nombre de relations de´pendantes de
V4 (V4, V7, V8, V11, V12, V14, V15 et V16). Ensuite, nous le soustrayons le couˆt de
calcul divise´ par le nombre de relations de´pendantes et multiplie´ par la fre´quence des
mises a` jour.
Le second choix est la vue V5 avec 626K (((21K*4*8)=672K) - ((346K/8) * 1.06
= 46K)=626K), les vues de´pendantes sont (V3, V6, V10 et V13), les autres vues
de´pendantes de V3 ne sont pas prises en compte, car elles ont un gain infe´rieur a` celui
de la vue V4. Ne´anmoins, nous multiplions le re´sultat par le nombre total des vues
de´pendantes et nous divisons le couˆt de calcul par ce nombre total. Finalement, la
dernie`re ligne contient le re´sultat, elle repre´sente l’ensemble S={V1, V4, V5, V10, V11,
V8, V15, V14}.
La figure 8 montre l’application de notre algorithme par rapport aux couˆts de calcul
et de stockage. Nous conside´rons les 7 premiers re´sultats. Si nous prenons comme
re´fe´rence la figure 4, nous remarquons que la se´lection est fait de la manie`re suivante :
du deuxie`me niveau (3 Dim), notre algorithme se´lectionne les deux vues de be´ne´fice
optimal. Pour le troisie`me niveau (2 Dim), il se´lectionne les trois meilleurs et finalement
pour le dernier niveau (1 Dim), il se´lectionne les deux premie`res vues optimales.
Le graphique contient les couˆts de calcul et de stockage sur l’axe des Y et les sept
premie`res vues de la table 5 ordonne´es (par rapport a` leur couˆt de calcul) sur l’axe X.
Nous constatons, qu’a` la diffe´rence de l’algorithme Greedy, notre proposition donne de
meilleurs re´sultats dans notre cas expe´rimental.
RNTI - E -
- 136 -RNTI-B-1
Mode´lisation multidimensionnelle et se´lection des vues a` mate´rialiser
16. . .5 6
Coût d’exécution
Coût de stockage
Nombre de vues matérialisées
70
100k
300k
90M
200k
Nombre
    de
  tuples
4321
.
.
.
V5
V10
V4
V8
V11 V14 V15
Fig. 8 – Ensemble ordonne´ des vues se´lectionne´es
5 Travaux analogues
Pour la se´lection des vues a` mate´rialiser, nous proposons un algorithme qui prend
en compte la fre´quence d’utilisation, le couˆt de calcul ainsi que la fre´quence de mises a`
jour. Nous nous sommes inspire´ des travaux de recherche [Gupta et Mumick, 1995,
Levy et al., 1995, Chan et al., 1999, Yang et al., 1997, Baril et Bellahse`ne, 2003] qui
utilisent un mode`le de couˆt, comme celui de Greedy, mais qui a e´te´ adapte´ avec
l’inclusion de certains parame`tres. Par exemple, dans [Zhang et al., 2001], les auteurs
proposent un MVPP (Multiple View Processing Plan) pour une se´lection des vues a`
mate´rialiser, leur algorithme utilise la fre´quence d’utilisation et la fre´quence de mises
a` jour.
Dans [Baril et Bellahse`ne, 2003], pour de´terminer l’ensemble des vues a` mate´rialiser
offrant un plus grand be´ne´fice, les auteurs proposent e´galement un MVMG (Multi
View Materialization Graph). Ils de´finissent un algorithme ge´ne´ral pour calculer le
be´ne´fice global de la vue par rapport au couˆt de la requeˆte et au couˆt de maintenance.
Ne´anmoins, a` la diffe´rence de MVPP, ils diffe´rencient le couˆt d’e´valuation d’une requeˆte
par rapport au type d’ope´ration (Select, Project et Join). Ils utilisent aussi le parame`tre
de fre´quence de la requeˆte ainsi que le couˆt de maintenance base´ sur les ope´rateurs Add
et Delete.
Notre algorithme se base sur le mode`le de couˆt propose´ par Greedy, ne´anmoins,
dans notre cas, le nombre total des relations de´pendantes joue un roˆle essentiel, car
nous conside´rons que le be´ne´fice d’une vue augmente en rapport avec le nombre de
relations qui en de´pendent. Pour une raison similaire, le couˆt de calcul de la vue di-
minue en rapport avec le nombre total de relations de´pendantes d’elle. La faiblesse de
notre algorithme est l’absence du couˆt d’e´valuation d’une requeˆte par rapport au type
d’ope´ration (Select, Project ou Join). Nous ne prenons pas en compte les restrictions
e´ventuelles sur l’espace de stockage.
RNTI - E -
- 137 - RNTI-B-1
Serna et al.
6 Conclusions
Pour la conception d’un mode`le multidimensionnel, nous avons spe´cifie´ trois classes :
Cube, Dimension et Hie´rarchie. Nous avons donne´ une de´finition formelle pour chaque
classe et leur instance, ainsi qu’une de´finition d’une base de donne´es multidimen-
sionnelle et son instance. Ceci nous a permis d’aboutir a` la conception d’un sche´ma
en constellation pour la construction d’un entrepoˆt multidimensionnel de donne´es
me´dicales. Nous avons utilise´ les informations concernant l’ensemble de sources de
donne´es re´elles et des indicateurs du projet ADELEM pour prouver et ve´rifier le mode`le
propose´.
Par rapport a` la se´lection des vues a` mate´rialiser, nous avons implante´ d’abord le
sche´ma en e´toile Prise MCO. Nous avons utilise´ ce sche´ma pour aboutir a` la mate´rialisa-
tion de l’hypercube, ce qui nous a permis de connaˆıtre le couˆt de stockage des vues
et de pouvoir de´terminer leur couˆt de calcul. Nous avons utilise´ l’algorithme Greedy
pour la se´lection de l’ensemble optimal de vues a` mate´rialiser, ne´anmoins, dans notre
expe´rimentation, a` partir du 6e`me choix, l’algorithme se´lectionne les vues plus couˆteuses.
Ceci nous a motive´ a` proposer un me´canisme pour une se´lection plus fiable. Notre al-
gorithme conside`re les parame`tres de fre´quence d’utilisation, de couˆt de calcul et de
fre´quence de mises a` jour sur les relations de base. Nous avons prouve´ l’algorithme
propose´ sur des donne´es me´dicales re´elles et nous avons constate´ que notre proposition
donne de meilleurs re´sultats pour notre cas d’expe´rimentation.
Remerciements
Nous remercions les referees anonymes pour leurs commentaires de´taille´s sur la
premie`re version de l’article.
Re´fe´rences
[Baril et Bellahse`ne, 2003] X. Baril et Z. Bellahse`ne. Selection of Materialized Views :
A Cost-Based Approach. In CAiSE, pages 665–680, Bethesda, Maryland, USA, 2003.
J. Eder and M. Missikoff.
[Belot, 2002] A. Belot. De´veloppement d’un logiciel de cartographie de l’offre et de la
demande de soins hospitaliers en France. Technical Report Projet ADELEM-SIGT,
Universite´ Claude Bernard Lyon 1, 2002.
[Benitez, 2002] E. Benitez. Infrastructure adaptable pour l’e´volution des entrepoˆts de
donne´es. PhD thesis, Universite´ Joseph Fourier, Grenoble, France, Septembre 2002.
[Chan et al., 1999] G. Chan, Q. Li, et L. Feng. Design and Selection of Materialized
Views in Data Warehousing : A Case Study. In ACM International Workshop on
Data Warehousing and OLAP, 1999.
[Doucet et Gangarski, 2001] A. Doucet et S. Gangarski. Entrepoˆts de donne´es et Bases
de Donne´es Multidimensionnelles, Chapitre 12 du livre : Bases de Donne´es et In-
ternet, Mode`les, langages et syste`mes. A. Doucet, G. Jomier (e´diteurs). Editions
Herme`s, 2001.
RNTI - E -
- 138 -RNTI-B-1
Mode´lisation multidimensionnelle et se´lection des vues a` mate´rialiser
[Grandi et Mandreoli, 2002] Fabio Grandi et Federica Mandreoli. A Formal Model for
Temporal Schema Versioning in Object-Oriented Databases. Technical Report A
TIME CENTER, TR-68, 2002.
[Gray et al., 1995] J. Gray, A. Bosworth, A. Layman, et H. Pirahesh. Data Cube : A
Relational Aggregation Operator Generalizing Group-By, Cross-Tab and Sub-Totals.
Technical Report Microsoft No. MSR-TR-95-22, 1995.
[Gupta et Mumick, 1995] A. Gupta et I. Mumick. Maintenance of Materialized Views :
Problems, Techniques and Applications. IEEE Quarterly Bulletin on Data Enginee-
ring ; Special Issue on Materialized Views and Data Warehousing, 18(2) :3–18, 1995.
[Harinarayan et al., 1995] V. Harinarayan, A. Rajaraman, et J. Ullman. Implementing
Data Cubes Efficiently. A full version. Technical Report IRI-92-23406 and DAAH04-
95-1-0192 and F33615-93-1-1339, 1995.
[Hurtado et al., 1999a] Carlos A. Hurtado, Alberto O. Mendelzon, et Alejandro A.
Vaisman. Maintaining Data Cubes under Dimension Updates. In ICDE, pages 346–
355, 1999.
[Hurtado et al., 1999b] Carlos A. Hurtado, Alberto O. Mendelzon, et Alejandro A.
Vaisman. Updating OLAP dimensions. In DOLAP ’99 : Proceedings of the 2nd
ACM international workshop on Data warehousing and OLAP, pages 60–66. ACM
Press, 1999.
[Kimball, 1996] R. Kimball. Entrepoˆts de donne´es, Guide pratique du concepteur de
data warehouse. John Wiley and Sons, Inc., 1996.
[Kimball et Ross, 2003] R. Kimball et M. Ross. Entrepoˆts de donne´es, Guide pratique
de mode´lisation dimensionnelle. Vuibert, Paris, 2003.
[Levy et al., 1995] A. Levy, A. Mendelzon, Y. Sagiv, et D. Srivastava. Answering Que-
ries Using Views. In Proceedings of the 14th ACM SIGACT-SIGMOD-SIGART
Symposium on Principles of Database Systems, pages 95–104, San Jose, Calif., 1995.
[Li et Wang, 1996] Chang Li et Xiaoyang Sean Wang. A Data Model for Supporting
On-Line Analytical Processing. In CIKM, pages 81–88, 1996.
[Quix, 1999] Christoph Quix. Repository Support for Data Warehouse Evolution. In
DMDW, page 4, 1999.
[Yang et al., 1997] J. Yang, K. Karlapalem, et Q. Li. Algorithms for Materialized View
Design in Data Warehousing Environment. In The VLDB Journal, pages 136–145,
1997.
[Zhang et al., 2001] C. Zhang, X. Yao, et J. Yang. An evolutionary approach to ma-
terialized view selection in a data warehouse environment. IEEE Trans. Systems,
Man, Cybernetics, PART C, 31 :282–294, September 2001.
Summary
A data warehouse integrates information from several internal and external data
sources in an enterprise or an organization. Data sets are used for decision making, thus
multidimensional model design and materialized view selection constitute a complex
RNTI - E -
- 139 - RNTI-B-1
Serna et al.
and delicate process. In this article, we designed a multidimensional model with three
classes : cube, dimension and hierarchy. Also, we propose an algorithm for an optimal
selection of materialized views based upon different frequencies (queries, updates on
database relations). We had the opportunity to apply our proposal to medical data.
This allowed us to verify and validate our approach.
RNTI - E -
- 140 -RNTI-B-1
