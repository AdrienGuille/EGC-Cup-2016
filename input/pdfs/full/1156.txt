1Processing Data Streams:
An (Incomplete) Tutorial
Johannes Gehrke
Department of Computer Science
johannes@cs.cornell.edu
http://www.cs.cornell.edu
Standard Pub/Sub
z Publish/subscribe (pub/sub) is a 
powerful paradigm 
z Publishers generate data 
zEvents, publications
z Subscribers describe interests in 
publications
zQueries, subscriptions
z Asynchronous communication
z Decoupling of publishers and subscribers
z Much commercial software …
2Limitation of Standard Pub/Sub
z Scalable implementations have very simple 
query languages
z Simple predicates, comparing message attributes 
to constants
z E.g., topic=‘politics’ AND author=‘J. Doe’
z Individual events vs. event sequences
z Many monitoring applications need 
sequence patterns 
z Stock tickers, RSS feeds, network monitoring, 
sensor data monitoring, fraud detection, etc.
Example: RSS Feed Monitoring
z Once CNN.com posts an article on 
Technology, send me the first post 
referencing (i.e., containing a link to) this 
article from the blogs to which I subscribe
z Send postings from all blogs to which I 
subscribe, in which the first posting is a 
reference to a sensitive site XYZ, and 
each later posting is a reference to the 
previous.
3Example: System Event Log Monitoring
z In the past 60 seconds, has the number of 
failed logins (security logs) increased by more 
than 5? (break-in attempt)
z Have there been any failed connections in the 
past 15 minutes? If yes, is the rate increasing?
z Have there been any disk errors in the past 30 
minutes? If yes, is the rate increasing? (failed 
disk indicator)
z Have there been any critical errors (those 
added to the dbase table to monitor by 
administrators) in the past 10 minutes?
Example: Stock Monitoring
z Notify me when the price of IBM is above 
$83, and the first MSFT price afterwards 
is below $27.
z Notify me when some stock goes up by at 
least 5% from one transaction to the 
next.
z Notify me when the price of any stock 
increases monotonically for ≥30 min.
z Notify me when the next IBM stock is 
above its 52-week average.
4Linear Road Benchmark
Linear City
z 100x100 miles
z 10 parallel 
expressways, 100 
segments each
z Each expressway has 
4 lanes in each 
direction
z 3 travel lanes
z 1 entry/exit lane
z Vehicles with sensors 
that report their 
position
Figure from Linear Road: A Stream Data Management Benchmark, VLDB 2004
Linear Road Benchmark (2)
z Vehicle:
z Begins at some segment and exists at some 
segments
z Reports its position every 30 seconds
z Vehicle speed is set such that:
zOne report from entrance and exit ramps
zAt least one report from each segment
z One accident every 20 minutes
z Reduced speed in that segment
z Takes 10-20 minutes to clear out the accident
5Linear Road Benchmark (3)
Figure from Linear Road: A Stream Data Management Benchmark, VLDB 2004
Linear Road Benchmark (4)
z Streams:
z Position reports
z Historical query requests:
zAccount balances
zDaily expenditures
zTravel time estimation
6Linear Road Benchmark (5)
z Benchmark requirements:
z Compute tolls every time a position is reported
z Toll notification at every position update
z Toll assessment at every segment crossing
z Accident detection
z Four consecutive identical position reports
z Accident notification: If there is an accident in a segment, 
notify all incoming vehicles of the accident
z Historical queries
z Account balance
z Daily expenditure
z Travel time estimation
Linear Road Benchmark (6)
z System achieves L-Rating
z Maximum scale factor at which the system meets 
response time and accuracy requirements
z Example of DSMS versus dinosaur system: 
Response time
Expressways X Aurora
0.5 3 1
1 2031 1
1.5 ~16000 1 
2 ~52000 2
7Solutions?
z Traditional pub/sub
z Scalable, but not expressive enough
z Database Management System
z Static datasets
z One-shot queries
z Triggers
z Data Stream Management Systems
z Event Processing Systems
Real-Time DSP Requirements
(1) Support a high-level “StreamSQL” language
(2) Deal with out-of-order data
(3) Generate predictable and repeatable 
outcomes
(4) Integrate well with static data
(5) Fault-tolerance
(6) Scale with hardware resources
(7) Low latency Æ process data as it streams by 
(“in-stream processing”); no requirement to 
store data first
8Tutorial Outline
z Basics
z How to model time
z Data stream query languages and processing 
models
z STREAM and CQL
z Cayuga
z Fault tolerance
z New operators
z Change detection
z Burst detection
z A Case Study
Caveat
z To trade breadth for some depth, this tutorial 
ignores many important topics among them:
z In-depth discussion of applications 
z Query processing
z Heartbeats
z Query optimization
z Query rewrite
z Access methods
z XML
z Theoretical results on the language side
9Tutorial Outline
z Basics
z How to model time
z Data stream query languages and 
processing models
z Fault tolerance
z New operators
z A Case Study
The Data Stream Model
1) A relation is a set of 
tuples
2) Relations are persistent
3) Interactive queries
4) Random access to data, 
queries need to be 
processed as they arrive
5) Physical database design 
does not change during 
query, queries can be 
unpredictable
1) A stream is a bag of 
tuples with a partial order
2) Streams need to be 
processed in real time as 
tuples arrive
3) Continuous queries
4) Sequential access to 
data, random access to 
continuous queries
5) Queries do not change, 
stream can be very 
unpredictable
Slide based on material from Jennifer Widom.
10
Comparison of Stream Systems
High
Low
CEPDSMS
Publish/
subscribe
☺
Complexity 
of queries
ManyFew
Number of 
concurrent queries
Tutorial Outline
z Basics
z How to model time
z Data stream query languages and 
processing models
z Fault tolerance
z New operators
z A Case Study
11
Temporal Model
z Questions:
z How are timestamps defined?
zWhat is the timestamp of an output record?
z Approaches:
zPoint timestamps
z Interval timestamps
z Surprises like E1;(E2;E3)=E2;(E1;E3)?
Imperfections in Event Streaming
Slide courtesy
of Mingsheng 
Hong.
12
Imperfections in Event Streaming
Network imperfections:
Tuples are late and/or out of order
Slide courtesy
of Mingsheng 
Hong.
Item X, Qty Q, Value, V
Imperfections in Event Streaming
Stream source retractions:
A tuple is retracted after 
it is streamed on the wire
Slide courtesy
of Mingsheng 
Hong.
13
Consistency Requirements
z Imperfections in streaming environments
z Out of order delivery
z Retractions
z Current approaches
z Conservative approach: buffer incoming events to re-establish 
temporal ordering
z Best-effort approach: can allow to drop late events
z Consistency levels
z User: specify consistency requirements on a per query basis
z System: manage resources to uphold the consistency guarantees
z Tradeoffs
z Output quality and size 
z System responsiveness and cost
Slide courtesy
of Mingsheng 
Hong.
Example Scenarios
z Various continuous monitoring queries in financial 
markets
z Scenario 1: queries running in compliance office to monitor 
trader activity and customer accounts, ensure conformity with 
SEC rules and institution guidelines
z Requirements: process events in proper order to make accurate 
assessment (strong consistency)
z Scenario 2: queries running in trading floors to extract events 
from news feeds and correlated with market indicators, 
impacting automated stock trading programs
z Requirement: high responsiveness (low delay); can allow 
retraction on trading (middle consistency)
z Scenario 3: queries running on a trader’s desktop to track a 
moving average of the value of a an investment portfolio
z Requirement: high responsiveness; does not require perfect 
accuracy (weak consistency)
Slide courtesy
of Mingsheng 
Hong.
14
Key Insight
z Optimistic query processing 
provides a spectrum of consistency levels
Slide courtesy
of Mingsheng 
Hong.
Consistency Domain and  Levels
W
B
Blocking
Memory
Fast & optimistic
Late & conservative
Cheap &
less correct
Expensive &
more correct
Slide courtesy
of Mingsheng 
Hong.
15
Consistency Tradeoffs
Blocking
Memory
Slide courtesy
of Mingsheng 
Hong.
Consistency Tradeoffs
Quality of Output
Non-Blocking Output Size
Middle Consistency
Weak Consistency
Strong Consistency
Slide courtesy
of Mingsheng 
Hong.
16
Consistency Tradeoffs
Low
Middle
High
Quality 
of 
Output
LowLowNoWeak
HighHighNoMiddle
LowHighYesStrong
Output
Size
State
Size
BlockingConsistency
(as specified by 
user)
Slide courtesy
of Mingsheng 
Hong.
Bitemporal Stream Model
zTemporal dimensions
z Application time: event provider’s clock
z Valid time, Vs, Ve
z System time: CEDR server’s clock
z CEDR time, Cs
z Example
z [Insertion] A security token valid from 9am to 
5pm arrives at CEDR server at 9:15am. 
z [Retraction] The same token is revoked at 
4pm, and the revocation arrives at CEDR 
server at 4:10pm.
Slide courtesy of Mingsheng Hong.
17
Bitemporal Stream Schema
z Schema (ID, Type, Vs, Ve, Cs; Payload)
z ID can be implicitly represented 
z Insertions and retractions (+ and -)
z Root time not included
z Example: event provider inserts an event of ID e0, 
valid during [1, ∞), which arrives at server at CEDR 
time 3.
ID Type Vs Ve Cs P
e0 + 1 ∞ 3 p0
e0 - 1 10 5 p0
e0 - 1 5 8 p0
e1 + 4 9 10 p1
Slide courtesy of Mingsheng Hong.
Conceptual Stream Schema
z (Vs, Ve; Payload)
ID Typ
e
Vs Ve Cs P
e0 + 1 ∞ 3 p0
e0 - 1 10 5 p0
e0 - 1 5 8 p0
e1 + 4 9 10 p1
Vs V
e
P
1 5 p0
4 9 p1
e0
e1
Bitemporal schema Conceptual schema
Slide courtesy of Mingsheng Hong.
18
Tutorial Outline
z Basics
z How to model time
z Data stream query languages and 
processing models
z STREAM and CQL
z Cayuga
z Fault tolerance
z New operators
z A Case Study
Continuous Query Language – CQL
SQL with:
z Streams
zWindows
z New semantics (stream)
z Three relation-to-stream operators: Istream, 
Dstream Rstream
z Sampling
Slide based on material from Jennifer Widom.
19
CQL: Stream
z A stream S is a (possibly infinite) bag 
(multiset) of elements (s,t), where s is a 
tuple belonging to the schema of S and t 
in T is the timestamp of the element.
z Base stream versus derived stream
Slide based on material from Jennifer Widom.
CQL and Linear Road Examples
Simplified Linear Road Setup:
z A single input stream: The stream of positions and 
speeds of vehicles
z A single continuous query computing the tolls
z A single output toll stream:
PosSpeedStr(vehicleId,speed,xPos,dir,hwy)
z vehicleId: vehicle
z speed: speed in MPH
z xPos: Position of the vehicle within the highway in 
feet
z dir: direction (east or west)
z hwy: highway number
Slide based on material from Jennifer Widom.
20
CQL: Relation
z Definition: A relation R is a mapping from 
T to a finite but unbounded bag of tuples 
belonging to the schema of R.
z R(t) varies over time
Slide based on material from Jennifer Widom.
CQL Relation: Example
z Toll for a congested segment depends on 
the current number of vehicles in the 
segment:
SegVolRel(segNo,dir,hwy,numVehicles)
z segNo: segment within the highway
z dir: direction
z hwy : highway number
z numVehicles: number of vehicles in the 
segment
Slide based on material from Jennifer Widom.
21
Streams ÅÆ Relations
Streams Relations
Window specification
Special operators:
Istream, Dstream, Rstream
Any relational 
query language
Slide based on material from Jennifer Widom.
Stream Æ Relation
z Construct: Windows
z Time-based
z Tuple-based
z Partitioned
Slide based on material from Jennifer Widom.
22
Time-Based Window
z S [Range T]
z S [Now]
z S [Range Unbounded]
Examples:
z PosSpeedStr [Range 30 Seconds]
z PosSpeedStr [Now]
z PosSpeedStr [Range Unbounded]
Slide based on material from Jennifer Widom.
Tuple-Based Window
z S [Rows N]
z If tuples form a partial order, ties are broken 
arbitrarily
z [Rows Unbounded]
Example:
z PosSpeedStr [Rows 1]
Slide based on material from Jennifer Widom.
23
Partitioned Windows
z S [Partition By A1,...,Ak Rows N]
1. Logically partition S into substreams
(compare to SQL GROUP By)
2. Compute a tuple sliding window
3. Take union
Example:
z PosSpeedStr [Partition By vehicleId
Rows 1]
Slide based on material from Jennifer Widom.
Relation Æ Relation
z Any query expressed in SQL
z But time-varying relations
Example:
z Select Distinct vehicleId
From PosSpeedStr [Range 30 Seconds]
Slide based on material from Jennifer Widom.
24
Relation Æ Stream
z Istream(R) contains a stream element 
(r,t) whenever r in R(t) \ R(t-1)
z Dstream(R) contains a stream element 
(r,t) whenever r in R(t-1) \ R(t)
z Rstream(R) contains a stream element 
(r,t) whenever r in R(t)
Note: Istream and Dstream are expressible 
with Rstream and suitable selections
Slide based on material from Jennifer Widom.
Relation Æ Stream: Examples
Select Istream(*)
From PosSpeedStr [Range Unbounded]
Where speed > 65
Select Rstream(*)
From PosSpeedStr [Now]
Where speed > 65
Slide based on material from Jennifer Widom.
25
Some Equivalences
Select Istream(L)
From S [Range Unbounded]
Where C
==
Select Rstream(L)
From S [Now]
Where C
Slide based on material from Jennifer Widom.
Some Equivalences (Contd.)
(Select L From S Where C) [Range T]
==
Select L From S [Range T] Where C
Slide based on material from Jennifer Widom.
26
Query Execution
z When a continuous query is registered, 
generate a query execution plan
z New plan merged with existing plans
z Users can also create & manipulate plans directly
z Plans composed of three main components:
z Operators 
z Queues (input and inter-operator)
z State (windows, operators requiring history)
z Global scheduler for plan execution
Slide based on material from Jennifer Widom.
Simple Query Plan
Q1 Q2
State4⋈State3σ
Stream1 Stream2
Stream3
State1 State2⋈
SchedulerScheduler
Slide courtesy of Jennifer Widom.
27
Tutorial Outline
z Basics
z How to model time
z Data stream query languages and 
processing models
z STREAM and CQL
z Cayuga
z Fault tolerance
z New operators
z A Case Study
Cayuga: From Pub/Sub to CEP
(CEP: Complex Event Processing)
z Cayuga language
z Expressiveness
z Precise, formal semantics
z Cayuga processing model
z Scalability in event rate and number of 
queries
28
Data Model
z Stream S is a sequence of tuples
z are data attribute values
z Like relational tuples
z t’s are temporal values
z Starting and detection times of an event
z Events have duration
z Example
z Schema of stock ticker stream: (Name, Price)
z Base stream events: (IBM, 85; 9:15, 9:15), (MSFT, 27; 
9:16, 9:16), (DELL, 29; 9:17, 9:17)
Data Model
z Stream S is a sequence of tuples
z are data attribute values
z Like relational tuples
z t’s are temporal values
z Starting and detection times of an event
z Events have duration
z Example
z Schema of stock ticker stream: (Name, Price)
z Base stream events: (IBM, 85; 9:15, 9:15), (MSFT, 27; 
9:16, 9:16), (DELL, 29; 9:17, 9:17)
29
Data Model
z Stream S is a sequence of tuples
z are data attribute values
z Like relational tuples
z t’s are temporal values
zStarting and detection times of an event
zEvents have duration
z Example
zSchema of stock ticker stream: (Name, Price)
zBase stream events: (IBM, 85; 9:15, 9:15), (MSFT, 
27; 9:16, 9:16), (DELL, 29; 9:17, 9:17)
Cayuga Stream Algebra
z Compositional: Operators produce new 
streams from existing streams
z Translation to Nondeterministic Finite 
Automata
z Edge transitions on input events
z Automaton instances carry relevant data from 
matched events
30
Operators
z Relational operators (on non-temporal 
attributes)
z Selection
z Projection
z Renaming
z Union
z Together these give standard pub/sub
Sequence Operator
z Sequence operator S1;θ S2
z After an event from S1 is detected, match the 
first event from S2 that satisfies the condition
z Examples
z IBM price increases by at least $1 in two 
consecutive sales:
z Find a stock whose price stays constant in two 
consecutive sales:
31
Sequence Operator (Contd.)
z Sequencing is a weak join on timestamps
z Can join an event with one later in future...
z Or with the immediate successor
z Can be useful for queries about causal relationships
Sequence Operator: Example
z Query 1:
z Send me the first new posting from 
apple.slashdot.org after a product 
announcement on www.apple.com.
32
Sequence Operator (Contd.)
z Automaton edges search 
for matches.
z θ1: www.apple.com 
announcement
z θ2: apple.slashdot.org
posting
z Intermediate state stores 
Apple announcements
z Waits to pair with next 
available Slashdot post.
Parameterized Sequencing
z Problems with previous query
z Assumes a quick response to Apple announcements
z There may be several announcements (i.e., 
MacWorld Expo)
z Want Slashdot post to refer to right product
z Post has link to announcement as a parameter
z Query 2:
z Once a new product announcement appears on 
www.apple.com, send me the first posting from 
apple.slashdot.org that links to this announcement. 
33
Parameterized Sequencing (Contd.)
z Intermediate information 
is already there
z Each announcement is an 
automaton instance
z Just change edge filters 
to leverage information
z θ1: www.apple.com 
announcement
z θ2: apple.slashdot.org
posting linking to an 
instance
Iteration Operator
z Iteration operator (similar to Kleene-+)
z Intuitively:
34
Iteration Example
z IBM stock price monotonically increases
IBM
85
MSFT
27
IBM
85.5
IBM
85.7
DELL
29
MSFT
27.4
IBM
85.9
IBM
85.6
Name
Price
Automaton for Iteration Operator
35
Iteration: Another Example
z Following the spread of crazy Apple 
rumors...
z Query 3:
z Send me a sequence of Apple blog postings, 
in which the first posting is a rumor about an 
upcoming Apple product announcement, and 
each later posting is a reference (i.e., 
contains a direct quote from or a hypertext 
link to) to the previous.
Implementing Iteration
z Similar to parameters sequencing
z θ1: Initial Apple rumor
z θ2: Rumor that references the previous one
z Purple edge is a rebind edge
z Updates instance information with latest rumor
36
Aggregation
z Recall: Iteration also allows for aggregation.
z Iterate over all posts of this type
z Keep a running aggregate of some post attribute
z e.g. current number of comments, average word count, 
etc...,
z Implemented like normal aggregates
z Need initializer, iterator, finalizer
z Query 4:
z Send me an product review from apple.slashdot.org
once it receives an above average number of user 
comments.
Implementing Aggregation
z Rebind edge performs the aggregation
z g is attached to rebind edge to update values
z Note outgoing edge different from rebind edge
z θ3: Above average number of comments
37
Other Features
z Resubscription
z Ability for one query to subscribe to the 
output of another (as a stream)
z Significantly more expressive
z Extensibility
z incorporate user-defined datatypes, data 
mining algorithms, predicates, aggregation 
functions, ...
Example
z Notify me when 
1. for any stock, there is a a very large trade 
(volume > 10K);
2. followed by a monotonic decrease in price for 
at least 10 minutes;
3. the next quote on the same stock after this 
monotonic sequence is 5% above the 
previously seen (bottom) price.
z Intuition: Large sale, followed by price 
drop, followed by sudden upwards move
38
Example
z Algebra expression:
Example
39
Example
(name,price,vol)
(company,maxP)
(company,maxP,minP)
(company,maxP,minP,finalP)
Example
40
Cayuga Query Language
SELECT Name, MaxPrice, MinPrice, Price AS FinalPrice
FROM
FILTER{Price > 1.05*MinPrice}(
FILTER{DUR > 10min}(
(SELECT Name, Price_1 AS MaxPrice, Price AS MinPrice
FROM FILTER{Volume > 10000}(Stock))
FOLD{$2.Name = $.Name, $2.Price < $.Price}
Stock)
NEXT{$2.Name = $1.Name}
Stock)
Cayuga Automata
SELECT Name, MaxPrice, MinPrice, Price AS FinalPrice
FROM
FILTER{Price > 1.05*MinPrice}(
FILTER{DUR > 10min}(
(SELECT Name, Price_1 AS MaxPrice, Price AS MinPrice
FROM FILTER{Volume > 10000}(Stock))
FOLD{$2.Name = $.Name, $2.Price < $.Price}
Stock)
NEXT{$2.Name = $1.Name}
Stock)
41
Cayuga Automata
SELECT Name, MaxPrice, MinPrice, Price AS FinalPrice
FROM
FILTER{Price > 1.05*MinPrice}(
FILTER{DUR > 10min}(
(SELECT Name, Price_1 AS MaxPrice, Price AS MinPrice
FROM FILTER{Volume > 10000}(Stock))
FOLD{$2.Name = $.Name, $2.Price < $.Price}
Stock)
NEXT{$2.Name = $1.Name}
Stock)
Cayuga Automata
SELECT Name, MaxPrice, MinPrice, Price AS FinalPrice
FROM
FILTER{Price > 1.05*MinPrice}(
FILTER{DUR > 10min}(
(SELECT Name, Price_1 AS MaxPrice, Price AS MinPrice
FROM FILTER{Volume > 10000}(Stock))
FOLD{$2.Name = $.Name, $2.Price < $.Price}
Stock)
NEXT{$2.Name = $1.Name}
Stock)
42
Cayuga Automata
SELECT Name, MaxPrice, MinPrice, Price AS FinalPrice
FROM
FILTER{Price > 1.05*MinPrice}(
FILTER{DUR > 10min}(
(SELECT Name, Price_1 AS MaxPrice, Price AS MinPrice
FROM FILTER{Volume > 10000}(Stock))
FOLD{$2.Name = $.Name, $2.Price < $.Price}
Stock)
NEXT{$2.Name = $1.Name}
Stock)
Cayuga Automata
SELECT Name, MaxPrice, MinPrice, Price AS FinalPrice
FROM
FILTER{Price > 1.05*MinPrice}(
FILTER{DUR > 10min}(
(SELECT Name, Price_1 AS MaxPrice, Price AS MinPrice
FROM FILTER{Volume > 10000}(Stock))
FOLD{$2.Name = $.Name, $2.Price < $.Price}
Stock)
NEXT{$2.Name = $1.Name}
Stock)
43
Cayuga Automata
SELECT Name, MaxPrice, MinPrice, Price AS FinalPrice
FROM
FILTER{Price > 1.05*MinPrice}(
FILTER{DUR > 10min}(
(SELECT Name, Price_1 AS MaxPrice, Price AS MinPrice
FROM FILTER{Volume > 10000}(Stock))
FOLD{$2.Name = $.Name, $2.Price < $.Price}
Stock)
NEXT{$2.Name = $1.Name}
Stock)
Example: Double-Top
z Double-Top query pattern
44
Cayuga Resubscription (No Iteration)
z Compute stream of local extrema:
z Union them, then search for actual pattern:
Double-Top Query: Cayuga
SELECT Name, PriceA, PriceB, PriceC, PriceD, Price_1 AS PriceE, Price AS PriceF
FROM FILTER {Price >= Price_1 AND Price <= PriceA}
(FILTER{Price <= 1.1*PriceB} (
SELECT Name, PriceA, PriceB, PriceC, Price_1 AS PriceD, Price
FROM 
FILTER{Price >= 0.9*PriceB} (
SELECT Name, PriceA, PriceB, Price_1 AS PriceC, Price
FROM 
FILTER{Price >= 0.9*PriceA AND Price <= 1.1*PriceA} (
SELECT Name, PriceA, Price_1 AS PriceB, Price
FROM 
FILTER{Price >= 1.2*PriceA} (
SELECT Name, Price_1 AS PriceA, Price 
FROM 
FILTER {Price < Price_1} 
(SELECT Name, Price FROM Stock NEXT {$1.Name=$2.Name} Stock)
FOLD {$1.Name = $2.Name, $2.Price >= $.Price,} Stock)
FOLD {$1.Name = $2.Name, $2.Price <= $.Price,} Stock)
FOLD {$1.Name = $2.Name, $2.Price >= $.Price,} Stock)
FOLD {$1.Name = $2.Name, $2.Price <= $.Price,} Stock)
NEXT {$1.Name = $2.Name} 
Stock)
PUBLISH MShapeStock
45
Double-Top Query: CQL
vquery : Rstream (Select S.time, S.name, S.price, (S.price - P.price)
From Stock [Now] as S, Stock [Partition By P.name Rows 2] as P Where S.name = P.name and S.time > P.time);
vtable : register stream StockDiff (time integer, name integer, price float, pdiff float);
vquery : Rstream (Select P.time, P.name, P.price, P.pdiff
From StockDiff [Now] as S, StockDiff [Partition By P.name Rows 2] as P Where S.name = P.name and (S.pdiff * P.pdiff) < 0.0);
vtable : register stream Extrema (time integer, name integer, price float, pdiff float);
vquery : Select name, count(*) from Extrema Group By name;
vtable : register relation ExtremaCounter (name integer, seqNo integer);
vquery : Rstream (Select E.name, E.price, E.pdiff, C.seqNo, C.seqNo – 1
From Extrema [Now] as E, ExtremaCounter as C Where E.name = C.name);
vtable : register stream ExtremaSeq (name integer, price float, pdiff float, seq integer, prevSeq integer);
vquery : Select name, price, seq from ExtremaSeq Where pdiff < 0.0;
vtable : register relation stateA (name integer, price float, seq integer);
vquery : Rstream (Select E.name, E.price, A.price, E.seq
From ExtremaSeq [Now] as E, stateA as A Where E.name = A.name and E.prevSeq = A.seq and E.price > (A.price * 1.2));
vtable : register relation stateB (name integer, bprice float, aprice float, seq integer);
vquery : Rstream (Select E.name, E.price, B.bprice, B.aprice, E.seq From ExtremaSeq [Now] as E, stateB as B
Where E.name = B.name and E.prevSeq = B.seq and E.price > (B.aprice * 0.9) and E.price < (B.aprice * 1.1));
vtable : register relation stateC(name integer, cprice float, bprice float, aprice float, seq integer);
vquery : Rstream (Select E.name, E.price, C.cprice, C.bprice, C.aprice, E.seq from ExtremaSeq [Now] as E, stateC as C
Where E.name = C.name and E.prevSeq = C.seq and E.price > (C.bprice * 0.9) and E.price < (C.bprice * 1.1));
vtable : register relation stateD (name integer, dprice float, cprice float, bprice float, aprice float, seq integer);
query : Rstream (Select E.name, E.price, D.dprice, D.cprice, D.bprice, D.aprice from ExtremaSeq [Now] as E, stateD as D
Where E.name = D.name and E.prevSeq = D.seq and E.price <= D.aprice);
Example: Double-Top
z Real stock data (24 companies, 112,635 
events)
46
Tutorial Outline
z Basics
z How to model time
z Data stream query languages and 
processing models
z Fault tolerance
z New operators
z A Case Study
Fault Tolerance: Environment
z Dataflow: Single entry and single exit
z Total order on input and output data
z Operators:
z Interface:
z init()
z processNext()
• Non-blocking
z Deterministic
z Platform assumptions
z Reliable network
z Fail-stop
z Controller has consistent view of the dataflow
47
Example Dataflow
z Analyze network packets from a firewall
z Track minimum and average duration of 
network sessions on a per source and 
application basis
Figure from Highly Available, FaultTolerant, Parallel Dataflows, SIGMOD 2004.
Fault-Tolerance: Basic Approach
z Process pair: Coordinate redundant 
computation between a primary and a 
secondary
z Properties of the resulting dataflow:
z Loss-free: No data in the input sequence is 
lost
z Duplicate-free: No data in the input sequence 
is duplicated
48
Fault-Tolerance: Basic Approach (2)
z Main idea:
z Add new operators 
that connect existing 
operators in the 
replicated dataflow
z Add boundary operators
z Assign a sequence 
number to each tuple
z Coordinate consumer 
and producer 
operators to store, 
ack, and flush data 
accordingly
Figure from Highly Available, FaultTolerant, Parallel Dataflows, SIGMOD 2004.
Fault-Tolerance: Basic Approach (3)
z Assumption: Ingress 
and Egrees do not fail
z Notation:
z P: Primary
z S: Secondary
Figure from Highly Available, FaultTolerant, Parallel Dataflows, SIGMOD 2004.
49
Normal Case Protocol
z Ingress forwards data to 
both S-ConsP and S-
ConsS; discards it once it 
has received acks from 
both
z Only S-ProdP forwards 
the result to Egress
z Egress acks results to S-
ProdS, which then 
discards the data
z Note: S-ProdS could have 
dangling sequence 
numbers
Figure from Highly Available, FaultTolerant, Parallel Dataflows, SIGMOD 2004.
Take-Over During Failure
z Assume wolg primary 
fails
z S-ProdS starts sending 
to Egress
z Buffer at S-ProdS only 
has unacked tuples or 
dangling sequence 
numbers
Figure from Highly Available, FaultTolerant, Parallel Dataflows, SIGMOD 2004.
50
Catch-Up
z S-ConsS [which is now 
the new primary!] 
quiesces the dataflow
z Send state to new 
secondary
z API: getState() and 
installState()
z Fold in new 
secondary
Figure from Highly Available, FaultTolerant, Parallel Dataflows, SIGMOD 2004.
This Can Be Made Formal
Idea: Specify behavior as a state-machine
Variables:
Buffer: Array of (sn, tuple, mark)
del: {REC|PRIM|SEC}
status[src], status[dest] = 
{ACTIVE|DEAD|STDBY|PAUSE}
conn[src], conn[dest] = 
{SEND|RECV|ACK|PAUSE}
dest = {PRIM,SEC}
51
State Machine of Normal Processing
Not B.full() {t = processNext();
B.put(t.sn,t,del)}
status[dest]=ACTIVE and {t=B.peed(dest);
SEND in conn[dest] send(dest,t);
B.advance(dest);}
status[dest]=ACTIVE and {t=B.peed(dest);
SEND in conn[dest] and send(dest,t);
ACK not in conn[dest] B.advance(dest);
B.ack(t.sn, dest, del);}
status[dest] = ACTIVE and {sn=recv(dest);
ACK in conn[dest] B.ack(t.sn, dest, del);}
Rollback Recovery
Passive standby:
z Into the stream of data, add delta-checkpoint 
messages. When an operator processes such a 
message, it captures the change in state since 
the last checkpoint
z Secondary does not do much processing
Upstream backup:
z Log all the data at upstream nodes
z Queue trimming by eliminating data that cannot 
contribute to the current state
z Need to find the earliest data item that contributed 
to the current state
52
Tutorial Outline
z Basics
z How to model time
z Data stream query languages and processing 
models
z STREAM and CQL
z Cayuga
z Fault tolerance
z New operators
z Change detection
z A Case Study
Types of Change
z Transient change.
z Bursts in a datastream (later talk)
z Specific patterns (intrusion detection).
z Particular sequence of data.
z Change in mean or variance.
z Long-term change of unknown character.
z Change in distribution.
z Power/generality.
53
Model for Long-term Change
z X1, X2, X3, ...
z Xi ~ Di
z Xi are independent random variables
z Detect when 
D1=D2= ... Di Di+1=Di+2=...
z Two sample case, 
z S1={Y1,...,Yn}~Da, S2 ={Z1,...,Zm} ~Db
z Continuous/Discrete distributions.
≠
Reduction to Two Samples
z Given a stream:
X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11 , X12 ...
z Reference window and sliding window.
X1, X2, X3, X4, X5, X6, X7, X8 ...
54
Reduction to Two Samples
z Given a stream:
X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11 , X12 ...
z Reference window and sliding window.
X1, X2, X3, X4, X5, X6, X7, X8, X9 ...
Reduction to Two Samples
z Given a stream:
X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11 , X12 ...
z Reference window and sliding window.
X1, X2, X3, X4, X5, X6, X7, X8, X9, X10 ...
55
Reduction to Two Samples
z Given a stream:
X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11 , X12 ...
z Reference window and sliding window.
X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11 ...
Reduction to Two Samples
z Given a stream:
X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X12 ...
z Reference window and sliding window.
X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X12 ...
z Compare samples from reference and sliding 
window to see if they came from the same 
distribution.
z Large windows for slow, subtle change.
z Small windows for quick, short change.
z Copies of algorithm running in parallel using 
different window sizes.
56
Reduction to Two Samples
z Given a stream:
X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X12 ...
z Reference window and sliding window.
X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X12 ...
zWhen we detect a change the window 
tumbles:
... X12, X13, X14, X15, X16, X17, X18, X19, X20, X21, X22,  ...
Back to Streams
z Solution for two-sample case must scale 
to data steam model.
z Three issues:
z Execution time per stream element
z Robustness to multiple testing problem
z Easy explanation of change
57
Execution Time Per Stream Element
z Incremental addition and deletion of 
elements in O(1) or O(log w) time, where 
w is the window size
Multiple Testing Problem
z Given a stream:
X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11 , X12 ...
z Reference window and sliding window.
X1, X2, X3, X4, X5, X6, X7, X8 ...
58
Multiple Testing Problem
z Given a stream:
X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11 , X12 ...
z Reference window and sliding window.
X1, X2, X3, X4, X5, X6, X7, X8, X9 ...
Multiple Testing Problem
z Given a stream:
X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11 , X12 ...
z Reference window and sliding window.
X1, X2, X3, X4, X5, X6, X7, X8, X9, X10 ...
59
Multiple Testing Problem
z Given a stream:
X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11 , X12 ...
z Reference window and sliding window.
X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11 ...
Simple Explanation of Change
Sample 1
(reference 
window)
Sample 2
(sliding 
window)
0    1    2    3    4    5    6  
60
Simple Explanation of Change
z User might be interested in a collection A of regions 
of the input space.
z Intervals of the form: [a, b]
z Initial segments: (-∞, b]
z Regions as queries
z Count number of points in this area.
z Estimate probability of this area.
z Point out region C∈A with most significant change in 
probability (or top K).
z Compare: Decision trees with axis-orthogonal splits 
versus DTs with linear splits
Algorithm
z Regions:
z Initial segments (-∞, a]
z Incremental maintenance by keeping tuples in 
window sorted in-memory
z Comparison function:
)}()(2),()(min{
)|()(|
2121
12max
cFcFcFcF
cFcF
−−+
−=φ
|)()(|max 12 cFcF −
61
Tutorial Outline
z Basics
z How to model time
z Data stream query languages and 
processing models
z Fault tolerance
z New operators
z Change detection
z A Case Study
A Case Study: Implementing Cayuga
z Issues:
z Efficiently implementing automata-based 
processing model
z How to efficiently index queries 
z How to handle events with the same 
detection time
z Memory management
62
Architecture of the NFA Engine
...
incoming
event streams
priority queue
(by timestamp)
delivered
events
Engine manages
state transitions,
event delivery
Automaton States
z Instance record contains stored data 
for a (nondeterministic) instance of the 
state
z All instances of a state have the same 
schema (known at query compile time)
Instance records
Q
63
Automaton Edges
z S identifies a stream of incoming events
z θ is a selection predicate on Schema(Q) X 
Schema(S)
z f is the instance map:
z Schema(Q) X Schema(S) Æ Schema(Q’)
Q Q’
Automaton Edges II
z All edges leaving a given state Q have 
the same stream S
z θ and f are compiled code for an 
interpreter we designed for this purpose
Q Q’
64
Optimization Goals
z Minimize
z # automaton states
z # instance records / state
Æ Merging techniques (states and 
instances) 
z Quickly find
z states affected by an input event
z edges that are traversed
State Merging
z Roughly: two states are equivalent if they have 
identically labeled entering edges from 
equivalent states
65
State Merging
z Start states are equivalent ...
State Merging
z Now the next pair are equivalent, 
inductively ...
z But the next two are not (under the 
assumption that (S2, θ3, f3) and (S2, θ4, f4)      
are distinct) 
66
Instance Merging
z Event e arrives on S, traverses edges 
from Q1 and Q2, both can produce 
equal instance records at Q3!
a
b
c
c
Q1
Q2
Q3
Q1
Q2
Q3
Instance Merging II
z Clearly we want to merge instances if we can do it 
efficiently ... indexing (later) helps!
z Can yield exponential reduction in number of 
instance records
z Similar to dynamic programming or function 
caching
2c
Q1
Q2
Q3
No loss of information
67
Indexing
z Index maps event to set of predicates that 
are satisfied by it
z essentially a standard pub/sub engine
z Choice: static or dynamic predicates
z Static
z easy to maintain
z conservative approximation
z Dynamic
z precise
z high update rate as instances change
Indexing: Affected Nodes
z A node is affected if at least one instance does 
not traverse a filter edge
z for most input events, most nodes are not affected!
z nodes that are unaffected require no processing at 
all
z Construct index that yields (approx) the nodes 
affected by input event
z e.g. can use static part of predicate
z Global index per input stream
68
Indexing: Forward/Rebind
z Conceptually ...
z maps an event to (approx) the set of instance-
edge pairs that satisfy it
z In Cayuga engine
z global index (static parts of predicates) 
produces candidate edges
z per-node index produces candidate instances
z join the two results, testing predicates
FR Indexing II
selected by
per-node
instance index
selected by
global
edge index
Join the sets together
and check predicate
satisfaction
69
Simultaneous Events
z When two events arrive simultaneously 
(identical detection timestamps) neither 
should “see” the effect of the other ...
a b c
b generated from a by event 
arriving at time t c generated from b by event
arriving at the same time t
This is unsound!
Simultaneous Events Correctly
z Accumulate all new instances generated 
at a given arrival time in “pending 
instance” lists
z Install them atomically when clock ticks
a
b
a
b
c
d
e
c
d
e
70
Aggregation of Pending Instance Lists
z Apply an aggregate computing function f
to pending instances at installation time
z A “spatial” aggregate at a point in time
a
b
a
b
c
d
e
f
gf(.)
Application to Resubscription
z Recall resubscription treats the output of 
an automaton final state as another input 
stream ...
z Just treat instances added to the pending 
list of a final state as if they were new 
events!
71
Resubscription
... incoming
event streams
priority queue
(by timestamp)
delivered
events
A
A
A
resubscription
events
Resubscription
z It was a problem before we figured out 
how to do it correctly!
z Now
z Gives us expressiveness of the entire stream 
algebra
z Common subexpression elimination
z Dynamically disable resubscription states
z Note: This will be harder once we 
distribute Cayuga across a cluster
72
Resubscribing to Common Subexpressions
z Common subexpressions where 
states P and Q are not equivalent ...
P
Q
Common Subexpressions II
z Convert to
P Q
A A
A
73
Common Subexpressions III
z When neither P nor Q is occupied, states of 
the resubscription machine (determined by 
static analysis) can be disabled. 
P Q
A A
A
In Summary: We Covered …
z Basics
z How to model time
z Data stream query languages and processing 
models
z STREAM and CQL
z Cayuga
z Fault tolerance
z New operators
z Change detection
z A Case Study
74
Concluding Remarks
There is money in data stream processing!
z How much?
z Low stream rate: The dinosaurs of the 
marketplace will grab this space
z Integrate full functionality of the existing engine
zScalable triggers
zExample: Work by Dieter Gawlick’s group at 
Oracle
z High stream rate: The startups are battling it 
out
zThey have many more programmers than a 
university/research lab
Concluding Remarks
zWhat could we researchers work on?
z Foundational issues
z Uncertainty, imperfection
z XML
z Scaling across a cluster
z Semantically rich operators
z Motivate your work by a real application 
scenario
z Build the system!
75
Thank you!
Cornell:
Alan Demers, Mingsheng Hong, Dan Kifer, 
Mirek Riedewald, Walker White
Stanford:
STREAM Team, Jennifer Widom
Microsoft:
Roger Barga, Jonathan Goldstein
Questions?
johannes@cs.cornell.edu
http://www.cs.cornell.edu/johannes
