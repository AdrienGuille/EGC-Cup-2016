Construction Incrémentale de Graphes de Voisinage avec
Accès Réduit aux Disques
Hakim Hacid∗, Tetsuya Yoshida∗∗
∗Alcatel-Lucent Bell Labs France
Centre de Villarceaux Route de Villejust, 91620 Nozay, France
hakim.hacid@alcatel-lucent.com,
∗∗Hokkaido University,
Graduate School of Information Science and Technology,
N-14 W-9, Sapporo 060-0814, Japan
yoshida@meme.hokudai.ac.jp
Résumé. La recherche efficace de voisinage dans un espace multidimension-
nel a été étudiée dans plusieurs domaines tels que la reconnaissance de formes
et l’exploration de données. Les graphes de voisinage sont des structures géo-
métriques basées sur le concept de proximité des éléments de données, et ils
peuvent être utilisés pour déterminer les plus proches voisins de données mul-
tidimensionnelles. Le problème est que, outre la construction couteuse de ces
graphes, leur mise à jour est aussi difficile en raison de l’insertion ou la sup-
pression d’un élément. Dans cet article nous proposons d’adapter les graphes de
voisinage pour l’indexation de plus grandes quantités de données multidimen-
sionnelles. Nous proposons une modification d’une méthode existante de mise à
jour locale de graphes de voisinage de telle sorte à ce qu’elle puisse considérer
des accès réduits aux disques afin de prendre en compte l’évolution des bases de
données. Cette proposition est étendue pour faire de la construction incrémen-
tale de graphes de voisinage. Des évaluations de l’approche ont été effectuées et
les résultats montrent que notre approche est prometteuse.
1 Introduction
Une des exigences pour traiter des données multidimensionnelles à grande échelle telles
que des données multimédias, des données temporelles, des données spatiales, etc., est de
fournir une solution efficace pour rechercher le voisinage. En plus de l’hétérogénéité des don-
nées, leur grande quantité et leur haute dimensionnalité rendent cette tache de recherche assez
difficile. Rechercher le voisinage efficacement est une question clé dans le traitement auto-
matique de données multidimensionnelles. Divers algorithmes et techniques dans différents
domaines de recherche ont été proposés. Par exemple, k-means (MacQueen (1967)), Cartes
de Kohonen (Somervuo and Kohonen (1999)), et k-NN sont des solutions largement utilisées
dans l’exploration de données ou dans la majorité des techniques d’indexation de bases de
données (Gaede and Günther (1998)).
Construction Incrémentale de Graphes de Voisinage avec Accès Réduits aux Disques
Parmi les modèles proposés pouvant faire face au probléme de la recherche de voisinage
dans un espace multidimensionnel, les graphes de voisinage (Preparata and Shamos (1985);
Toussaint (1980); Gabriel and Sokal (1969)) sont illustratifs. Cependant, outre la construction
de graphes de voisinage, leur mise à jour, en raison de l’insertion ou la suppression d’éléments
de données, peut aussi devenir coûteuse. Une méthode de mise à jour locale a été proposée
dans (Hacid and Zighed (2005)) pour atténuer ce problème. Cette méthode construit une hyper-
sphère pouvant localiser les données pouvant être concernées par la mise à jour du graphe.
Toutefois, ce travail n’a pas explicitement adressé le cas où la taille des données devient très
importante. Ce problème est d’autant plus important que les données ne rentrent pas forcément
en mémoire centrale, nécessitant aussi des accès disques supplémentaires pouvant réduire le
rendement de la méthode ainsi proposée. Il est donc nécessaire de réduire les accès aux disques
pour garantir un certain niveau de qualité dans la mise à jour, voire dans la construction du
graphe.
Nous proposons dans ce travail d’utiliser un graphe de voisinage comme une structure d’in-
dexation d’une base de données multidimensionnelle. Pour faire face à des masses de données
qui dépassent la taille de la mémoire principale, nous construisons un graphe de voisinage pour
un jeu de données et nous chargeons uniquement la structure du graphe, et non l’ensemble
des données, dans la mémoire principale. Sur la base de cette structure, nous proposons (i)
une modification de la méthode de mise à jour locale du graphe de voisinage de sorte à ce
qu’elle puisse prendre en compte l’accès réduit aux disques, et (ii) une méthode incrémentale
de construction de graphes de voisinage intégrant un accès réduit aux disques. Afin de réduire
les accès aux disques, nous définissons et utilisons une limite supérieure pour la méthode pro-
posée dans (Hacid and Zighed (2005)) dans la construction d’une hyper-sphère pour situer la
mise à jour. Nous avons en outre élaboré des mécanismes pour faire face à plusieurs problèmes
avec la borne supérieure, et proposé d’autres limites pour la méthode de mise à jour. Plusieurs
évaluations ont été menées pour évaluer l’approche proposée et les résultats des expériences
montrent l’intérêt de notre approche.
Le reste de cet article est organisé comme suit : la Section 2 introduit brièvement différents
types de graphes de voisunage. La Section 3 décrit les problèmes des approches existentes, et
détaille la méthode proposée pour réaliser la mise à jour locale avec accès limités aux disques.
Les évaluations sont rapportées dans la Section 4. Enfin, nous concluons et présentons quelques
perspectives dans la Section 5.
2 Graphes de voisinage pour la recherche de voisinage
La recherche de voisinage est largement utilisée dans les systèmes de gestion de bases
de données pour effectuer un prétraitement des données afin de localiser les données les plus
proches les unes des autres. Ainsi, une fois ce voisinage identifié, il devient facile d’interroger
et retrouver des données lors d’une recherche d’informations par exemple.
2.1 Notations et définitions
Tout au long de cet article, nous utiliserons des lettres en majuscule gras pour dénoter les
ensembles d’objets (données). Soit V un ensemble d’objets dans un espace à p-dimensions
H. Hacid, T. Yoshida
R
p où R représente l’ensemble des nombres réels. Pour un ensemble V , |V | représente sa
cardinalité.
Un graphe G(V ,E) consiste en un ensemble de nœuds V et un ensemble d’arrêtes E
définies surV ×V . L’ensembleE peut être interprété comme une représentation d’une relation
binaire sur l’ensemble V . Un couple de nœuds (vi, vj) est une relation binaire définie par le
graphe G(V ,E) si et seulement si la paire (vi, vj) ∈ E. Intuitivement, chaque individu est
traduit en nœud dans le grapheG et une paire de noeuds (vi, vj) est dansE si et seulement si ils
sont directement connectés par un lien dans le graphe. La fonction N(v) retourne l’ensemble
des nœuds connectés au nœud v ∈ V . Formellement, N(v) = {w|w ∈ V ∧ (v, w) ∈ E}.
Nous considérons que la fonction de distance
d : V × V → R+ ∪ {0} (1)
peut être spécifiée pour les données à traiter en se basant sur sur une mesure de distance (Toussaint
(1991)). Dans ce qui suit, nous considérons que la fonction de distance d est spécifiée et nous
y référons explicitement comme d dans la suite du manuscrit.
Les graphes de voisinage, ou graphes de proximité, sont des structures géométriques
qui sont définies en se basant sur la proximité mutuelle entre une paire d’objets. Formellement,
une fonction de proximité fprox : V ×V → {1, 0} est définie par rapport aux caractéristiques
des données à traiter et le type du voisinage considéré.
Definition 1 (Graphe de voisinage) Supposons un ensemble de données V et une fonction
de proximité fprox : V × V → {1, 0}. Un graphe de voisinage G(V ,E) pour V est défini
comme suit :
(vi, vj) ∈ E Ssi fprox(vi, vj) = 1 (2)
pour toute paire de nœuds vi, vj ∈ V , vi 6= vj .
Intuitivement, une paire de nœuds (vi, vj) forme une arête dans le graphe de voisinageG(V ,E)
pour l’ensemble V si les nœuds respectent la contrainte de proximité qui est représentée par
fprox.
2.2 Exemple de graphe de voisinage
Même pour le même ensemble de données V , nous pouvons définir différents types de
graphes de voisinage en utilisant différentes fonctions de proximité. Nous introduisons dans ce
qui suit les définitions suivantes.
Definition 2 (Hyper-sphère H(vi, vj)) Une hyper-sphère dans Rp, centerée sur vi avec un
rayon r = d (vi, vj), est dénotée par H(vi, vj). Pour tout objet w inRp,
w ∈ H(vi, vj) Ssi d(vi, w) ≤ r (3)
Nous pouvons considérer d’autres types de régions pour une paire de nœuds dans V . Par
exemple, nous pouvons considérer une “lunule” comme suit :
Construction Incrémentale de Graphes de Voisinage avec Accès Réduits aux Disques
x
y
vi vj
FIG. 1: Un exemple d’un graphe de voisins relatifs dans un plan.
Definition 3 (Lunule A(vi, vj)) Pour tout vi, vj ∈ Rp, une lunule A(vi, vj) inRp est définie
comme l’intersection de deux hyper-sphères H(vi, vj) et H(vj , vi). Formellement :
A(vi, vj) = H(vi, vj) ∩H(vj , vi) (4)
Pour tout individu w dans Rp, w est à l’intérieur de la lunule A(vi, vj) si et seulement si
(d(vi, w) ≤ d(vi, vj)) ∧ (d(vj , w) ≤ d(vi, vj)) .
En considérant la définition précédente d’une lunule, nous pouvons ainsi considérer un
autre type de graphes de voisinage appelé “le graphe des voisins relatifs” (RNG)
(Jaromczyk and Toussaint (1992)).
Definition 4 (Graphe des voisins relatifs) Pour un ensemble de données V et une fonction
de distance spécifiée d, un graphe de voisins relatifs est défini en se basant sur la fonction de
proximité suivante : fRNG : V × V → {1, 0}
fRNG(vi, vj) =
{
1 A(vi, vj) ∩ V = φ
0 sinon
(5)
Ainsi, un individu vi ∈ V est voisin d’un autre nœud vj ∈ V dans un RNG si et seulement
si aucun autre nœud dans V n’est à l’intérieur de la lunule A(vi, vj). La Figure 1 illustre un
exemple d’un graphe de voisins relatifs dans un espace bi-dimensionnel.
2.3 Principe des algorithmes de construction des graphes de voisinage
Plusieurs algorithmes pour la construction des graphes de voisinage ont été proposés. Les
algorithmes que nous citons ci-après concernent la construction du graphe des voisins relatifs
étant donné que c’est la structure principale dans nos travaux. L’une des approches communes
aux différents algorithmes est l’utilisation des techniques de raffinement. Dans ce type d’ap-
proches, le graphe est construit par étapes. Chaque graphe est construit à partir d’un graphe
précédent, contenant toutes les connexions, en éliminant un certain nombre d’arêtes qui ne vé-
rifient pas la propriété de voisinage du graphe à construire. L’élagage (élimination des arrêtes)
se fait généralement en tenant compte de la fonction de construction du graphe ou à travers des
propriétés géométriques.
H. Hacid, T. Yoshida
Le principe de construction des graphes de voisinage consiste à chercher pour chaque point
si les autres points de l’espace sont dans son voisinage. Le coût de cette opération est d’une
complexité de O(n3)(n étant le nombre de points dans l’espace). Toussaint (Toussaint (1991))
a proposé un algorithme de complexité O(n2). En utilisant les voisins géographiques (Oc-
tant neighbors), (Katajainen (1988)) a proposé également un algorithme de complexité O(n2).
Smith (Smith (1989)) a proposé un algorithme de complexité O(n23/12).
Ces algorithmes sont de moindre complexité comparés à l’algorithme standard (< O (n3)
). Toutefois, ces derniers se concentrent sur la construction globale du graphe. C’est pourquoi
ces algorithmes ne supportent pas et n’offrent pas des opérations d’insertion et de suppression
de points dans le graphe. Or, ces opérations sont vitales pour une structure d’indexation, c’est
pour cela que ces algorithmes ne sont pas non plus souhaitables pour l’utilisation du graphe
comme structure d’indexation.
Ainsi, étant donné qu’un index de données modernes doit supporter beaucoup d’interac-
tions, traduites par des insertions, des suppressions et des interrogations fréquentes, nous pro-
posons dans ce qui suit des algorithmes capables de prendre en considération ces interactions,
tout en préservant les propriétés initiales du graphe nécessaires pour l’application de techniques
de data mining.
3 Construction de graphes avec un accès réduit aux disques
Avant de présenter et de discuter la proposition de cet article, nous allons tout d’abord faire
un rappel de l’approche initiale de mise à jour locale de graphes de voisinage basée sur le
repérage des individus potentiellement concernés par l’opération de mise à jour.
3.1 Approche initiale de mise à jour locale
L’approche initiale de mise à jour locale de graphes de voisinage (Hacid and Zighed (2005))
construit un graphe de voisinage G(V ,E) en se basant sur la localisation de l’individu inséré
ainsi que les arêtes potentiellement affectées par l’insertion. Cette méthode réalise ceci en deux
étapes principales :
1) déterminer une région dansRp (une hyper-sphère SR avec un rayon r centrée sur l’individu
inséré q) qui contiendrait potentiellement les objets les plus proches de q.
2) calculer la mise à jour de G et appliquer les modifications sur E.
L’hyper-sphère dans (1) est formalisée comme suit :
Definition 5 (Hyper-sphère SR(q, r)) Une hyper-sphère SR(q, r) est définie comme celle
centrée sur q ∈ Rp avec un rayon r. pour tout objet w inRp,
w ∈ SR(q, r) ssi d(q, w) ≤ r (6)
Le rayon r de l’hyper-sphère SR est déterminé de telle sorte que tous les voisins du plus
proche voisin de q soient inclus dans SR. La mise à jour de E est conduite ensuite dans (2)
entre les individus récupérés via la phase précédente.
Construction Incrémentale de Graphes de Voisinage avec Accès Réduits aux Disques
Le rayon et l’hyper-sphère pour une requête q sont déterminés comme suit (Hacid and Zighed
(2005)). Soit vq1 le plus proche voisin de q, et soit vq2 le voisin le plus éloigné de vq1 avec
leurs distances respectives. Ainsi, le rayon rnf est défini comme suit :
d1 = d(q, vq1) (7)
d2 = d(vq1, vq2) (8)
r = (d1 + d2)(1 + ǫ) (9)
où ǫ ∈ [0, 1] est un paramètre de relaxation qui peut être initialisé en fonction de la connais-
sance des données (la dispersion par exemple) ou en se basant sur la connaissance du domaine.
Dans ce qui suit, les valeurs concrètes de r et de SR sont représentées en utilisant les suffixes
adéquats comme : rnf et SRnf .
La complexité de la méthode proposée dans (Hacid and Zighed (2005)) est de O(n+ n′3)
où n(=|V |) est le nombre d’objets dans la base de données, n′ est le nombre d’objets dans
SRnf (n′ ≪ n). Les termes correspondent à : 1) la recherche du rayon rnf de SRnf , qui né-
cessite O(n), et 2) l’ajout et la suppression d’arêtes SRnf , qui nécessite O(n′3). Le deuxième
terme correspond au temps requis pour la mise à jour de E dans SRnf . Le traitement de (2)
est réalisé selon la méthode standard de construction de graphes de voisinage.
Dans cet article, nous appelons la fonction LocalInsert(G(V ,E),q,ǫ) la méthode prposée
dans (Hacid and Zighed (2005)). Elle retourne un graphe en insérant un élément de la requête
q dans G(V ,E) avec le paramètre ǫ. Plusieurs expériences ont été menées et les résultats
vérifient que LocalInsert (G(V ,E),q, ǫ) construit le graphe correctement pour les données
en question, i.e. V et q (Hacid and Zighed (2005)).
Le problème majeur de l’approche précédente est qu’elle procède en essayant de trouver
tout d’abord le plus proche voisin vq1 pour un élément requête q en vérifiant tous les objets.
Lorsqu’on est en présence d’une grosse grosse masse de données, cela peut aussi prendre
beaucoup de temps. Ainsi, il est souhaitable de réduire le nombre d’accès aux disques pour
supporter l’évolution de la mise à jour. La section suivante décrit notre solution pour traiter ce
problème.
3.2 Passage à l’échelle avec réduction des accès disques
Avec la quantité de plus en plus croissante des données disponibles dans les bases de don-
nées, une méthode d’indexation doit prendre en considération l’aspect accès disques. Les mé-
thodes d’insertion et de suppression locales telles qu’elles ont été présentées dans la section
précédente sont efficaces pour la mise à jour locale et la construction rapides d’un graphe
de voisinage. Toutefois, quand la masse de données est trop importante, les performances de
ces méthodes peuvent être affectées. Pour permettre à ces méthodes d’offrir de bonnes per-
formances lorsque nous traitons de grandes bases de données, il est nécessaire de réduire au
maximum leur dépendance de la taille globale de ces dernières. Ainsi, nous allons présen-
ter dans ce qui suit d’autres améliorations visant à rendre ces méthodes les moins dépendantes
possible de la base de données. Pour cela, nous nous basons sur le calcul de certains indicateurs
statistiques sur l’ensemble du graphe.
Le problème auquel nous voulons faire face ici est le cas où la taille des données est très
importante et que celles-ci ne tiennent pas en mémoire centrale. Pour cela, il est important et
H. Hacid, T. Yoshida
nécessaire de considérer l’accès aux données sur les mémoires secondaires qui est générale-
ment une opération très coûteuse comparée aux accès à la mémoire centrale.
FIG. 2: Illustration du principe général de la réduction des accès disques
Dans la Figure 2, les données de la base de données sont représentées de manière com-
pacte sous forme de graphe de voisinage. En plus du calcul et du stockage du graphe, nous
calculons aussi deux indicateurs statistiques représentés par les colonnes dmin et dmax. Ces
deux colonnes calculent la distance minimale (resp. maximale) entre chaque individu v donné
et tous ses voisinsN(v) dans le graphe G(V ,E). Ces deux paramètres sont calculés pour une
utilisation ultérieure. La colonne d(q, v) est utilisée, quant à elle, pour stocker la distance d’un
point requête (à son arrivée dans le système) par rapport à tous les individus de la base de
données. Les autres indicateurs sont calculés indépendamment de la requête.
A l’arrivée d’un point requête, les valeurs de la colonne d(q, v) sont calculées pour une
utilisation ultérieure. Il est nécessaire à ce niveau d’accéder à la base de données pour effectuer
ces calculs. Toutefois, une fois cette distance calculée, il n’est plus nécessaire d’accéder à la
base de données et il suffira ainsi d’utiliser la structure ainsi stockée en mémoire pour des
traitements ultérieurs.
3.2.1 Insertion locale dans un graphe avec un accès réduit aux disques
Comme cela a été mentionné plus haut, la méthode d’insertion locale dans sa version ini-
tiale nécessite deux accès à la base de données (représentés par le paramètre 2n dans l’expres-
sion de sa complexité). Le premier accès est nécessaire pour repérer le plus proche voisin du
point requête, tandis que le deuxième sert pour la recherche des individus contenus dans l’hy-
per sphère SR. Quand la taille de la base de données augmente, ceci peut avoir un effet négatif
sur les performances de la méthode, c’est pourquoi la réduction de ces accès est nécessaire.
Pour atteindre cet objectif, nous utilisons des limites (supérieures et inférieures) pour dé-
terminer le rayon de l’hyper sphère. L’idée est la suivante : en construisant le grapheG(V ,E),
en plus de la structure du graphe, nous récupérons aussi deux valeurs : d¯min représentant la
plus grande distance entre un point et son plus proche voisin dans toutes les connexions du
graphe 1, et d¯max représentant la plus grande distance entre un point et son plus loin voisin
1. Cette valeur constitue ainsi une borne supérieure de d1 dans la formule du rayon de la formule 7.
Construction Incrémentale de Graphes de Voisinage avec Accès Réduits aux Disques
dans toutes les connexions du graphe 2. Formellement, nous aurons :
d¯min = argmax
vi∈V
argmin
vj∈N(vi)
d(vi, vj) (10)
d¯max = argmax
vi∈V
argmax
vj∈N(vi)
d(vi, vj) (11)
A partir de cette définition, nous pouvons extraire les propriétés servant de correspondance
entre les paramètres de la méthode de base en ayant un point requête en entrée. Ces propriétés
sont présentées ci-après :
Property 1 ∀vi, vj ∈ V, vi 6= vj ,
d1 = d(q, vq1) ≤ d¯min (12)
d2 = d(vq1, vq2) ≤ d¯max (13)
En nous basant sur cette propriété, nous pouvons redéfinir le rayon de l’hypersphère déli-
mitant l’espace de recherche. En intégrant ces nouveaux paramètres, l’équation est la suivante :
rd¯ = (d¯min + d¯max)(1 + ǫ) (14)
En faisant toujours un parallèle avec la méthode de base et en considérant la définition de
rd¯ dans l’équation (14), la propriété suivante est alors vérifiée :
Property 2 ∀q ∈ V ,
rnf = (d1 + d2)(1 + ǫ)
≤ (d¯min + d¯max)(1 + ǫ) = rd¯ (15)
En utilisant d¯min et d¯max, nous pouvons calculer rd¯, qui peut être considéré comme une
borne supérieure pour rnf pour tout q ∈ V , et construire ainsi l’hypersphère SRd¯ avec rd¯
centrée dans q. Ainsi, à partir de la définition de SRd¯, nous pouvons avoir la propriété suivante :
Property 3
SRnf ⊆ SRd¯ pour ∀q ∈ V.
A partir de là, étant donné qu’il n’est plus nécessaire de rechercher le plus proche voisin
vq1 du point requête q ∈ V (et par conséquent le plus loin voisin vq2), nous pouvons alors
supprimer un accès au disque. La complexité de la méthode basée sur d¯min et d¯max peut alors
être exprimée comme suit :
O(n+ n′3d¯ ) (16)
où n = |V | et nd¯ est le nombre d’individus dans SRd¯.
En nous basant sur les propriétés précédentes, nous pouvons alors émettre la proposition
suivante :
2. Cette valeur constitue ainsi une borne supérieure de d2 dans la formule du rayon de la formule 8.
H. Hacid, T. Yoshida
Proposition 1 Vu que la méthode initiale d’insertion locale peut construire un graphe de voi-
sinage correct et mettre à jour le voisinage correctement, la nouvelle méthode basée sur les
SRd¯ peut aussi construire un graphe correct pour q ∈ V .
Preuve A partir de la propriété 3, tous les individus se trouvant dans SRnf sont aussi
contenus dans SRd¯, ∀q ∈ V . Ainsi, vu qu’il est suffisant de mettre à jour le voisinage à
l’intérieur de SRnf centrée sur q, la méthode basée sur SRd¯ est aussi suffisante pour mettre à
jour correctement le graphe en mettant à jour le voisinage entre les individus dans SRd¯ centrée
dans q.
Les Figures 3 et 4 illustrent la nouvelle méthode basée sur d¯min et d¯max.
FIG. 3: La première phase dans la nouvelle méthode de mise à jour locale
FIG. 4: La seconde phase dans la méthode de mise à jour locale qui applique la mise à jour
uniquement à l’intérieur de l’hypersphère.
3.2.2 Problème associé à la nouvelle méthode de mise à jour locale
La méthode proposée ci-dessus est intéressante et rapide en supprimant un accès à la mé-
moire secondaire qui est une opération coûteuse en terme de temps de calcul. Toutefois, il y
a une situation où cette méthode, opérant toute seule, ne peut pas mettre à jour correctement
le graphe de voisinage. Ce problème est illustré dans les figures 5 et 6. Ainsi, cette utilisa-
tion naïve de la méthode peut insérer correctement un individu dans le graphe G(V,E) pour
un point requête q 6∈ V si rnf ≤ rd¯. Toutefois, pour un individu q 6∈ V avec rnf > rd¯,
SRd¯ ∩ V = φ et la méthode ne peut donc pas localiser l’individu et les relations de voisinage
à mettre à jour.
Construction Incrémentale de Graphes de Voisinage avec Accès Réduits aux Disques
FIG. 5: Le graphe initial sur lequel d¯min et d¯max sont calculées.
FIG. 6: Une nouvelle requête q est insérée dans G. Si d(q, v) > d¯, ∀v ∈ V , SRd¯ ∩ V = φ et
donc G ne peut être mis à jour correctement en utilisant uniquement SRd¯.
Les problèmes cités précédemment peuvent survenir car les différentes propriétés et pro-
positions se vérifient pour les requêtes q ∈ V , et même pour (q 6∈ V et rnf ≤ rd¯). Cette
proposition ne peut toutefois pas être vérifiée pour une requête q 6∈ V en général. Ceci est dû
au fait que rnf peut être plus large que rd¯ pour un nouveau point quelconque q 6∈ V .
Pour résoudre ce problème nous proposons donc de combiner SRd¯ pour G(V,E) et SRnf
(dans LocalInsert(G(V,E),q,ǫ)) de telle sorte que le cas où SRd¯ ∩ V = φ peut être pris en
compte. Dans cette nouvelle approche, la méthode basée sur d¯ est privilégiée et est utilisée
quand SRd¯ ∩ V 6= φ. Dans le cas où SRd¯ ∩ V = φ, la méthode initiale est invoquée.
Un autre problème susceptible d’être rencontré lors de l’utilisation de SRd¯ est que d¯min
et d¯max peuvent être une estimation trop large de d1 et d2, i.e., rnf ≪ rd¯ et donc |SRnf | ≪
|SRd¯|. Il peut arriver surtout que |SRd¯| ≃ |V |. Ceci signifie que l’utilisation de l’hyper sphère
SRd¯ s’avère inefficace pour localiser la zone à mettre à jour dans un graphe de voisinage pour
un point requête q donné.
Pour apporter une solution à ce problème, nous utilisons SRd¯ pour construire une hyper
sphère similaire à SRnf , et utilisons l’hyper sphère pour localiser la zone de mise à jour pour
le point requête q. La différence de la forme originale de SRnf dans LocalInsert(G(V,E),q,ǫ)
est que nous construisons l’hyper sphère uniquement en considérant les individus qui sont dans
SRd¯ et non pas dans toute la base de données V . Ainsi, du moment que SRd¯ ⊆ V se vérifie, il
est garanti que le nombre de points vérifiés pour la construction de l’hyper sphère est plus petit
H. Hacid, T. Yoshida
Algorithm 1 LocalInsertdmax (G(V,E),q,d¯min,d¯max,ǫ) basé sur d¯min et d¯max
Require: G(V,E) ;
Require: q ; //Le point requête à insérer.
Require: d¯min ;
Require: d¯max ;
Require: ǫ ; //Le paramètre de relaxation
1: rd¯ = (d¯min + d¯max)(1 + ǫ) ;
2: Vd¯ = {v ∈ V |d(q, v) ≤ rd¯} ;
3: vq1 = Le plus proche voisin de q dans G ;
4: d1 = d(q, vq1) ;
5: vq2 = Le plus loin voisin de vq1 dans G ;
6: rnf = (d1 + d2)× (1 + ǫ) ;
7: if (Vd¯ 6= φ) then
8: V SR = {v ∈ V d¯| rnf > d(q, v)} ;
9: else
10: V SR = {v ∈ V | rnf > d(q, v)} ;
11: end if
12: Ajouter q à V ;
13: Mettre à jour E en utilisant la méthode standard seulement pour le sous graphe Gsub de G
(Gsub ⊆ G et Gsub est constitué de V SR et des arêtes correspondantes à V SR).
14: return G(V,E) mis à jour ;
que celui des points contenus dans toute la base de données. Par conséquent, les performances
sont réduites dans tous les cas.
La méthode que nous proposons, appelée LocalInsertdmax (G(V,E),q,d¯min,d¯max,ǫ), est
résumée dans l’Algorithme 1. Pour éviter l’augmentation de la complexité de la méthode pro-
posée, quand on accède aux données pour trouver les individus dans SRd¯ à la ligne 2, nous
récupérons aussi le plus proche voisin vq1 de q à la ligne 3. Nous procédons ensuite à la mise
à jour, à la ligne 10, seulement quand SRd¯ ∩ V = φ et ce sans accéder aux données encore
une fois pour trouver vq1. En outre, et comme cela a été décrit précédemment, les distances
calculées à la ligne 2 sont stockées et sont utilisées (lignes 8 et 10) pour éviter des calculs et
des accès inutiles.
Ainsi, les propriétés suivantes sont vérifiées pour cette nouvelle stratégie de mise à jour
locale.
Proposition 2 Les performances de LocalInsertdmax (G(V,E),q,d¯min,d¯max,ǫ) sont garanties
d’être équivalentes ou supérieures à celles de LocalInsert (G(V,E),q,ǫ).
Preuve
Par définition, étant donné que SRd¯ ⊆ V se vérifie, |SRd¯| ≤ |V |. Si SRd¯ ∩ V = φ alors
LocalInsertdmax (G(V,E),q,d¯min,d¯max,ǫ) est équivalente à LocalInsert (G(V,E),q,ǫ), et ses
performances sont alors équivalentes aussi à la première. D’un autre côté, si SRd¯ ∩V 6= φ, vu
que SRd¯ ⊆ V se vérifie, V SR à la ligne 8 dans l’algorithme 1 est plus petite que V SR à la ligne
10, qui est équivalente à l’hypersphère dans LocalInsert(G(V,E),q,ǫ). Ainsi, les performances
de la première sont équivalentes ou supérieures à la méthode initiale.
Construction Incrémentale de Graphes de Voisinage avec Accès Réduits aux Disques
Dans le pire des cas (seulement quand SRd¯∩V = φ), la complexité de la nouvelle méthode
est équivalente à celle de LocalInsert(G(V,E),q,ǫ). Toutefois, ce cas arrive uniquement quand
la requête spécifiée est située à l’extérieur de tous les points du graphe. Ce point peut être
considéré, à cet instant là, comme un point aberrant (outlier) par rapport à l’ensemble des
points de V . En plus de l’insertion locale, cette approche est étendue pour la construction
incrémentale des graphes.
3.2.3 Une heuristique pour l’amélioration de la suppression locale
Toujours dans un esprit de limitation de la dépendance des méthodes proposées par rapport
à la taille des bases de données, nous avons proposé d’améliorer aussi la méthode de suppres-
sion locale dans un graphe de voisinage. Nous proposons alors une nouvelle méthode, basée
certes sur une heuristique, mais totalement indépendante de la taille de la base de données.
Cette méthode est basée sur des observations que nous avons menées sur la structure glo-
bale des graphes de voisinage. L’idée est alors de supprimer la lecture faite par la méthode
initiale (représentée par O(n) dans O(n + n′3)). Pour cela, nous nous basons sur le concept
des couches de voisinage. En effet, nous avons émis l’hypothèse qui consiste à dire que, lors de
la suppression d’un point dans un graphe, les relations de voisinage pouvant être affectées sont
celles des voisins directs ainsi que celles de quelques couches liées à cette première couche de
voisinage (voir Figure 7).
FIG. 7: Illustration de l’heuristique de suppression locale.
Ainsi, l’idée ici est de pouvoir déterminer un nombre minimum de couches de voisinage
pouvant être impliquées dans la mise à jour, tout en assurant une mise à jour correcte. Nous
avons alors vérifié cette hypothèse par des expérimentations et des observations sur les graphes.
Nous avons conclu que notre hypothèse se vérifie en utilisant uniquement deux couches de voi-
sinage : soit vi ∈ V , le voisinage de vi est défini commeN(vi) = {vj ∈ V /vi 6= vj ∧ (vi, vj) ∈ E}.
Ainsi, N(vi) constitue la première couche de voisinage (i.e. points ayant une relation directe
avec le point vi). De ce fait, nous pouvons définir l’ensemble des points pouvant être affectés
par la suppression d’un point dans le graphe par la formule : N(N(vi)).
H. Hacid, T. Yoshida
3.3 Construction incrémentale du graphe avec un accès réduit aux disques
L’Algorithme 1 est basé sur un graphe initial avec lequel la mise à jour du graphe est
réalisée. Toutefois, que ce passerait-il s’il n’y a pas de graphe disponible pour la mise à jour ?
Etant donné que la méthode proposée est capable de mettre à jour la structureG(V ,E) tout en
conservant la propriété de voisinage, il semble assez aisé de la généraliser pour la construction
incrémentale de graphes de voisinage. Par exemple, considérons le graphe G(Vnew,E) où
Vnew = {v1, v2} et E = {(v1, v2)}, à chaque itération nous tirons un sommet v ∈ V et
l’ajoutons dans G à l’aide de l’Algorithme 1 et décrémentons V comme suit : V \{v}.
Cependant, cette méthode “naïve” ne peut pas construire les graphes de voisinage correc-
tement. Ceci est dû au fait que l’insertion d’un élément de données v dans G(V ,E) exige la
mise à jour de d¯min et d¯max pour les sommets insérés V ∪{v} en plus de la mise à jour deE.
Par ailleurs, une mise à jour naïve de ces bornes à chaque insertion d’un nouvel élément q en
calculant à chaque fois la distance d(q, v) pour ∀v ∈ V n’est pas acceptable, étant donné que
le traitement prend O(n) avec n = |V | pour chaque insertion.
Pour résoudre le problème pour le graphe courant G(V ,E), nous introduisons une autre
structure de données pour gérer l’ensemble des bornes deE. Cette structure de données stocke
l’ensemble des bornes de E par rapport à leur longueur de telle sorte que nous puissions tou-
jours obtenir la bonne limite pour les données actuelles V indépendamment de la suppres-
sion ou de l’insertion d’un noeud. La contrainte imposée sur la structure de données est que
toutes les bornes pour le graphe courant G(V ,E) doivent être triées (par ordre décroissant)
par rapport à leur longueur, et l’ordonnancement doit être conservé correct à chaque fois que
l’insertion ou la suppression de sommets se produit. Ceci peut être aisément réalisé en utilisant
un standard dans le commerce tel que B-arbre (Bentley (1975)).
Notre algorithme incrémental de construction de graphes de voisinage est résumé dans
l’Algorithme 2. Dans cet algorithme, sauf pour |V | < 2, E est initialisé avec une arête reliant
deux sommets, qui sont prélevés aléatoirement de V (lignes 4 à 9), et crée les structures de
données pour l’ensemble des arêtes E (ligne 10). Après cela, nous appliquons l’Algorithme 1
pour les données restantes dans V jusqu’à ce que V soit vide (ligne 15). Notons que d¯min et
d¯max sont obtenus en utilisant la structure (lignes 14 et 15) pour qu’ils soient ensuite mis à
jour (ligne 17). A la fin, l’algorithme retourne un graphe de voisinage correct correspondant à
l’ensemble V selon la propriété de voisinage spécifiée pour le graphe G.
Pour ce qui est de la complexité de IncNGCdmax(V , ǫ), celle ci peut être nettement plus
intéressante que celle de la méthode naïve. A chaque i-ème itération, la mise à jour des struc-
tures pour Ei peut être effectuée en O(log |Ei|). Supposons n′i = |viSR|(≪ ni = |vi|), où
Ei
SR est l’ensemble des arêtes de viSR à chaque i-ème itération. Ici, ni représente le nombre
de données qui figurent déjà dans le graphe de voisinageG à la i-ème itération, et n′i représente
la quantité de données localisées dans SRd¯. L’insertion (suppression) des arêtes EiSR dans la
structure nécessiteO(|EiSR| log |Ei|), vu que la hauteur de l’arbre dans les structures est pro-
portionnelle àO(log |Ei|) et le nombre d’arêtes à insérer est |EiSR|. De nos expérimentations
préliminaires (Hacid and Zighed (2005); Hacid and Yoshida (2007)), |E| est généralement li-
néaire à n(= |V |) 3, O(EiSR) peut être approché par O(ni).
En résumé, à chaque i-ème itération, IncNGCdmax(V , epsilon ) prend O(ni + n′i3)
pour la mise à jour d’un graphe de voisinage à l’aide de l’Algorithme 1, O(n′i log ni) pour la
3. En moyenne, |N(v)| = O(10) ∼ O(102) pour ∀v inV où |V | = O(103) ∼ O(104)
Construction Incrémentale de Graphes de Voisinage avec Accès Réduits aux Disques
Algorithm 2 IncNGCdmax (V ,ǫ) : Construction incrémentale de graphes de voisinage
Require: V ;
Require: ǫ ;
1: if |V | < 2 then
2: return G(V , φ) ;
3: else
4: v1 = a data item from V ;
5: v2 = another data item from V ; //v1 6= v2
6: V = V \{v1, v2} ;
7: Vnew = {v1, v2} ;
8: E = {(v1, v2)} ;
9: create DBd¯min and DBd¯max for E ;
10: for i = 3 to n do
11: vi = a data item from V ;
12: V = V \{vi} ;
13: d¯min = argmax
vi∈Vnew
argmin
vj∈N(vi)
d(vi, vj) ; //utilize DBd¯min for the calculation
14: d¯max = argmax
vi∈Vnew
argmax
vj∈N(vi)
d(vi, vj) ; //utilizeDBd¯max for the calculation
15: G(Vnew,E) = LocalInsertd¯(G(Vnew,E), vi, d¯min, d¯max, ǫ) ;
16: Update DBd¯min and DBd¯max based on the updated E ;
17: end for
18: end if
19: return G(Vnew,E) ; // Vnew should be equal to V
mise à jour de d¯min et d¯max. Ainsi, il faut O(∑ni=3[ni + n′i3 + (n′i log ni)]), au total, qui est
(nettement) plus faible que celle de la méthode naïve nécessitant O(∑ni=3[ni + n′i3]).
4 Evaluations
Comme décrit dans dans la Section 3, théoriquement, la méthode proposée a la propriété
de garantir certaines améliorations par rapport à la méthode précédente (Hacid and Yoshida
(2007)). Du point de vue de la validité, il est clair que la modification de la méthode (i.e.,
LocalInsertd¯) donne des résultats corrects comme indiqué précédemment. Cette partie ne
sera donc pas discutéé dans cette section. Ainsi, nous mettons l’accent sur l’évaluation des
performances de calcul, i.e., temps d’exécution, de l’approche proposée dans le but de l’illus-
trer et de la comparer avec d’autres approches. Les résultats seront discutés et décrits selon
les deux aspects suivants : (1) le temps d’exécution et le passage à l’échelle de la méthode
d’insertion locale modifiée ; (2) le temps d’exécution de la méthode de construction incré-
mentale. Notons que ces résultats sont également influencés par l’implémentation mise en
œuvre. Pour montrer les différences entre LocalInsertd¯ et le méthode proposée antérieu-
rement dans (Hacid and Yoshida (2007)), que nous appelons LocalInsert, les résultats sont
présentés sur le même graphique afin de faciliter leur compréhension et d’analyse.
H. Hacid, T. Yoshida
4.1 Configuration des évaluations
Etant donné que nous nous concentrons sur le temps de calcul pour gérer les ensembles de
données en fonction de leur taille, nous avons utilisé des ensembles de données synthétiques
avec la taille spécifiée dans les évaluations ci-dessous. Pour mener des comparaisons avec
notre approche précédente, nous avons suivi le même protocole d’évaluation que celui décrit
dans (Hacid and Zighed (2005)). Les temps d’exécution ont été mesurés sur une machine avec
un processeur de 1,8 GHz, 512 Mo de mémoire et un système Windows XP.
4.2 Passage à l’échelle de LocalInsertd¯
L’évaluation du passage à l’échelle se réfère au comportement des méthodes proposées
par rapport à la taille (ni) et la dimension p de l’ensemble de données. Nous avons généré
des séries de données artificielles ayant une dimension p = 250. Les ensembles de données
varient de 5×103 individus à 40×103, avec un intervalle de 2, 5×103. A chaque itération, 10
individus sont tirés aléatoirement de l’ensemble des données correspondantes, et réinsérés dans
le graphe. Les expérimentations ont été menées en considérant les situations où le sommet qui
doit être inséré dans un graphe de voisinage réside à l’intérieur du graphe. Pour chaque graphe
correct G(V ,E), un sommet v ∈ V est choisi aléatoirement V , et le graphe sans v (soit
G′(V \{v},E′)) est construit. Puis, v est inséré dans G′ en utilisant la méthode proposée. Le
temps d’exécution a été enregistré pour ce processus. Les résultats obtenus sont présentés dans
la Figure 8.
FIG. 8: Comparaison des temps d’exécution suivant deux stratégies.
4.3 Temps d’exécution de la construction incrémentale
Nous avons ensuite évalué le comportement de la construction incrémentale. L’idée est
simple : disposer d’un ensemble de données, appliquer des stratégies différentes pour construire
un graphe de voisinage et enregistrer les temps d’exécution. Comme dans la Section 4.2, nous
Construction Incrémentale de Graphes de Voisinage avec Accès Réduits aux Disques
avons généré des ensembles de données artificielles ayant une dimension p = 250 et une taille
de 5, 10, 20, 40, 50, 75, 100, 150×103. Nous avons comparé notre méthode de construction in-
crémentale (Algorithme 2) avec une autre version proposée dans (Hacid and Yoshida (2007))
et avec l’Algorithme de construction naïve (avec O(n3)). Les résultats obtenus sont illustrés
dans la Figure 9.
FIG. 9: Comparaison des temps d’exécution de trois approches
4.4 Discussions
La Figure 8 montre que les deux méthodes (LocalInsertd¯ et LocalInsert) est linéaire par
rapport à la taille des données. En outre, la Figure 9 montre que la construction de graphes de
voisinage fondée sur les méthodes supplémentaires est efficace comparée à l’approche naïve.
Toutefois, en ce qui concerne le temps d’exécution dans le monde réel, les résultats indiquent
que LocalInsertd¯ n’améliore pas la performance par rapport à LocalInsert.
Bien que la propriété théorique de l’Algorithme 1 indiquée dans la proposition 2, rd¯ peut
être une estimation très prudente pour rnf en fonction des caractéristiques de l’ensemble de
données. Ainsi, la taille de SRd¯ peut être assez grande pour garantir cette propriété. La loca-
lisation des données à traiter pour les mise à jour n’est pas encore suffisante à la ligne 2 de
l’Algorithme 1. En outre, les évaluations dans les Figures 8 et 9 ne prennent pas explicitement
en compte le coût (temps d’exécution) des accès disques, ce qui dépend de l’architecture de
la machine et le système d’exploitation utilisés. En particulier, l’accès aux disques se produit
lorsque la taille des données dépasse la taille de la mémoire principale : lorsque les données
traitées sont échangées avec l’espace de stockage secondaire et de nouveaux éléments de don-
nées sont échangés dans la mémoire. Ainsi, actuellement, il n’est pas clair dans quelle mesure
l’utilisation d’un graphe de voisinage en tant que structure d’indexation dans la mémoire prin-
cipale aide pour identifier le voisinage. Il serait nécessaire de mesurer le nombre d’accès disque
et le temps pris pour l’accès aux disques. Cela permettrait de clarifier l’effet de l’utilisation
d’un graphe de voisinage en tant que structure d’indexation.
H. Hacid, T. Yoshida
5 Conclusion
Cet article propose d’utiliser la structure de graphe de voisinage pour l’indexation à grande
échelle de données multidimensionnelles. Du point de vue de la réduction des accès aux
disques, nous avons proposé une méthode modifiée de recherche de voisinage pour sa mise à
jour sur la base de statistiques sur les données. Nous avions défini des limites (supérieure et in-
férieure) pour la méthode proposée dans (Hacid and Zighed (2005)), et les ont utilisées pour la
construction d’une hyper-sphère localisant la mise à jour. Pour faire face à certains problèmes
dans l’utilisation de la borne supérieure, nous avons aussi mis au point plusieurs mécanismes et
les ont incorporés dans la méthode de mise à jour. En outre, nous avons également proposé une
méthode incrémentale pour la construction basée sur des statistiques calculées sur le graphe
de voisinage. Plusieurs expériences ont été menées pour évaluer l’approche proposée et les
résultats indiquent que notre approche est prometteuse. Toutefois, ils ont aussi révélé que plus
d’efforts devraient être menés pour l’amélioration de sa mise en œuvre.
Dans l’avenir immédiat, nous pensons étudier l’effet d’utiliser un graphe de voisinage en
tant que structure d’indexation et d’optimiser sa mise en œuvre et son implémentation en consi-
dérant les analyses de ce travail. Nous prévoyons également d’étendre la méthode proposée
pour traiter la suppression d’éléments de données (Hacid and Yoshida (2007)), en plus de l’in-
sertion.
Références
Bentley, J. L., 1975. Multidimensional binary search trees used for associative searching. Com-
mun. ACM 18 (9), 509–517.
Gabriel, K. R., Sokal, R. R., 1969. A new statistical approach to geographic variation analysis.
Systematic zoology 18, 259–278.
Gaede, V., Günther, O., 1998. Multidimensional access methods. ACM Comput. Surv. 30 (2),
170–231.
Hacid, H., Yoshida, T., 2007. Incremental neighborhood graphs construction for multidimen-
sional databases indexing. In : Proc. of the 20th Canadian Conference on Artificial Intelli-
gence. pp. 405–416.
Hacid, H., Zighed, D. A., 2005. An effective method for locally neighborhood graphs updating.
In : DEXA. pp. 930–939.
Jaromczyk, J. W., Toussaint, G. T., 1992. Relative neighborhood graphs and their relatives.
P-IEEE 80, 1502–1517.
Katajainen, J., 1988. The region approach for computing relative neighborhood graphs in the
lp metric. Computing 40, 147–161.
MacQueen, J. B., 1967. Some methods for classification and analysis of multivariate observa-
tions. In : Proceedings of 5-th Berkeley Symposium on Mathematical Statistics and Proba-
bility", Berkeley, University of California Press, 1. pp. 281–297.
Preparata, F., Shamos, M. I., 1985. Computationnal Geometry-Introduction. Springer-Verlag,
New-York.
Construction Incrémentale de Graphes de Voisinage avec Accès Réduits aux Disques
Smith, W. D., 1989. Studies in computational geometry motivated by mesh generation. PhD
thesis, Princeton University.
Somervuo, P., Kohonen, T., 1999. Self-organizing maps and learning vector quantization for
feature sequences. Neural Processing Letters 10 (2), 151–159.
Toussaint, G. T., 1980. The relative neighborhood graphs in a finite planar set. Pattern recog-
nition 12, 261–268.
Toussaint, G. T., 1991. Some insolved problems on proximity graphs. D. W Dearholt and F.
Harrary, editors, proc. of the first workshop on proximity graphs. Memoranda in computer
and cognitive science MCCS-91-224. Computing research lab. NewMexico, state university
Las Cruces.
Summary
Efficient neighborhood search in a multi-dimensional space has been studied in several
fields such as pattern recognition and data mining. Neighborhood graphs are geometrical struc-
tures based on the concept of proximity of data items, and they can be utilized to determine the
nearest neighbors for multi-dimensional data. One problem is that, besides the construction
of neighborhood graphs, their update due to the insertion or deletion of data items can also
become expensive. To alleviate this problem, a localization-based method was previously pro-
posed. However, it might not be scalable because it first tries to find out the nearest neighbor
for a queried data item by checking all the data items, which can be time consuming when
the size of dataset gets large. In this paper we propose to go one step further in the usage of
neighborhood graphs for indexing larger multi-dimensional data. By utilizing the structure of
a graph for data indexing, we propose a modified neighborhood graph update method so that
it can work with reduced data access to realize the scalability. Furthermore, we also propose
an incremental neighborhood graph construction method based on statistics of the neighbor-
hood graph. Experiments for evaluating the proposed approach were conducted, and the results
indicate that our approach is promising.
