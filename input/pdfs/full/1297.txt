A Simplified Approach for Testing Real-Time Systems Based
on Action Refinement
Saddek Bensalem∗, Moez Krichen∗,
Lotfi Majdoub∗∗, Riadh Robbana∗∗,
Stavros Tripakis∗∗∗
∗ Verimag Laboratory, Centre Equation 2, avenue de Vignate, 38610, Gières, France.
saddek.bensalem@imag.fr, moez.krichen@imag.fr.
∗∗ LIP2 Laboratory and Polytechnic School of Tunisia.
lotfi.majdoub@ensi.rnu.tn, riadh.robbana@fst.rnu.tn.
∗∗∗ Verimag Laboratory and Cadence Berkeley Labs, 1995 University avenue,
Suite 460, Berkeley, CA 94704, USA.
tripakis@cadence.com.
Abstract. We propose a new method for generating digital-clock tests for real-
time systems. That is, tests which can observe time with only a finite precision.
Our goal from testing is to check the conformance of a given implementation
with respect to a given specification (the model). The method is based on the so-
called action refinement techniques. The main benefit of the method is to save
memory space needed to build and to store tests. One important contribution of
this work is a simplified way for both modelling and testing real-time systems.
We first write a (high-level) simplified version of the model of the system, as an
input-output transition system (IOTS) and then we refine it into a more detailed
(low-level) model as a timed input-output transition system (TIOTS). This same
mechanism applies to the test generation procedure.
1 Introduction
Action refinement techniques are well experimented techniques in the field of hierarchical
design of wide classes of systems. They mainly consist in translating high-level actions into
lower-level ones. That is to move from a high-level abstraction to a lower one until reaching
the implementation level.
Applying action refinement techniques in the field of testing is quite promising. Current
techniques typically suffer from state explosion problems: this includes test generation, storage
and execution. The problem is more dramatic in the case of timed systems, where an extra level
of complexity is introduced by handling time-measuring variables (clocks).
Our main goal in this paper is to reduce the size of generated tests. Our focus is on digital-
clock test generation for real-time systems (Krichen and Tripakis, 2004, 2005) and our ob-
jective is to improve our previous method to generate such tests. To achieve this, we use an
approach based on action refinement. In our timed setting, untimed actions are refined into
timed actions. This helps reduce redundancy and results in optimized storage of useful data.
Real-Time Testing Based on Action Refinement
1.1 Overview of our approach
As already mentioned, we are interested in testing real-time systems. For this goal, we
adopt the following approach. We assume that the model of the system we want to test is
given as an untimed graph. The latter describes the behavior of the considered system using
high-level actions. More precisely this untimed graph is, in our case, an input-output transition
system (IOTS). For instance, an example of an IOTS is the following
→ q double?−→ q′ bright!−→ q′′.
That is the (high-level) model of a lighting device: “q” is the initial state; “double” is a high-
level input-action; and “bright” a high-level output-action. It says that after receiving input
“double” the lighting device will emit output “bright”.
We then assume that each high-level action is refined into a timed path. For instance, the
actions “double” and “bright” are refined, respectively, into
q
touchr?−−−−→
[0,∞]
p
touchr?−−−−→
[0,1]
s
τr−−−→
[1,1]
q′ and q′
brightr!−−−−→
[2,3]
q′′,
where touchr is a low-level input-action, brightr a low-level output-action and τr is an unob-
servable low-level action. That means that input double happens if two consecutive touchr’s
occur within one time-unit interval. The transition s τr−−−→
[1,1]
q′ means that no (observable) action
should happen during the one time-unit following the occurrence of the second touchr. The
interval [0,∞]means that there is no constraint on the timing of occurrence of the first touchr.
Similarly, the refinement of bright means that a time elapse between 2 and 3 time-units is
needed before moving to the desired state.
Thus, the IOTS above is transformed into the following timed input-output transition sys-
tem (TIOTS)
→ q touchr?−−−−→
[0,∞]
p
touchr?−−−−→
[0,1]
s
τr−−−→
[1,1]
q′
brightr!−−−−→
[2,3]
q′′.
We define both analog-clock and digital-clock semantics of a given TIOTS. Analog-clock
means that we observe time with an infinite-precision and digital-clock means that time is ob-
served with only a finite-precision. Given an IOTS, the next step consists in using the algorithm
of (Tretmans, 1999) to generate (untimed) tests. The generated tests are given as trees. Other
refinement techniques are then used to transform these test trees into digital-timed test trees.
The remaining part of the paper is structured as follows. Section 2 recalls the untimed test-
ing framework of (Tretmans, 1999). Section 3 defines the TIOTS model. Section 4 describes
the timed testing framework. The action-refinement rules to transform an IOTS into a TIOTS
are given is Section 5. The method for deriving refined digital-timed tests from untimed tests is
described in Section 6. Section 7 gives an estimation of the memory saving we achieve by the
refinement techniques we propose. Finally, Section 8 concludes the paper and gives directions
for future-work.
1.2 Related Work
To our knowledge, only few works have attempted to investigate the link between testing
and action refinement techniques. In (van der Bijl et al., 2005), the authors present an approach
S. Bensalem et al.
double
single
dim
off
bright
single?
double? dim!
bright!
double?
single?
double?bright!
dim!
off!
off!
single?
Off
DimBright
B-O
B-O
O-D
Fig. 1 – An example of an IOTS: a lighting device.
to automatically obtain (untimed) test cases at some required level of detail by a particular type
of action refinement, so-called atomic linear input-inputs refinement.
2 Model-Based Untimed Conformance Testing
Definition 1 An input-output transition system is a 5-tuple (Q, In,Out, T, q0) where: Q is a
nonempty countable set of states. In is a countable set of input labels. Out is a countable set
of output labels (such that In ∩Out = ∅). T ⊆ Q× (In ∪Out)×Q the transition relation. q0
the initial state.
A triple (q, µ, q′) ∈ T is denoted q µ→ q′. We write q µ→ if ∃q′ ∈ Q : q µ→ q′. An IOTS
is said to be input-complete if ∀q ∈ Q,∀λ ∈ In : q λ→. A state is said to be quiescent if no
output action is possible from it. A new output label δ is considered. For each quiescent state
q, a self-loop q δ→ q is added to the considered IOTS. Next, we consider only IOTS for which
this operation is already achieved. Let Outδ = Out ∪ {δ} and Lδ = In ∪ Outδ . For σ =
µ1 · · ·µn ∈ L+δ , we write q
σ→ q′ if ∃ q1, q2, · · · , qn−1 ∈ Q : q µ1→ q1 µ2→ q2 · · · qn−1 µn→ q′
and write q σ→ if ∃ q′ ∈ Q : q σ→ q′. The sequence of transitions q µ1→ q1 µ2→ q2 · · · qn−1 µn→ q′
is called a path of the IOTS. An IOTS is said to be deterministic if: ∀q, q′, q′′ ∈ Q,∀µ ∈ Lδ :
q
µ→ q′ ∧ q µ→ q′′ ⇒ q′ = q′′. An example of an IOTS is given in Figure 1. It is a modification
of the case study presented in (Krichen and Tripakis, 2004).
For q ∈ Q,P ⊆ Q and σ ∈ L+δ : q after σ =df {q′ | q
σ→ q′}, out(q) =df {µ ∈
Outδ | q µ→}, STraces(q) =df {σ ∈ L+δ | q
σ→}, out(P ) =df
⋃
q∈P out(q). Let Spec =
(Q, In,Out, T, q0) and Imp = (Q′, In,Out, T ′, q′0) be two IOTS. Imp iocoSpec =df ∀σ ∈
STraces(q0) : out(q′0 after σ) ⊆ out(q0 after σ).
Untimed tests can be represented as either total functions or IOTS. A possible test for the
lighting-device example is given in Figure 2.
Real-Time Testing Based on Action Refinement
fail
dim!
pass
single?
δbright! off!
Fig. 2 – An untimed test represented as an IOTS.
The execution of the test T on the implementation Imp can be defined as the parallel
composition of the IOTS defined by T and Imp, with the usual synchronization rules for
transitions carrying the same label. We say that Imp passes the test, denoted Imp passes T , if
state fail is not reachable in the product Imp‖T . We say that an implementation passes (resp.
fails) a set of tests T if it passes all tests (resp. fails at least one test) in T . We say that T is
sound with respect to Spec if ∀Imp : Imp ioco Spec⇒ Imp passes T .
3 Timed Input-Output Transition Systems
Let R be the set of non-negative reals and N the set of non-negative integers. For t ∈ R
and j ∈ N, we write j = btc if t ∈ [j, j + 1). A timed sequence over the set of ac-
tions L = In ∪ Out is a sequence ρ = (µ0, t0)(µ1, t1) · · · (µn, tn) where µi ∈ L and
ti ∈ R and such that ∀i : ti ≤ ti+1. The sequence ρ is observed if each µi occurs at
time ti. If we use a periodic digital-clock with a stepwidth equal to 1 then ρ will be ob-
served as [ρ] = (µ0, j0)(µ1, j1) · · · (µn, jn) such that ∀i : ji = btic. For instance, if
ρ = (µ, 0.3)(ν, 5.6)(ν, 8.4) then [ρ] = (µ, 0)(ν, 5)(ν, 8). ρ and [ρ] are an analog-timed and
a digital-timed sequence, respectively. We will write (µ, 0tick)(ν, 5tick)(ν, 8tick) instead of
(µ, 0)(ν, 5)(ν, 8) to avoid confusion.
Definition 2 A timed input-output transition system is a 7-tuple (Q, In,Out, T, q0, l, u) where:
(Q, In,Out, T, q0) is an IOTS. l ∈ NT is the minimal-delay function. u ∈ (N ∪ {∞})T is the
maximal-delay function such that ∀τ ∈ T : l(τ) ≤ u(τ). By convention we assume that
∀n ∈ N : n ≤ ∞.
Each TIOTS defines a set of accepted timed sequences. The analog-timed trace (µ1, t1) · · · (µn,
tn) is accepted by S = (Q, In,Out, T, q0, l, u) if there exists a path qi0
µ1→ qi1 · · · qin−1 µn→ qin
in S such that qi0 = q0 and ∀j = 1, · · · , n : l(τ) ≤ tj − tj−1 ≤ u(τ) where τ = qij−1
µj→ qij
and t0 = 0.
The digital-timed sequence ρtick is said to be accepted by the TIOTS S if there exists an
analog-timed sequence ρ accepted by S such that ρtick = [ρ]. For each state q of S, the duration
of authorized stay at q must not exceed the maximum duration: maxd(q) = Max {u(τ) | τ =
(q, µ, q′) ∈ T} where “Max” is the maximum operator.
S. Bensalem et al.
Off DimO-D[0,∞]
single? dim!
[2, 3]
Fig. 3 – An example of a TIOTS.
Let cl be a variable ranging over R which measures the time elapsed since the system S has
reached its current state. Variable cl is reset as soon as a new state is visited. We say that S is
occupying the global state 〈q, cl〉. Clearly for each global state 〈q, cl〉, we have cl ≤ maxd(q).
We define two types of valid transitions between global states: (1) Timed transitions: for
d ∈ R, if cl + d ≤ maxd(q) then 〈q, cl〉 d→ 〈q, cl + d〉. (2) Discrete transitions: for µ ∈ L
and τ = (q, µ, q′) ∈ T , if l(τ) ≤ cl ≤ u(τ) then 〈q, cl〉 µ→ 〈q′, 0〉. An example of a TIOTS is
given in Figure 3. That is the timed version of one possible path of the IOTS example shown
in Figure 1.
4 Digital-Clock Testing
An analog-timed trace is an element of (L∪R)∗ and a digital-timed trace an element of (L∪
N)∗. Clearly a unique analog-timed trace and a unique digital-timed trace correspond to each
analog-timed sequence. For instance for ρ = (µ, 0.3)(ν, 5.6)(ν, 8.4), the corresponding analog
and digital traces are σ = 0.3µ 5.3 ν 2.8 ν and σtick = 0tick µ 5tick ν 3tick ν, respectively.
We extend the operator “[ · ]” to the case of timed traces. For instance, 2tick µ 1tick ν 1tick =
[2.1µ 1.2 ν 0.8]. The analog-timed trace σ = t0 µ1 t1 · · ·µn tn is said to be a valid analog-
timed trace of the TIOTS S = (Q, In,Out, T, q0, l, u) if there exist qi0 , · · · , qin ∈ Q such
that qi0 = q0 and 〈qi0 , 0〉 t0→ 〈qi0 , t0〉 µ1→ 〈qi1 , 0〉 t1→ 〈qi1 , t1〉 · · · tn→ 〈qin , tn〉 is a sequence of
valid transitions of S. In this case, we will use the following notation 〈qi0 , 0〉 σ→ 〈qin , tn〉 and
〈qi0 , 0〉 σ→. The digital-timed trace σtick is said to be a valid digital-timed trace of S if there
exists a valid analog-timed trace σ of S such that σtick = [σ]. For q ∈ Q, cl ∈ [0,maxd(q)],P
a set of global states and σ ∈ (R · L)∗ · R: 〈q, cl〉 after σ =df {〈q′, cl′〉 | 〈q, cl〉 σ→ 〈q′, cl′〉},
out(〈q, cl〉) =df {µ ∈ Out | 〈q, cl〉 µ→} ∪ {d ∈ R | 〈q, cl〉 d→}, TTraces(〈q, cl〉) =df {σ ∈
(R · L)∗ · R | 〈q, cl〉 σ→}, DTraces(〈q, cl〉) =df {[σ] |σ ∈ TTraces(〈q, cl〉)}, out(P) =df⋃
〈q,cl〉∈P out(〈q, cl〉).
Let Spec = (Q, In,Out, T, q0, l, u) (specification) and Imp = (Q′, In,Out, T ′, q′0, l
′, u′)
(implementation) be two TIOTS. Imp tiocoSpec =df ∀σ ∈ TTraces(〈q0, 0〉) : out(〈q′0, 0〉
after σ) ⊆ out(〈q0, 0〉 after σ).
A digital-timed test for a specification Spec over L is a total function
D : (L ∪ N)∗ → In ∪ {wait, pass, fail}
which can be represented as an IOTS. Given an implementation Imp and a digital-timed test
D, we have: Imp passes D ⇔ DTraces(Imp) ⊆ DTraces(D), and Imp failsD ⇔ ∃σtick ∈
DTraces(Imp) : σtick /∈ DTraces(D). Given two digital-timed tests D and D′, D′ is said to
be a prefix ofD if DTraces(D′) ⊆ DTraces(D). Consider a suite D of digital-timed tests. We
say that D is sound with respect to Spec if ∀Imp : Imp tioco Spec⇒ Imp passes D.
Real-Time Testing Based on Action Refinement
5 Action Refinement
5.1 Analog-time Action Refinement
The high-level actions to be refined are in Lδ = In ∪ Outδ and the low-level actions are in
Lr = Inr ∪ Outr,δr ∪ {τr}, where Outr,δr = Outr ∪ {δr} and τr is a low-level unobservable
action. Each high-level action µ is refined into a timed-path of the form
analogref(µ) = q1
µr1−−−−→
[l1,u1]
q2
µr2−−−−→
[l2,u2]
· · · qn µ
r
n−−−−→
[ln,un]
qn+1
where µri ∈ Lr and li, ui ∈ N are, respectively, the minimal and maximal delays of the cor-
responding transition. The sequence analogref(µ) is called the analog-time action refinement
of the high level action µ. Each high-level input-action in In is refined into a timed-path over
low-level input-actions in Inr ∪{τr}. Similarly, each high-level output-action in Out is refined
into a timed-path over low-level output-actions in Outr∪{τr}. The length of the analog-timed
refinement of a given low-level action is the number of edges that compose it. For instance the
length of the analog-timed refinement of the action µ above is n.
The refinement of the particular action δ is made as follows:
analogref(δ) = q
δr−−−→
[∆,∆]
q′
where ∆ ∈ N is the maximal waiting time constant (e.g., set either by the system designer or
the tester). That is∆ time-units must elapse before announcing that a timeout occurs.
The refinement technique above carries over in a natural way to the refinement of an IOTS
S into a TIOTS Sr. Given a transition τ = q
µ→ q′ of S, if analogref(µ) = q0 µ
r
0−−−−→
[l0,u0]
q1
µr1−−−−→
[l1,u1]
· · · qn µ
r
n−−−−→
[ln,un]
qn+1 then τ is replaced within Sr with the sequence analogref(τ) = q
µr0−−−−→
[l0,u0]
qτ,1
µr1−−−−→
[l1,u1]
· · · qτ,n µ
r
n−−−−→
[ln,un]
q′ where q and q′ are the same states as in τ and qτ,1, · · · , qτ,n
are the names of the new added states (they must be distinct from the already added ones).
Notice that q and q′ may be the same. If S = (Q, In,Out, T, q0) then Sr = analogref(S) =
(Qr, Inr,Outr,δr , Tr, q
r
0, lr, ur) such that: Qr = Q∪{qτ,i | τ ∈ T}. Tr =
⋃
τ∈T analogref(τ);
qr0 = q0. lr and ur are the functions encoding, respectively, the minimal and maximal delays
appearing in analogref(τ) for all τ ∈ T . We consider again the lighting-device example. The
model given in Figure 1 is indeed a simplified version of the real implementation. In fact, the
lighting-device has only one input action touch. The input high-level actions are introduced
for ease of modeling. The lighting device disposes of a touch-sensitive pad. The user interface
logic is as follows: a simple unique touch corresponds to the high-level input-action single
and two “quick” consecutive touches correspond to the high-level input-action double. The
maximum delay between two consecutive touches considered as a double touch is fixed to 1
time-unit.
As already shown in Figure 3, minimum and maximum delays for the lamp to change
intensity need to be introduced as well. We assume that moving from one intensity level to
another takes between 2 and 3 time units. Furthermore, we fix the maximal waiting time
constant ∆ to 4 time-units. The (analog-time) refinement rules for this example are summed
up within the table shown in Figure 4.
S. Bensalem et al.
µ analogref(µ)
single? q touchr?−−−−→
[0,∞]
q′ τr−−−→
[2,2]
q′′
double? p touchr?−−−−→
[0,∞]
p′ touchr?−−−−→
[0,1]
p′′ τr−−−→
[1,1]
p′′′
dim! r dimr!−−−→
[2,3]
r′
bright! s
brightr!−−−−→
[2,3]
s′
off! t offr!−−−→
[2,3]
t′
δ! u δr!−−−→
[4,4]
u′
Fig. 4 – Analog-time refinement rules for the lighting device example.
5.2 Digital-time Action Refinement
We first start with the refinement of input-actions. Consider a high-level input-action µ
such that analogref(µ) = q0
µr0−−−−→
[l0,u0]
q1
µr1−−−−→
[l1,u1]
· · · qn µ
r
n−−−−→
[ln,un]
qn+1. For the moment, we
assume that ∀i : ui ∈ N (i.e., ui 6= ∞). The digital-time action refinement of µ is defined as
follows:
digitalref(µ) = {t0 µ0 · · · tn µn | ∀i : ti ∈ N ∧ li ≤ ti ≤ ui}.
That is, if we consider analogref(µ) as a TIOTS (with initial state q0) then digitalref(µ) is
the set of valid digital-timed traces of this TIOTS.
Since we are interested in testing, considering unbounded time delays is not of any help
(i.e., by definition, the tester must not wait for ever). Thus, we may consider a maximal time
delay ∆′ ∈ N \ {0} that we will not exceed while generating consecutive inputs. For each
i = 1, · · · , n, if ui = ∞ then the upper bound of the corresponding interval is replaced with
∆′.1
For instance for the high-level input-action “double”, if we take∆′ = 2 then:
digitalref(double) = { 0tick touchr 0tick touchr 1tick,
0tick touchr 1tick touchr 1tick,
1tick touchr 0tick touchr 1tick,
1tick touchr 1tick touchr 1tick,
2tick touchr 0tick touchr 1tick,
2tick touchr 1tick touchr 1tick }.
Notice that we erased on purpose the low-level action τr from the refined digital-timed
traces since τr is unobservable anyway. Also notice that for simplicity, we can take∆′ = ∆.
For testing purposes, we assume that the analog-time refinement of any low-level input-
action starts with q0
µr0−−−−→
[l0,u0]
q1 such that l0 = u0 = 0 and µr0 is an observable action. Thus,
1We assume that for each i = 1, · · · , n, we have li ≤ ∆′.
Real-Time Testing Based on Action Refinement
for instance for the high-level input-action “double”, we will have
analogref(double) = p
touchr?−−−−→
[0,0]
p′ touchr?−−−−→
[0,1]
p′′ τr−−−→
[1,1]
p′′′
and
digitalref(double) = { 0tick touchr 0tick touchr 1tick,
0tick touchr 1tick touchr 1tick }
instead of the digital-time refinement above. This assumption guarantees that the tester may
start the execution of the refined digital-time input-trace before any low-level action occurs.
We also assume that for any two distinct high-level input-actions µ and µ′, for all µr ∈
digitalref(µ) and µ′r ∈ digitalref(µ′), µr is not a prefix of µ′r. The latter is a quite natural
assumption. It says that there is some kind of determinism between the refined low-level
digital-timed input-traces. We give a counterexample. Consider the two distinct high-level
input actions µ and µ′ and the two low-level digital-timed input-traces µ1r and µ
2
r such that
µ1r ∈ digitalref(µ) and µ1r · µ2r ∈ digitalref(µ′). After executing µ1r , the tester will not know
whether it should wait for outputs (the ones due to the execution of µ) or to continue executing
the low-level actions corresponding to µ2r (in order to finish the execution of the high-level
input-action µ′). It is not difficult to check that this assumption is true for the two high-level
input-actions single and double of our running example.
Now we move to digital-time action refinement of high-level output-actions. It is quite
similar to input-actions. The main difference is that we need to represent refinements as (de-
terministic) trees and no longer as sets of traces. For instance the digital-time action-refinement
of the high-level output-action dim is shown in Figure 5 (a). The leaves of the tree are labeled
with the name of the corresponding high-level output-action (the labels within rectangular
boxes in the figure).
The operator “digitalref( · )” is extended in the natural way to the case of a set of output-
actions. For instance, the digital-time action-refinement of the set {dim, bright} of output-
actions is shown in Figure 5 (b). As for input-actions, we assume that the refinement of a given
output-action is not the prefix of the refinement of an other output-action. Each leaf of the tree
is labeled with the name of the corresponding high-level output-action. These labels will help
us remember which high-level output-action each path of the tree corresponds to.
The reason why we should refine low-level output-actions as trees is the fact that we have
to consider only deterministic test cases. The set of low-level output-actions {dim, bright} is a
good example which illustrates this point. Suppose we refine the two output-actions separately.
In that case, we will have two edges emanating from the initial node of Figure 5 (b) which
are labeled with 2tick! instead of only one and any corresponding test case will no longer be
deterministic anymore.
Notice that, the integer time-delays are marked as output-actions in the figure since the
tester considers them so.
Consider the digital-timed trace σtick ∈ (Lr∪N)∗×Lr. We denote P(σtick) the projection
of σtick to Lr, obtained by “erasing” from σtick all actions in N. For example, if σtick =
µ1ν2µ3µ, then P(σtick) = µνµµ.
For a better optimization, we proceed as follows. We collapse all nodes reached by digital-
timed traces with the same projection on Lr into a single node. For instance in Figure 5 (b),
we may collapse the two leaves labeled with the output-action bright into a single node and
the two nodes labeled with dim as well.
S. Bensalem et al.
dim!
(a)
2tick! 1tick!
dimr!dimr!
dim! dim! dim!
bright!
2tick!
dimr!
1tick! brightr!
dimr!
(b)
brightr!
bright!
FIG. 5 – The two trees representing (a) the digital-time action-refinements of the high-level
output-action dim and (b) the set of high-level output-actions {dim, bright}, respectively.
6 Digital-Timed Test Generation
The method we propose for generating digital-timed tests consists in transforming an ini-
tially untimed test “T ” into a timed one “Tr” using the refinement techniques introduced so
far. We assume that T is given as a tree. An internal node of T is called an input-node if it
has a unique outgoing edge labeled with an input-action. Similarly, an internal node of T is
called an output-node if all its outgoing edges are labeled with output-actions. To obtain Tr
we proceed as follows:
S 1. We make a copy of T (we already call it Tr);
S 2. We omit all edges of Tr leading to fail;
S 3. We refine all edges of Tr and add progressively the new edges leading to fail.
Step “S 3” is achieved as follows:
(I) For an input-node q, let e = q
µ→ q′ be the outgoing edge from q:2
1. We choose a possible digital-time action-refinement µr = t0µ0 · · ·µntn+1 of µ
(i.e., µr ∈ digitalref(µ)).
2. We replace e in Tr with the path qi0
t0→ qi1 µ0→ qi2 · · · µn→ qi2n+2
tn+1→ qi2n+3 , where
qi0 = q, qi2n+3 = q
′ and the other qij are new names not used in the past.
3. For each tj 6= 0 and ν ∈ Outr,δr , we add a new edge qi2j ν→ fail to Tr.3
We consider the test case of Figure 2. We refine the edge emanating from the initial node of
the test tree. This edge is labelled with the high-level input-action single. The low-level digital-
timed input-trace we choose to refine this input-action with is touchr? 2tick!. The different
steps of the refinement of this edge are given in Figure 6. To make it clearer the new added
nodes are filled in with black and the new added edges leading to fail are drawn as dashed
arrows.
2We may have q′ = pass.
3This step allows to reject all the low-level output-actions that may be observed during the execution of refined
digital-timed input-trace µr .
Real-Time Testing Based on Action Refinement
(a) (b) (c)
touchr? touchr?single? 2tick!2tick!
fail
brightr! dimr! offr! δr
FIG. 6 – The different steps for refining an edge of a test case labelled with the low-level
input-action single: (a) the original high-level edge, (b) the corresponding low-level digital-
timed path, (c) adding the edges leading to fail.
(II) For an output-node q, let β = {µ ∈ Outδ | ∃q′ : q µ→ q′ is an edge of Tr} be the set of
labels of the outgoing edges from q:
1. We build the tree digitalref(β).
2. For each edge q
µ→ q′, we replace the leaves of digitalref(β) labeled with µ with
the one node q′.4
3. We replace the set of edges {q µ→ q′ |µ ∈ β} of Tr with digitalref(β).
4. For each internal node p of digitalref(β) and ν ∈ Outr,δr , if no outgoing edge from
p is labeled with ν then we add a new edge p ν→ fail to digitalref(β).
5. For each internal node p of digitalref(β), If no outgoing edge from p is labelled
with some t ∈ N \ {0} then we add a new edge p 1tick→ fail to digitalref(β).
Again, we consider the test case of Figure 2. Now, we refine the edge labelled with the
high-level output-action dim. We call q the node from which this edge emanates. Clearly,
q is an output-node. The set β associated with q is the singleton set {dim}. The digital-
timed refinement of the set {dim} is already given in Figure 5 (a). The different steps of the
refinement of the edge labelled with dim are given in Figure 7. As for Figure 6, the new added
nodes are the black ones and the edges leading to fail are drawn as dashed arrows. 5
If we concatenate the two refinements of Figure 6 and Figure 7, we obtain a possible
digital-timed refinement of the test case of Figure 2. The refined test case is given in Figure 8.
The method we propose to generate digital-timed tests is sound in the following sense.
Consider an IOTS Spec and an untimed test T .
Proposition 1 If T is generated by the untimed test genertaion algorithm of (Tretmans, 1999)
then digitalref(T ) is sound with respect to analogref(Spec).
4That means that the tester should behave in the same manner after any possible refinement of µ. Notice that, due
to this, the refined test cases are DAG (Directed Acyclic Graphs) and no longer trees.
5In order not to overload the figure we draw only one dashed arrow for several edges leading to fail.
S. Bensalem et al.
δr
fail
fail
offr! δr
fail
brightr!
2tick!
1tick!
brightr!
brightr!
pass
dimr!
dimr!
pass
dimr!
1tick!offr!
pass
pass
offr!
δr
1tick!
2tick!
dimr!
dimr!
dim!
pass
δ
pass
dim!
q
q q
fail
off!bright!
q
(c)(b)(a) (d)
FIG. 7 – The different steps for refining the edges emanating from an output-node: (a) the
original edges emanating from the output-node q, (b) removing all the high-level edges leading
to fail, (c) replacing the edge labelled with dim with its digital-timed refinement, (d) adding
the low-level edges leading to fail.
δr
fail
fail
offr! δr
fail
brightr!
1tick!
brightr!
brightr!
pass
dimr!
dimr!
pass
dimr!
1tick!
offr!
offr!
δr
fail
δr
offr!brightr!
dimr!
touchr? 2tick!
2tick!
Fig. 8 – A possible digital-timed refinement of the test case of Figure 2.
Real-Time Testing Based on Action Refinement
7 Estimation of Memory Saving
Consider an IOTS S = (Q, In,Out, T, q0) and the corresponding set of refinement rules.
Let n be the size of the set of nodes Q and m the size of T . We assume that the length
of the analog-timed refinement of each edge of Spec is between lmin and lmax. Let Sr =
analogref(S). We call Qr the set of nodes of Sr and Tr its set of transitions. Let nr be the size
of Qr andmr the size of Tr. Then, it is not difficult to check the following.
Proposition 2 We have:
1. lmin ∗m ≤ mr ≤ lmax ∗m ;
2. n+ (lmin − 1) ∗m ≤ nr ≤ n+ (lmax − 1) ∗m .
Thus, the memory saving at the specification level is linear in the number of transitions of
the low-level specification S and the length of the analog-timed refinements.
Now, we consider an untimed test T generated by the untimed test generation algorithm
of (Tretmans, 1999). Let Tr = digitalref(T ). Also, let p and pr be the number of edges
composing T and Tr, respectively. We assume that∆ = ∆′.
Proposition 3 We have: lmin ∗ p ≤ pr ≤ (2 ∗∆+ 1) ∗ lmax ∗ p.
8 Conclusion
In this work, we succeeded to make the link between: (I) The framework for untimed
testing based on the model of IOTS and the (untimed) conformance relation ioco (Tretmans,
1999) and; (II) Our framework for real-time testing based on the model of TIOTS and the timed
conformance relation tioco (Krichen and Tripakis, 2004). We have proposed a new method for
generating digital-clock tests based on the so-called action refinement techniques.
Possible future directions of this work are: (1) To extend the method from TIOTS to general
timed automata specifications. (2) To be able to handle more general, aperiodic digital-clock
models, as in (Krichen and Tripakis, 2004, 2005). (3) To consider more general action refine-
ment rules (e.g., an action is refined into a tree rather than a "linear" trace).
References
Krichen, M. and S. Tripakis (2004). Black-box conformance testing for real-time systems. In
11th International SPIN Workshop on Model Checking of Software (SPIN’04), Volume 2989
of LNCS. Springer. 1, 3, 12
Krichen, M. and S. Tripakis (2005). An expressive and implementable formal framework for
testing real-time systems. In The 17th IFIP Intl. Conf. on Testing of Communicating Systems
(TestCom’05), Volume 3502 of LNCS. Springer. 1, 12
Tretmans, J. (1999). Testing concurrent systems: A formal approach. In CONCUR’99, Volume
1664 of LNCS. Springer. 2, 10, 12
van der Bijl, M., A. Rensink, and J. Tretmans (2005). Action refinement in conformance
testing. In F. Khendek and R. Dssouli (Eds.), TestCom, Volume 3502 of Lecture Notes in
Computer Science, pp. 81–96. Springer. 2
